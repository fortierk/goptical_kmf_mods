This is goptical.info, produced by makeinfo version 6.1 from
goptical.texi.

This manual is for GNU Goptical.  Copyright (C) 2010-2011 Free Software
Foundation, Inc

     Copyright (C) 2010-2011 Free Software Foundation, Inc.  Permission
     is granted to copy, distribute and/or modify this document under
     the terms of the GNU Free Documentation License, Version 1.3 or any
     later version published by the Free Software Foundation; with no
     Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.
     A copy of the license is included in the section entitled "GNU Free
     Documentation License".
INFO-DIR-SECTION Scientific software
START-INFO-DIR-ENTRY
* goptical:                   GNU Optical design and simulation library
END-INFO-DIR-ENTRY


File: goptical.info,  Node: Top,  Next: Introduction

Top
***

* Menu:

* Introduction:: 
* Conventions:: 
* Tutorial:: 
* API documentation:: 
* GNU Free Documentation License:: 


File: goptical.info,  Node: Introduction,  Next: Conventions,  Prev: Top,  Up: Top

1 Introduction
**************

Goptical is a C++ optical design and simulation library.  Goptical is
free software and is part of the GNU project .

   It provides model classes for optical components, surfaces and
materials.  It enables building optical systems by creating and placing
various optical components in a 3d space and simulates light propagation
through the system.  Classical optical design analysis tools can be used
on optical systems.

   It takes advantages of the C++ object model to allow building complex
optical systems with a few classes instanciations as optical components
are represented by language objects.

* Menu:

* Features list:: 


File: goptical.info,  Node: Features list,  Up: Introduction

1.1 Features list
=================

   * Goptical relies on an object oriented optical design approach.
     This allows designing optical component models and reuse them
     nested in other designs.  Components are stored in herarchical form
     and live in a three-dimentional space with group (*note
     Sys_Group_class_reference::) local coordinates.

   * Support for sequential and non-sequential ray-tracing.

   * Available components include:

        * Single optical surfaces (*note
          Sys_OpticalSurface_class_reference::)

        * Lenses (*note Sys_Lens_class_reference::)

        * Mirrors (*note Sys_Mirror_class_reference::),

        * Point sources (*note Sys_SourcePoint_class_reference::) and

        * Image (*note Sys_Image_class_reference::) planes.

     Surface curve and material used by optical components are described
     using dedicated models.

   * Several surface curvature models are available:

        * Conic (*note Curve_Conic_class_reference::) curves.

        * Polynomial (*note Curve_Polynomial_class_reference::) curves.

        * Rotationally symmetric (*note Curve_Spline_class_reference::)
          splines and Grid (*note Curve_Grid_class_reference::) splines.

        * Zernike polynomials (*note Curve_Zernike_class_reference::).

        * Foucault test (*note Curve_Foucault_class_reference::) curves.

        * Composition (*note Curve_Composer_class_reference::) of other
          curve models.

        * Array (*note Curve_Array_class_reference::) of other curve
          models.

        * User defined (*note A custom surface curve model::) curve
          models.

     Most curve models can be described using model specific parameters
     or by best fitting any curve object.

   * Several glass material models are available:

        * Interpolated dispersion (*note
          Material_DispersionTable_class_reference::) glass model

        * Abbe number (*note Material_Abbe_class_reference::) and mil
          number (*note Material_Mil_class_reference::) model glass
          model.

        * Sellmeier (*note Material_Sellmeier_class_reference::) glass
          model.

        * Schott (*note Material_Schott_class_reference::) glass model.

        * Conrady (*note Material_Conrady_class_reference::) glass
          model.

        * Herzberger (*note Material_Herzberger_class_reference::) glass
          model.

        * A simple reflective surfaces mirror (*note
          Material_Mirror_class_reference::) model.

        * A more accurate metal (*note Material_Metal_class_reference::)
          material model.

        * Air (*note Material_Air_class_reference::) and vaccum (*note
          Material_Vacuum_class_reference::) models.

   * Surfaces outline shapes are described by a set of model classes
     too:

        * Disk (*note Shape_Disk_class_reference::) shapes model.

        * Ring (*note Shape_Ring_class_reference::) shapes model.

        * Ellipse (*note Shape_Ellipse_class_reference::) shapes model.

        * Rectangle (*note Shape_Rectangle_class_reference::) shapes
          model.

        * Regular polygon (*note Shape_RegularPolygon_class_reference::)
          and User defined polygon (*note
          Shape_Polygon_class_reference::) shapes models.

   * Optical system analysis tools include:

        * Layout and rays rendering in 2d and 3d,

        * Best point of focus (*note Analysis_Focus_class_reference::)
          finding.

        * Various ray fan (*note Analysis_RayFan_class_reference::)
          plots.

        * Spot diagram (*note Analysis_Spot_class_reference::) plots.

   * Several graphical output driver are available to render optical
     layouts and plots:

        * output in Svg (*note Io_RendererSvg_class_reference::) vector
          format.

        * output in bitmap format using the Gd (*note
          Io_RendererGd_class_reference::) library.

        * output in Dxf (*note Io_RendererDxf_class_reference::) CAD
          format.

        * output in various formats via the PlPlot (*note
          Io_RendererPlplot_class_reference::) library.

        * X11 (*note Io_RendererX11_class_reference::) display on UNIX
          boxes.

        * 3d display using the OpenGL (*note
          Io_RendererOpengl_class_reference::) library.

        * output in X3D (*note Io_RendererX3d_class_reference::), a
          standard 3d format.

   * Various optical design file formats can be read:

        * Oslo glass catalog

        * Zemax glass catalog and optical designs


File: goptical.info,  Node: Conventions,  Next: Tutorial,  Prev: Introduction,  Up: Top

2 Conventions
*************

* Menu:

* Coordinates system:: 
* Measurement units:: 
* Object references:: 


File: goptical.info,  Node: Coordinates system,  Next: Measurement units,  Up: Conventions

2.1 Coordinates system
======================

Each optical element in Goptical lives in its own coordinates system.
It's usually located at _(0, 0, 0)_ with the _Z_ axis being the local
optical axis.

[coordinates]

File: goptical.info,  Node: Measurement units,  Next: Object references,  Prev: Coordinates system,  Up: Conventions

2.2 Measurement units
=====================

   * Lengths are expressed using millimeter unit.

   * Wavelengths are expressed in nanometer unit in vacuum.

   * Absolute refractive indexes are used, with 1 being the refractive
     index of vacuum.


File: goptical.info,  Node: Object references,  Prev: Measurement units,  Up: Conventions

2.3 Object references
=====================

C++ objects are used to model optical elements, materials, curvatures,
shapes and other kinds of object Goptical deals with.  As the optical
system is being built, some objects keep references to other objects.

   The ref smart pointer class is used to manage objects in a convenient
way.  Objects can either be statically allocated or dynamically
allocated.  Both can then be passed to reference holder objects in the
same way but only dynamically allocated objects will be automatically
deleted when not used anymore:

       using namespace Goptical;

       Sys::System     sys;

       // statically allocated object added to the system
       Sys::SourceRays src1(Math::vector3_0);
       sys.add(src1);

       // dynamically allocated object added to the system
       ref<Sys::SourceRays> src2 = ref<Sys::SourceRays>::create(Math::vector3_0);
       sys.add(src2);


File: goptical.info,  Node: Tutorial,  Next: API documentation,  Prev: Conventions,  Up: Top

3 Tutorial
**********

This section contains some commented example of applications and codes
which use the Goptical library to model optical systems.

* Menu:

* A simple refractor design:: 
* A photo lens design:: 
* System hierarchy and groups:: 
* A parameterizable segmented mirror model:: 
* A custom surface curve model:: 


File: goptical.info,  Node: A simple refractor design,  Next: A photo lens design,  Up: Tutorial

3.1 A simple refractor design
=============================

[Refractor optical system 2d layout]
* Menu:

* Building the optical system:: 
* Performing light propagation:: 
* Rendering optical layout and rays:: 
* Performing a ray fan analysis:: 


File: goptical.info,  Node: Building the optical system,  Next: Performing light propagation,  Up: A simple refractor design

3.1.1 Building the optical system
---------------------------------

Unlike much optical design software which relies on a list of surfaces
to sequentially propagate light through the system, Goptical uses an
object representation of the optical system in 3d space.

   To model an optical system with Goptical, we just have to instantiate
components and add them to the system.

   For this refractor example we first need to deal with glass materials
used in the design.  Our achromatic refractor design needs two lenses of
different glass materials.  In this example we choose to model Bk7 and
F3 glasses with the Sellmeier model:

     // code from examples/simple_refractor/refractor.cc:64

       Material::Sellmeier bk7(1.03961212, 6.00069867e-3, 0.231792344,
                               2.00179144e-2, 1.01046945, 1.03560653e2);

       Material::Sellmeier f3(8.23583145e-1, 6.41147253e-12, 7.11376975e-1,
                              3.07327658e-2, 3.12425113e-2, 4.02094988);


   The Sys::OpticalSurface (*note Sys_OpticalSurface_class_reference::)
class is used to model a single optical surface.

   The two lenses have the same disk outline shape, so we declare the
shape model once:

       Shape::Disk   lens_shape(100); // lens diameter is 100mm

       // 1st lens, left surface
       Curve::Sphere curve1(2009.753); // spherical curve with given radius of curvature
       Curve::Sphere curve2(-976.245);


   Surface curves rely on dedicated models which are not dependent on
optical component being used.  Here we need two simple spherical curves
for the first lens.

   The first lens component can then be instantiated.  We need to
specify its 3d position, thickness, shape model, curve models and
material models.  Material::none (*note _528::) will later be replaced
by system environment material.

       Sys::OpticalSurface s1(Math::Vector3(0, 0, 0), // position,
                              curve1, lens_shape,     // curve & aperture shape
                              Material::none, bk7);   // materials

       // 1st lens, right surface
       Sys::OpticalSurface s2(Math::Vector3(0, 0, 31.336),
                              curve2, lens_shape,
                              bk7, Material::none);


   More convenient optical surface constructors are available for simple
cases, with circular aperture and spherical curvature.  They are used
for the second lens:

       // 2nd lens, left surface
       Sys::OpticalSurface s3(Math::Vector3(0, 0, 37.765), // position,
                              -985.291, 100,        // roc & circular aperture radius,
                              Material::none, f3);  // materials

       // 2nd lens, right surface
       Sys::OpticalSurface s4(Math::Vector3(0, 0, 37.765+25.109),
                              -3636.839, 100,
                              f3, Material::none);


   The Sys::Lens (*note Sys_Lens_class_reference::) class is more
convenient to use for most designs as it can handle a list of surfaces.
In this example we choose to use the Sys::OpticalSurface (*note
Sys_OpticalSurface_class_reference::) class directly to show how things
work.  The convenient method is used in the next example (*note A photo
lens design::).

   We then create a point light source at infinite distance with a
direction vector aimed at entry surface (left of first lens):

       // light source
       Sys::SourcePoint source(Sys::SourceAtInfinity,
                               Math::Vector3(0, 0, 1));


   And we finally create an image plane near the expected focal point:

       // image plane
       Sys::Image    image(Math::Vector3(0, 0, 3014.5),  // position
                           60);                           // square size,


   All these components need to be added to an optical system:

       Sys::System   sys;

       // add components
       sys.add(source);
       sys.add(s1);
       sys.add(s2);
       sys.add(s3);
       sys.add(s4);
       sys.add(image);


   This simple optical design is ready for ray tracing and analysis.


File: goptical.info,  Node: Performing light propagation,  Next: Rendering optical layout and rays,  Prev: Building the optical system,  Up: A simple refractor design

3.1.2 Performing light propagation
----------------------------------

Light propagation through the optical system is performed by the
Trace::Tracer (*note Trace_Tracer_class_reference::) class.  There are
several tracer parameters which can be tweaked before starting light
propagation.  Some default parameters can be set for an optical system
instance; they will be used for each new tracer created for the system.

   When light is propagated through the system, a tracer may be
instructed to keep track of rays hitting or generated by some of the
components for further analysis.

   Some analysis classes (*note Analysis_namespace_reference::) are
provided which embed a tracer configured for a particular analysis, but
it's still possible to request a light propagation by directly
instantiating a tracer object.

   There are two major approaches to trace rays through an optical
system:

   * Sequential ray tracing: This requires an ordered list of surfaces
     to traverse.  Rays are generated by the light source and propagated
     in the specified sequence order.  Any light ray which doesn't reach
     the next surface in order is lost.

   * Non-sequential ray tracing: Rays are generated by the light source
     and each ray interacts with the first optical component found on
     its path.  Rays are propagated this way across system components
     until they reach an image plane or get lost.

   The default behavior in Goptical is to perform a non-sequential ray
trace when no sequence is provided.

Non-sequential ray trace
........................

A non-sequential ray trace needs the specification of an entrance pupil
so that rays from light sources can be targeted at optical system entry.

   Performing light propagation only needs instantiation of a
Trace::Tracer (*note Trace_Tracer_class_reference::) object and
invocation of its Trace::Tracer::trace (*note _1425::) function.  Tracer
parameters are inherited from system default tracer parameters:

       sys.set_entrance_pupil(s1);
       Trace::Tracer tracer(sys);
       tracer.trace();


   When performing a non-sequential ray trace, only optical components
based on Sys::Surface (*note Sys_Surface_class_reference::) will
interact with light.

   All enabled light sources which are part of the system are
considered.

Sequential ray trace
....................

Switching to a sequential ray trace is easy: The sequence is setup from
components found in the system, in order along the Z axis.

       Trace::Sequence seq(sys);

       sys.get_tracer_params().set_sequential_mode(seq);


   More complicated sequences must be created empty and described
explicitly using the Trace::Sequence::add (*note _1410::) function.

   Optical system and sequence objects can be displayed using stl
streams:

       std::cout << "system:" << std::endl << sys;
       std::cout << "sequence:" << std::endl << seq;


   Ray tracing is then performed in the same way as for non-sequential
ray traces:

       Trace::Tracer tracer(sys);
       tracer.trace();


   When performing a sequential ray trace, all optical components can
process incoming light rays.

   A single light source must be present at the beginning of the
sequence.


File: goptical.info,  Node: Rendering optical layout and rays,  Next: Performing a ray fan analysis,  Prev: Performing light propagation,  Up: A simple refractor design

3.1.3 Rendering optical layout and rays
---------------------------------------

The result of ray tracing is stored in a Trace::Result (*note
Trace_Result_class_reference::) object which stores information about
generated and intercepted rays and involved components for each ray.
Not all rays' interactions are stored by default, and the result object
must be first configured to specify which interactions should be stored
for further analysis.

   Here we want to draw all rays which are traced through the system.
We first have to instruct our Trace::Result (*note
Trace_Result_class_reference::) object to remember which rays were
generated by the source component in the system, so that it can used as
a starting point for drawing subsequently scattered and reflected rays.

   We use an Io::Renderer (*note Io_Renderer_class_reference::) based
object which is able to draw various things.  We use it to draw system
components as well as to recursively draw all rays generated by light
sources.

   Here is what we need to do in order:

   * Instantiate a renderer object able to write graphics in some output
     format.

   * Fit renderer viewport to optical system.

   * Draw system components.

   * Optionally change the ray distribution on entrance pupil so that
     only meridional rays are traced.

   * Instruct the result object to keep track of rays generated by the
     source component.

   * Perform the ray tracing.

   * Draw traced rays.

       Io::RendererSvg renderer("layout.svg", 1024, 100);

       // draw 2d system layout
       sys.draw_2d_fit(renderer);
       sys.draw_2d(renderer);

       Trace::Tracer tracer(sys);

       // trace and draw rays from source
       tracer.get_params().set_default_distribution(
         Trace::Distribution(Trace::MeridionalDist, 5));
       tracer.get_trace_result().set_generated_save_state(source);
       tracer.trace();
       tracer.get_trace_result().draw_2d(renderer);



File: goptical.info,  Node: Performing a ray fan analysis,  Prev: Rendering optical layout and rays,  Up: A simple refractor design

3.1.4 Performing a ray fan analysis
-----------------------------------

The Analysis (*note Analysis_namespace_reference::) namespace contains
classes to perform some common analysis on optical systems.  Analysis
classes may embed a Trace::Tracer (*note Trace_Tracer_class_reference::)
object if light propagation is needed to perform analysis.

   Ray fan plots can be computed using the Analysis::RayFan (*note
Analysis_RayFan_class_reference::) class which is able to plot various
ray measurements on both 2d plot axes.

   The example below shows how to produce a transverse aberration plot
by plotting entrance ray height against transverse distance:

       Io::RendererSvg     renderer("fan.svg", 640, 480, Io::rgb_white);

       Analysis::RayFan    fan(sys);

       // select light source wavelens
       source.clear_spectrum();
       source.add_spectral_line(Light::SpectralLine::C);
       source.add_spectral_line(Light::SpectralLine::e);
       source.add_spectral_line(Light::SpectralLine::F);

       // get transverse aberration plot
       ref<Data::Plot> fan_plot = fan.get_plot(Analysis::RayFan::EntranceHeight,
                                               Analysis::RayFan::TransverseDistance);

       fan_plot->draw(renderer);


[refractor_fan]

File: goptical.info,  Node: A photo lens design,  Next: System hierarchy and groups,  Prev: A simple refractor design,  Up: Tutorial

3.2 A photo lens design
=======================

[Tessar lens system 2d layout with chief and marginal rays]
* Menu:

* Using the Lens component:: 
* Adding multiple light sources:: 
* Plotting spot diagram:: 
* Plotting ray fans:: 


File: goptical.info,  Node: Using the Lens component,  Next: Adding multiple light sources,  Up: A photo lens design

3.2.1 Using the Lens component
------------------------------

The Sys::Lens (*note Sys_Lens_class_reference::) class is a convenient
way to model a list of optical surfaces.  In this example we use it to
model a Tessar photo lens by adding all optical surfaces to the lens
object.  Several functions are available to add surfaces to the lens;
one of the simplest can create spherical surfaces with circular aperture
for us.  In this example, the glass material models used are created on
the fly:

     // code from examples/tessar_lens/tessar.cc:70

       Sys::Lens     lens(Math::Vector3(0, 0, 0));

       //               roc,            ap.radius, thickness,

       lens.add_surface(1/0.031186861,  14.934638, 4.627804137,
                        ref<Material::AbbeVd>::create(1.607170, 59.5002));

       lens.add_surface(0,              14.934638, 5.417429465);

       lens.add_surface(1/-0.014065441, 12.766446, 3.728230979,
                        ref<Material::AbbeVd>::create(1.575960, 41.2999));

       lens.add_surface(1/0.034678487,  11.918098, 4.417903733);

       lens.add_stop   (                12.066273, 2.288913925);

       lens.add_surface(0,              12.372318, 1.499288597,
                        ref<Material::AbbeVd>::create(1.526480, 51.4000));

       lens.add_surface(1/0.035104369,  14.642815, 7.996205852,
                        ref<Material::AbbeVd>::create(1.623770, 56.8998));

       lens.add_surface(1/-0.021187519, 14.642815, 85.243965130);

       sys.add(lens);



File: goptical.info,  Node: Adding multiple light sources,  Next: Plotting spot diagram,  Prev: Using the Lens component,  Up: A photo lens design

3.2.2 Adding multiple light sources
-----------------------------------

The Sys::SourcePoint (*note Sys_SourcePoint_class_reference::) class can
be used to create a point light source suitable for analysis, but we
sometimes want to trace custom rays.  This can be achieved by using the
Sys::SourceRays (*note Sys_SourceRays_class_reference::) component
class.

   In this example we add both source types to our system but enable a
single one at the same time.  The Sys::SourceRays (*note
Sys_SourceRays_class_reference::) is used to draw a 2d layout with chief
and marginal rays whereas the Sys::SourcePoint (*note
Sys_SourcePoint_class_reference::) source is used with multiple
wavelengths for ray fan and spot diagram analysis:

       Sys::SourceRays  source_rays(Math::Vector3(0, 27.5, -1000));

       Sys::SourcePoint source_point(Sys::SourceAtFiniteDistance,
                                     Math::Vector3(0, 27.5, -1000));

       // add sources to system
       sys.add(source_rays);
       sys.add(source_point);

       // configure sources
       source_rays.add_chief_rays(sys);
       source_rays.add_marginal_rays(sys, 14);

       source_point.clear_spectrum();
       source_point.add_spectral_line(Light::SpectralLine::C);
       source_point.add_spectral_line(Light::SpectralLine::e);
       source_point.add_spectral_line(Light::SpectralLine::F);


   The object is located at -1000 on the Z axis and has a height of
27.5.


File: goptical.info,  Node: Plotting spot diagram,  Next: Plotting ray fans,  Prev: Adding multiple light sources,  Up: A photo lens design

3.2.3 Plotting spot diagram
---------------------------

The Analysis::Spot (*note Analysis_Spot_class_reference::) class can be
used to plot spot diagrams:

         sys.enable_single<Sys::Source>(source_point);

         sys.get_tracer_params().set_default_distribution(
           Trace::Distribution(Trace::HexaPolarDist, 12));

         Analysis::Spot spot(sys);

           Io::RendererSvg renderer("spot.svg", 300, 300, Io::rgb_black);

           spot.draw_diagram(renderer);


[Tessar lens spot diagram]
           Io::RendererSvg renderer("spot_intensity.svg", 640, 480);

           ref<Data::Plot> plot = spot.get_encircled_intensity_plot(50);

           plot->draw(renderer);


[tessar_spot_intensity]

File: goptical.info,  Node: Plotting ray fans,  Prev: Plotting spot diagram,  Up: A photo lens design

3.2.4 Plotting ray fans
-----------------------

Various ray fan plots can be obtained by using the Analysis::RayFan
(*note Analysis_RayFan_class_reference::) class:

         sys.enable_single<Sys::Source>(source_point);

         Analysis::RayFan fan(sys);

           Io::RendererSvg renderer("opd_fan.svg", 640, 480);

           ref<Data::Plot> fan_plot = fan.get_plot(Analysis::RayFan::EntranceHeight,
                                                   Analysis::RayFan::OpticalPathDiff);

           fan_plot->draw(renderer);



[tessar_opdfan]
           Io::RendererSvg renderer("transverse_fan.svg", 640, 480);

           ref<Data::Plot> fan_plot = fan.get_plot(Analysis::RayFan::EntranceHeight,
                                                   Analysis::RayFan::TransverseDistance);

           fan_plot->draw(renderer);



[tessar_transverse]
           Io::RendererSvg renderer("longitudinal_fan.svg", 640, 480);

           ref<Data::Plot> fan_plot = fan.get_plot(Analysis::RayFan::EntranceHeight,
                                                   Analysis::RayFan::LongitudinalDistance);

           fan_plot->draw(renderer);



[tessar_longitudinal]

File: goptical.info,  Node: System hierarchy and groups,  Next: A parameterizable segmented mirror model,  Prev: A photo lens design,  Up: Tutorial

3.3 System hierarchy and groups
===============================

Goptical allows arranging components of the optical system in a
hierarchical manner.  Optical component classes all inherit from the
Sys::Element (*note Sys_Element_class_reference::) class.  Elements
which inherit from the Sys::Group (*note Sys_Group_class_reference::)
class can contain nested elements.

   Each element has a local coordinate system and stores a
Math::Transform (*note Math_Transform_3_class_reference::)<3> object
which describes its translation and rotation relative to the parent
coordinate system.

* Menu:

* The Lens component:: 
* A newton telescope with corrector:: 


File: goptical.info,  Node: The Lens component,  Next: A newton telescope with corrector,  Up: System hierarchy and groups

3.3.1 The Lens component
------------------------

The Sys::Lens (*note Sys_Lens_class_reference::) optical component is a
good example of group component.  It is based on the Sys::Group (*note
Sys_Group_class_reference::) class so that it can embed
Sys::OpticalSurface (*note Sys_OpticalSurface_class_reference::) and
Sys::Stop (*note Sys_Stop_class_reference::) elements.

   When displaying the system and ray trace sequence of the tessar lens
design described in the previous section (*note A photo lens design::),
we notice that the system hierarchy has been flattened in the sequence:

     system:
        [1]Goptical::Sys::Lens at [0, 0, 0]
        [10]Goptical::Sys::Image at [0, 0, 125.596]
        [11]Goptical::Sys::SourceRays at [0, 27.5, -1000]
        [12]Goptical::Sys::SourcePoint at [0, 27.5, -1000]
     sequence:
        [11]Goptical::Sys::SourceRays at [0, 27.5, -1000]
        [12]Goptical::Sys::SourcePoint at [0, 27.5, -1000]
        [2]Goptical::Sys::OpticalSurface at [0, 0, 0]
        [3]Goptical::Sys::OpticalSurface at [0, 0, 4.6278]
        [4]Goptical::Sys::OpticalSurface at [0, 0, 10.0452]
        [5]Goptical::Sys::OpticalSurface at [0, 0, 13.7735]
        [6]Goptical::Sys::Stop at [0, 0, 18.1914]
        [7]Goptical::Sys::OpticalSurface at [0, 0, 20.4803]
        [8]Goptical::Sys::OpticalSurface at [0, 0, 21.9796]
        [9]Goptical::Sys::OpticalSurface at [0, 0, 29.9758]
        [10]Goptical::Sys::Image at [0, 0, 125.596]

   Positions of optical surfaces are relative to the parent lens
position.


File: goptical.info,  Node: A newton telescope with corrector,  Prev: The Lens component,  Up: System hierarchy and groups

3.3.2 A newton telescope with corrector
---------------------------------------

Object-oriented programming together with the hierarchical optical
components organization in Goptical allows writing complex and
dynamically parameterized optical component models composed of simple
components.

Using the telescope model
.........................

Usage of the newton telescope model class (*note
Design_Telescope_Newton_class_reference::) is presented here as an
example of parameterized models which contain simple components.  The
following example shows how to build an optical design composed of a
light source, the newton telescope model, a corrector lens assembly and
an image plane.

   The model constructor is called with the basic newton telescope
parameters and the model internally computes other parameters of the
telescope and instantiates internal optical components as needed.

     // code from examples/hierarchical_design/newton.cc:61

       Sys::System             sys;

       // light source
       Sys::SourcePoint        source(Sys::SourceAtInfinity, Math::vector3_001);
       sys.add(source);

       // Newton telescope
       Design::Telescope::Newton newton(Math::vector3_0, // position
                                        1494.567 / 2.,   // focal len
                                        245.1);          // aperture diameter
       sys.add(newton);


   We can query the telescope model to get the 3d position of the focal
plane within parent coordinates.  This enables us to attach the image
plane or next optical component at right location without much
calculation.

Adding a corrector
..................

We choose to attach a Wynne 4 lens corrector to the telescope.  As usual
we describe the corrector lens group using the Sys::Lens (*note
Sys_Lens_class_reference::) component:


       // Wynne 4 lens corrector for parabolic mirrors
       Sys::Lens               wynne(newton.get_focal_plane(),
                                     -48.4585);        // z offset of first surface

                     //  roc       ap.radius  thickness  material
       wynne.add_surface(21.496,   23.2 / 2., 1.905,     bk7);
       wynne.add_surface(24.787,   22.5 / 2., 1.574         );
       wynne.add_surface(55.890,   22.5 / 2., 1.270,     bk7);
       wynne.add_surface(45.164,   21.8 / 2., 18.504        );
       wynne.add_surface(29.410,   14.7 / 2., 0.45,      bk7);
       wynne.add_surface(13.870,   14.1 / 2., 16.086        );
       wynne.add_surface(23.617,   13.1 / 2., 1.805,     bk7);
       wynne.add_surface(0,        12.8 / 2., 9.003);

       sys.add(wynne);

       // image plane
       Sys::Image              image(wynne.get_exit_plane(), 15);
       sys.add(image);



   The first surface of the corrector is located relative to origin of
the 'wynne' lens component with a Z offset of -48.4585 in the lens
coordinate system but the whole lens is rotated and positioned at the
telescope focal plane in the parent coordinate system.

   Finally an image plane is created and positioned according to the
corrector position and last surface thickness.

Querying model and rendering layouts
....................................

The model class may also provide access to some internal construction
details:

       std::cout << "unvignetted image diameter: "
                 << newton.get_unvignetted_image_diameter() << std::endl;

       std::cout << "secondary minor axis size: "
                 << newton.get_secondary_minor_axis() << std::endl;

       std::cout << "secondary offset: "
                 << newton.get_secondary_offset() << std::endl;

       std::cout << "field angle: "
                 << newton.get_field_angle() << std::endl;


   2d and 3d layouts of the whole system or groups can be rendered.  The
following code uses paging to render two such different views of the
system:

       Io::RendererSvg       svg_renderer("layout.svg", 640, 480);
       Io::RendererViewport  &renderer = svg_renderer;

       // horizontal page layout
       renderer.set_page_layout(1, 2);

       // 3d system layout on 1st sub-page
       renderer.set_page(0);
       renderer.set_perspective();

       sys.draw_3d_fit(renderer, 300);
       sys.draw_3d(renderer);

       tracer.get_trace_result().draw_3d(renderer);

       // 2d Wynne corrector layout on 2nd sub-page
       renderer.set_page(1);

       wynne.draw_2d_fit(renderer);
       wynne.draw_2d(renderer);

       tracer.get_trace_result().draw_2d(renderer, false, &wynne);


[3d layout of the system and 2d layout closeup of the corrector]

File: goptical.info,  Node: A parameterizable segmented mirror model,  Next: A custom surface curve model,  Prev: System hierarchy and groups,  Up: Tutorial

3.4 A parameterizable segmented mirror model
============================================

This section shows how to take advantages of the hierarchical design
(*note System hierarchy and groups::) feature of Goptical to write your
own parameterizable optical component models.  The code of a segmented
mirror component model is presented and this new component is used as
the primary mirror in a Ritchey-Chretien telescope design.

[3d layout of a Ritchey-Chretien telescope with segmented primary mirror (X3D output)]
* Menu:

* Writing the component model class:: 
* Using the model in Ritchey-Chretien design:: 


File: goptical.info,  Node: Writing the component model class,  Next: Using the model in Ritchey-Chretien design,  Up: A parameterizable segmented mirror model

3.4.1 Writing the component model class
---------------------------------------

The segmented mirror model uses hexagonal segments and takes a surface
curve model, an aperture shape model, segment size and segment
separation as parameters.  We start the definition of our model class
which inherits from the Sys::Group (*note Sys_Group_class_reference::)
class:

     // code from examples/segmented_mirror/segmented.cc:62

     class HexSegMirror : public Sys::Group
     {
     public:

       HexSegMirror(const Math::VectorPair3 &pos,
                    const const_ref<Curve::Base> &curve,
                    const const_ref<Shape::Base> &shape,
                    double seg_radius, double separation)
         : Sys::Group(pos)
       {


   When the model is instantiated, all hexagonal mirrors need to be
created from the constructor.  We use two loops in order to build the
hexagonal mirror tessellation:

         if (seg_radius > separation)
           throw(Error("overlapping segments"));

         // sqrt(3)/2
         static const double sqrt_3_2 = 0.86602540378443864676;

         // hexagonal tessellation
         int x_count = ceil(shape->max_radius() / (separation * 1.5));
         int y_count = ceil(shape->max_radius() / (separation * 2 * sqrt_3_2));

         for (int x = -x_count; x <= x_count ; x++)
           {
             for (int y = -y_count; y <= y_count ; y++)
               {
                 // find segment mirror 2d position
                 double yoffset = x % 2 ? separation * sqrt_3_2 : 0;
                 Math::Vector2 p(x * separation * 1.5,
                                   yoffset + y * separation * 2 * sqrt_3_2 );


   The aperture shape is then used to check if a segment mirror must
exist at each location:

                 // skip if segment center is outside main shape
                 if (!shape->inside(p))
                   continue;


   The segment mirror curve must take into account the offset from the
main mirror origin.  We also decide to subtract the sagitta offset from
the segment curve and add it to its Z component position instead; this
allows its origin to lie on the segment surface, which may be more
convenient when tilting the segment.  The Curve::Composer (*note
Curve_Composer_class_reference::) class is used here to apply required
transformations to the model curve passed as a parameter:

                 // find curve z offset at segment center to shift both
                 // curve and segment in opposite directions.
                 double z_offset = curve->sagitta(p);

                 // create a composer curve for this segment and use it to translate main curve
                 ref<Curve::Composer> seg_curve = ref<Curve::Composer>::create();

                 seg_curve->add_curve(curve).xy_translate(-p).z_offset(-z_offset);


   The segment mirror is then created and added to the model group:

                 // create a segment mirror with hexagonal shape and translated curve
                 ref<Sys::Mirror> seg = ref<Sys::Mirror>::create(Math::Vector3(p, z_offset), seg_curve,
                                                  ref<Shape::RegularPolygon>::create(seg_radius, 6));

                 // attach the new segment to our group component
                 add(seg);


   We finally add some code to keep track of the segments so that they
can be accessed (and modified) separately after model instantiation:

                 // keep a pointer to this new segment
                 _segments.push_back(seg.ptr());
               }
           }
       }

       size_t get_segments_count() const
       {
         return _segments.size();
       }

       Sys::Mirror & get_segment(size_t i) const
       {
         return *_segments.at(i);
       }

     private:
       std::vector<Sys::Mirror *> _segments;
     };


   This model class is less than 70 lines long, including comments.


File: goptical.info,  Node: Using the model in Ritchey-Chretien design,  Prev: Writing the component model class,  Up: A parameterizable segmented mirror model

3.4.2 Using the model in Ritchey-Chretien design
------------------------------------------------

Our new model can now be used like other component models in optical
systems and groups.  We use it here with a ring aperture shape and conic
curvature to model the primary mirror of a Ritchey-Chretien telescope:

       Sys::System             sys;

       // Ring shaped segmented mirror with conic curve
       HexSegMirror            primary(Math::Vector3(0, 0, 800),
                                       ref<Curve::Conic>::create(-1600, -1.0869),
                                       ref<Shape::Ring>::create(300, 85),
                                       28, 30);
       sys.add(primary);

       Sys::Mirror             secondary(Math::VectorPair3(0, 0, 225, 0, 0, -1), 675, -5.0434, 100);
       sys.add(secondary);

       Sys::Image              image(Math::VectorPair3(0, 0, 900), 15);
       sys.add(image);

       Sys::Stop               stop(Math::vector3_0, 300);
       sys.add(stop);
       sys.set_entrance_pupil(stop);

       Sys::SourcePoint        source(Sys::SourceAtInfinity, Math::vector3_001);
       sys.add(source);



File: goptical.info,  Node: A custom surface curve model,  Prev: A parameterizable segmented mirror model,  Up: Tutorial

3.5 A custom surface curve model
================================

Common curve models are available in the Curve (*note
Curve_namespace_reference::) namespace but extending this set with
user-defined models is easy, as explained in this tutorial.

* Menu:

* Writing the curve model class:: 
* Using the new model in optical design:: 


File: goptical.info,  Node: Writing the curve model class,  Next: Using the new model in optical design,  Up: A custom surface curve model

3.5.1 Writing the curve model class
-----------------------------------

In this example, we chose to model a rotationally symmetric catenary
curve.  This curve has the following sagitta formula:

   z = a \, \cosh \left ({r \over a} \right ) - a

   Our curve model needs to provide several functions in order to be
useful to the raytracer.  Fortunately there are base classes which
provide default implementations for most curve model functions.  This
include differentiation functions and ray intersection functions.

   The Curve::Rotational (*note Curve_Rotational_class_reference::)
class allows modeling rotationally symmetric curves by only dealing with
2d formulas.  Our model class just has to inherit from this class and
provide an implementation for the 'sagitta' function:

     // code from examples/curve_model/usercurve.cc:56

     class MyCatenaryCurve : public Curve::Rotational
     {
     public:
       MyCatenaryCurve(double a)
         : _a(a)
       {
       }

     private:
       double sagitta(double r) const
       {
         return _a * cosh(r / _a) - _a;
       }

       double _a;
     };


   The model can be improved by specifying the derivative function.
This make calculations more efficient by avoiding use of the default
numerical differentiation implementation:

       double derivative(double r) const
       {
         return sinh(r / _a);
       }


   Although more functions from Curve::Base (*note
Curve_Base_class_reference::) and Curve::Rotational (*note
Curve_Rotational_class_reference::) can be reimplemented to further
improve model efficiency, this curve model can readily be used in an
optical design.


File: goptical.info,  Node: Using the new model in optical design,  Prev: Writing the curve model class,  Up: A custom surface curve model

3.5.2 Using the new model in optical design
-------------------------------------------

To check our model, we then use it in a simple optical system composed
of a point source, a mirror and an image plane.  The catenary mirror
resemble a parabolic mirror as used in a newton telescope.

       Sys::System             sys;

       // light source
       Sys::SourcePoint        source(Sys::SourceAtInfinity, Math::vector3_001);
       sys.add(source);

       // mirror
       Shape::Disk             shape(200);
       MyCatenaryCurve         curve(-3000);
       Sys::Mirror             primary(Math::Vector3(0, 0, 1500), curve, shape);

       sys.add(primary);

       // image plane
       Sys::Image              image(Math::vector3_0, 15);
       sys.add(image);


   The best point of focus is slightly offset from the parabola focal
length.  We use the Analysis::Focus (*note
Analysis_Focus_class_reference::) class to find the best point of focus
and move the image plane at this location:

         Analysis::Focus               focus(sys);

         image.set_plane(focus.get_best_focus());


   Finally we plot some spot diagrams using the Analysis::Spot (*note
Analysis_Spot_class_reference::) class.  The point light source is
rotated for each diagram:

         Io::RendererSvg            renderer("spot.svg",        200 * 3, 200 * 2, Io::rgb_black);

         renderer.set_margin_ratio(.35, .25, .1, .1);
         renderer.set_page_layout(3, 2);

         for (int i = 0; i < 6; i++)
           {
             Analysis::Spot spot(sys);

             renderer.set_page(i);
             spot.draw_diagram(renderer);

             source.rotate(0, .1, 0);
           }


[Spot diagrams with image at best point of focus for the catenary curve]

File: goptical.info,  Node: API documentation,  Next: GNU Free Documentation License,  Prev: Tutorial,  Up: Top

4 API documentation
*******************

* Menu:

* Modules:: 
* Namespaces list:: 
* Classes list:: 
* Main classes:: 


File: goptical.info,  Node: Modules,  Next: Namespaces list,  Up: API documentation

4.1 Modules
===========

Name                   Description
--------------------------------------------------------------------------
Core                   Goptical core classes
Design                 Parametrizable optical designs classes


File: goptical.info,  Node: Namespaces list,  Next: Classes list,  Prev: Modules,  Up: API documentation

4.2 Namespaces list
===================

Name                   Description
--------------------------------------------------------------------------
Analysis               Optical systems analysis tools
Curve                  Surface curvature models
Data                   Numerical data interpolation and plotting
Design                 Design module classes
Io                     Data input/output and graphical rendering
Light                  Physical properties of light
Material               Material models for optical components
Math                   Mathematical tools and functions
Shape                  2d shapes used for surface contours
Sys                    Optical system and components
Trace                  Ray tracer and light propagation


File: goptical.info,  Node: Classes list,  Next: Main classes,  Prev: Namespaces list,  Up: API documentation

4.3 Classes list
================

Name                        Description
--------------------------------------------------------------------------
Analysis::Focus             Best focus point analysis
Analysis::RayFan            RayFan diagram analysis
Analysis::Spot              Spot diagram analysis
Curve::Array                Enable definition of curve as square and
                            hexagonal array of an other curve
Curve::Base                 Base class for surface curvature models
Curve::Composer             Enable definition of curve as composition
                            of other curves
Curve::Composer::Attributes Curve::Composer base curve attributes.
Curve::Conic                General purpose conic curve model
Curve::Flat                 Flat curve
Curve::Foucault             Define surface curve from Foucault test
                            data.
Curve::Grid                 Define surface curve from interpolated grid
                            data set.
Curve::Parabola             Parabola curve model
Curve::Polynomial           Even and odd polynomial curve
                            implementation.
Curve::Sphere               Spherical curve model
Curve::Spline               Rotationally symmetric spline curve
                            implementation
Curve::Zernike              Define surface curve from Zernike
                            polynomials
Curve::ConicBase            Base class for conic family of curves
Curve::CurveRoc             Base class for curves with a radius of
                            curvature
Curve::Rotational           Base class for rotationally symmetric
                            curves.
Data::DiscreteSet           1d numerical data set with interpolation
Data::Grid                  2d numerical data set with interpolation.
Data::Plot                  Data plots container
Data::PlotData              Data set plot
Data::SampleSet             1d fixed interval numerical data set with
                            interpolation
Data::Set                   Base class for numerical data sets.
Data::Set1d                 Base class for 1d y = f(x) numerical data
                            set
Design::Telescope::CassegrainCassegrain telescopes model
Design::Telescope::Newton   Newton telescope optical design
Design::Telescope::TelescopeBase class for telescope optical designs
Error                       Base class used for Goptical exceptions.
Io::ImportOslo              Oslo files loader
Io::ImportZemax             Zemax files loader (experimental)
Io::Renderer                Base class for rendering drivers
Io::RendererDxf             DXF rendering driver base (experimental)
Io::RendererGd              GD rendering driver
Io::RendererOpengl          OpenGL rendering driver
Io::RendererPlplot          Plplot rendering driver
Io::RendererSvg             SVG file rendering driver
Io::RendererX11             X11 rendering driver
Io::RendererX3d             X3d rendering driver (experimental)
Io::Export                  File export class interface
Io::Import                  File import class interface
Io::RendererAxes            RendererAxes rendering descriptor
Io::RendererViewport        Base class for viewport based rendering
                            drivers
Io::Rgb                     RGB color descriptor
Light::Ray                  Describe a ray of light
Light::SpectralLine         Describe a spectral line
Material::Abbe              Abbe model for optical glass material
Material::Air               Air optical material model
Material::Base              Optical material base class.
Material::Catalog           Hold a glass material catalog
Material::Conrady           Conrady model for optical glass material
Material::DispersionTable   Interpolated refractive index data set
                            model
Material::Herzberger        Herzberger model for optical glass material
Material::Metal             Metal optical material model.
Material::Mil               Mil glass code material model
Material::Mirror            Simple mirror optical material model.
Material::Schott            Schott model for optical glass material
Material::Sellmeier         Sellmeier model for optical glass material
Material::SellmeierMod      Modified sellmeier model for optical glass
                            material
Material::Vacuum            Vacuum optical material model
Material::Dielectric        Dielectric optical material model base
                            class.
Material::Proxy             Optical material proxy class.
Material::Solid             Solid optical material base class.
Math::Matrix                NxN square matrix class.
Math::Quaternion            Quaternion class.
Math::Transform<3>          3d linear and affine transformation class.
Math::Transform<2>          2d linear and affine transformation class.
Math::Triangle              N dimension triangle class
Math::Triangle<3>           3d triangle class
Math::Vector                N dimension vector class
Math::Vector<3, T>          3d vector class
Math::Vector<2, T>          2d vector class
Math::VectorPair            Vector pair class
Math::VectorPair<2>         Vector pair class
Math::VectorPair<3>         Vector pair class
Shape::Base                 Base class for contour 2d shapes
Shape::Composer             Enable definition of shape as composition
                            ot other shapes (experimental)
Shape::Composer::Attributes Enable definition of shape as composition
                            ot other shapes (experimental)
Shape::Disk                 Disk shape
Shape::Ellipse              Ellipse shape
Shape::EllipticalRing       Elliptical ring shape
Shape::Infinite             Borderless shape
Shape::Polygon              Polygon shape
Shape::Rectangle            Rectangle and square shape
Shape::RegularPolygon       Regular Polygon shape
Shape::Ring                 Ring shape
Sys::Group                  Optical elements group element
Sys::Image                  Image plane optical element
Sys::Lens                   Lens optical element
Sys::Mirror                 Reflecting optical surface element
Sys::OpticalSurface         Optical surface element
Sys::SourcePoint            Point light source
Sys::SourceRays             Custom rays light source
Sys::System                 Optical system
Sys::Container              Base class for System and Group
Sys::Element                Optical element base class
Sys::Source                 Base class for light sources
Sys::Stop                   Aperture stop element
Sys::Surface                Base class for surfaces
Trace::Distribution         Ray distribution pattern descriptor
Trace::Params               Light propagation parameters descriptor
Trace::Result               Store light propagation result
Trace::Sequence             Defines light propagation elemets order for
                            sequential light propagation
Trace::Tracer               Light propagation algorithms
Trace::Ray                  Propagated light ray class


File: goptical.info,  Node: Main classes,  Prev: Classes list,  Up: API documentation

4.4 Main classes
================

Sys namespace
-------------

Name                   Description
--------------------------------------------------------------------------
Group                  Optical elements group element
Image                  Image plane optical element
Lens                   Lens optical element
Mirror                 Reflecting optical surface element
OpticalSurface         Optical surface element
SourcePoint            Point light source
SourceRays             Custom rays light source
System                 Optical system

Trace namespace
---------------

Name                   Description
--------------------------------------------------------------------------
Distribution           Ray distribution pattern descriptor
Params                 Light propagation parameters descriptor
Result                 Store light propagation result
Sequence               Defines light propagation elemets order for
                       sequential light propagation
Tracer                 Light propagation algorithms

Material namespace
------------------

Name                   Description
--------------------------------------------------------------------------
Abbe                   Abbe model for optical glass material
Air                    Air optical material model
Base                   Optical material base class.
Catalog                Hold a glass material catalog
Conrady                Conrady model for optical glass material
DispersionTable        Interpolated refractive index data set model
Herzberger             Herzberger model for optical glass material
Metal                  Metal optical material model.
Mil                    Mil glass code material model
Mirror                 Simple mirror optical material model.
Schott                 Schott model for optical glass material
Sellmeier              Sellmeier model for optical glass material
SellmeierMod           Modified sellmeier model for optical glass
                       material
Vacuum                 Vacuum optical material model

Io namespace
------------

Name                   Description
--------------------------------------------------------------------------
ImportOslo             Oslo files loader
ImportZemax            Zemax files loader (experimental)
Renderer               Base class for rendering drivers
RendererDxf            DXF rendering driver base (experimental)
RendererGd             GD rendering driver
RendererOpengl         OpenGL rendering driver
RendererPlplot         Plplot rendering driver
RendererSvg            SVG file rendering driver
RendererX11            X11 rendering driver
RendererX3d            X3d rendering driver (experimental)

Data namespace
--------------

Name                   Description
--------------------------------------------------------------------------
DiscreteSet            1d numerical data set with interpolation
Grid                   2d numerical data set with interpolation.
Plot                   Data plots container
PlotData               Data set plot
SampleSet              1d fixed interval numerical data set with
                       interpolation

Math namespace
--------------

Name                   Description
--------------------------------------------------------------------------
Vector2
Vector3
VectorPair3

Shape namespace
---------------

Name                   Description
--------------------------------------------------------------------------
Base                   Base class for contour 2d shapes
Composer               Enable definition of shape as composition ot
                       other shapes (experimental)
Disk                   Disk shape
Ellipse                Ellipse shape
EllipticalRing         Elliptical ring shape
Infinite               Borderless shape
Polygon                Polygon shape
Rectangle              Rectangle and square shape
RegularPolygon         Regular Polygon shape
Ring                   Ring shape

Light namespace
---------------

Name                   Description
--------------------------------------------------------------------------
Ray                    Describe a ray of light

Curve namespace
---------------

Name                   Description
--------------------------------------------------------------------------
Array                  Enable definition of curve as square and
                       hexagonal array of an other curve
Base                   Base class for surface curvature models
Composer               Enable definition of curve as composition of
                       other curves
Conic                  General purpose conic curve model
Flat                   Flat curve
Foucault               Define surface curve from Foucault test data.
Grid                   Define surface curve from interpolated grid data
                       set.
Parabola               Parabola curve model
Polynomial             Even and odd polynomial curve implementation.
Sphere                 Spherical curve model
Spline                 Rotationally symmetric spline curve
                       implementation
Zernike                Define surface curve from Zernike polynomials

Analysis namespace
------------------

Name                   Description
--------------------------------------------------------------------------
Focus                  Best focus point analysis
RayFan                 RayFan diagram analysis
Spot                   Spot diagram analysis

::Core module reference
=======================

Description
-----------

Classes from this module are located in the 'goptical-core' subpackage
('goptical' library).

Members
-------

Namespaces
..........

   * Goptical::Analysis
   * Goptical::Curve
   * Goptical::Data
   * Goptical::Io
   * Goptical::Light
   * Goptical::Material
   * Goptical::Math
   * Goptical::Shape
   * Goptical::Sys
   * Goptical::Trace

Types
.....

   * template class Abbe
   * template class Air
   * class Array
   * class Base
   * class Base
   * class Base
   * class Catalog
   * class Composer
   * class Composer
   * class Conic
   * class Conrady
   * class DiscreteSet
   * class Disk
   * class DispersionTable
   * class Distribution
   * class Ellipse
   * class EllipticalRing
   * class Flat
   * class Focus
   * class Foucault
   * class Grid
   * class Grid
   * class Group
   * class Herzberger
   * class Image
   * class ImportOslo
   * class ImportZemax
   * class Infinite
   * class Lens
   * class Metal
   * class Mil
   * class Mirror
   * class Mirror
   * class OpticalSurface
   * class Parabola
   * class Params
   * class Plot
   * class PlotData
   * class Polygon
   * class Polynomial
   * class Ray
   * class RayFan
   * class Rectangle
   * class RegularPolygon
   * class Renderer
   * class RendererDxf
   * class RendererGd
   * class RendererOpengl
   * class RendererPlplot
   * class RendererSvg
   * class RendererX11
   * class RendererX3d
   * class Result
   * class Ring
   * class SampleSet
   * class Schott
   * class Sellmeier
   * template class SellmeierMod
   * class Sequence
   * class SourcePoint
   * class SourceRays
   * class Sphere
   * class Spline
   * class Spot
   * class System
   * class Tracer
   * class Vacuum
   * typedef _ [...]  _ Vector2
   * typedef _ [...]  _ Vector3
   * typedef _ [...]  _ VectorPair3
   * class Zernike
   * typedef _ [...]  _ AbbeVd
   * typedef _ [...]  _ AbbeVe
   * typedef _ [...]  _ AirBirch94
   * typedef _ [...]  _ AirKohlrausch68
   * class Attributes
   * class Attributes
   * class ConicBase
   * class Container
   * class CurveRoc
   * class Dielectric
   * class Element
   * class Error
   * class Export
   * typedef _ [...]  _ Handbook1
   * typedef _ [...]  _ Handbook2
   * class Import
   * template struct Matrix
   * typedef _ [...]  _ Matrix3x3
   * class Proxy
   * class Quaternion
   * class Ray
   * class RendererAxes
   * class RendererViewport
   * struct Rgb
   * class Rotational
   * typedef _ [...]  _ SellmeierMod2
   * class Set
   * class Set1d
   * class Solid
   * class Source
   * class SpectralLine
   * class Stop
   * class Surface
   * template class Transform<2>
   * template class Transform<3>
   * typedef _ [...]  _ Transform2
   * typedef _ [...]  _ Transform3
   * template struct Triangle
   * template struct Triangle<3>
   * template struct Vector
   * template struct Vector<2, T>
   * template struct Vector<3, T>
   * template struct VectorPair
   * template struct VectorPair<2>
   * template struct VectorPair<3>
   * typedef _ [...]  _ VectorPair2
   * typedef _ [...]  _ range_t
   * typedef _ [...]  _ rays_queue_t

Functions
.........

   * double degree2rad(double x)
   * void get_rotation_matrix(Goptical::Math::Matrix<2> &m, unsigned int
     axis, double rangle)
   * void get_rotation_matrix(Goptical::Math::Matrix<3> &m, unsigned int
     axis, double rangle)
   * double lp_floor(double x, double n)
   * double lp_mod(double x, double n)
   * template std::ostream & operator<<(std::ostream &o, const
     Goptical::Math::VectorBase<N, T> &v)
   * template std::ostream & operator<<(std::ostream &o, const
     Goptical::Math::VectorPairBase<N> &l)
   * template std::ostream & operator<<(std::ostream &o, const
     Goptical::Math::Matrix<N> &m)
   * std::ostream & operator<<(std::ostream &o, const
     Goptical::Math::Quaternion &q)
   * template std::ostream & operator<<(std::ostream &o, const
     Goptical::Math::TransformBase<N> &t)
   * std::ostream & operator<<(std::ostream &o, const
     Goptical::Sys::Element &e)
   * template std::ostream & operator<<(std::ostream &o, const
     Goptical::Math::Triangle<N> &l)
   * std::ostream & operator<<(std::ostream &o, const
     Goptical::Trace::Sequence &s)
   * std::ostream & operator<<(std::ostream &o, const
     Goptical::Sys::Container &v)
   * std::ostream & operator<<(std::ostream &o, const
     Goptical::Data::Set &s)
   * double rad2degree(double x)
   * double square(double x)

Constants
.........

   * const dpp::const_ref<Goptical::Material::Base> none
   * const Goptical::Io::Rgb rgb_black
   * const Goptical::Io::Rgb rgb_blue
   * const Goptical::Io::Rgb rgb_cyan
   * const Goptical::Io::Rgb rgb_gray
   * const Goptical::Io::Rgb rgb_green
   * const Goptical::Io::Rgb rgb_magenta
   * const Goptical::Io::Rgb rgb_red
   * const Goptical::Io::Rgb rgb_table[]
   * const size_t rgb_table_size
   * const Goptical::Io::Rgb rgb_white
   * const Goptical::Io::Rgb rgb_yellow
   * const Goptical::Material::AirBirch94 std_air
   * const Goptical::Math::Vector2 vector2_0
   * const Goptical::Math::Vector2 vector2_01
   * const Goptical::Math::Vector2 vector2_1
   * const Goptical::Math::Vector2 vector2_10
   * const Goptical::Math::VectorPair<2> vector2_pair_00
   * const Goptical::Math::VectorPair<2> vector2_pair_01
   * const Goptical::Math::Vector3 vector3_0
   * const Goptical::Math::Vector3 vector3_001
   * const Goptical::Math::Vector3 vector3_010
   * const Goptical::Math::Vector3 vector3_1
   * const Goptical::Math::Vector3 vector3_100
   * const Goptical::Math::VectorPair<3> vector3_pair_00
   * const Goptical::Math::VectorPair<3> vector3_pair_01

Variables
.........

   * Goptical::Material::AirBirch94 air
   * Goptical::Curve::Flat flat
   * Goptical::Shape::Infinite infinite
   * Goptical::Material::Mirror mirror
   * Goptical::Material::Vacuum vacuum

::Design module reference
=========================

Description
-----------

This module contains various optical design models.

   Classes from this module are located in the 'goptical-design'
subpackage ('goptical_design' library).

Members
-------

Namespace
.........

   * Goptical::Design

Types
.....

   * template class Cassegrain
   * class Newton
   * class Telescope

Goptical namespace reference
============================

Description
-----------

Goptical library namespace

Members
-------

Namespaces
..........

   * Analysis
   * Curve
   * Data
   * Design
   * Io
   * Light
   * Material
   * Math
   * Shape
   * Sys
   * Trace

Type
....

   * class Error

Analysis namespace reference
============================

Description
-----------

Optical systems analysis tools

Members
-------

Types
.....

   * class Focus
   * class RayFan
   * class Spot

Analysis::Focus class reference
===============================

Declaration
-----------

     #include <Goptical/Analysis/Focus>

     namespace Goptical {
       namespace Analysis {
         class Focus;
       };
     };


   This class is a member of the Analysis namespace.

Description
-----------

This class is designed to find the best point of focus of an optical
system.

Members
-------

See also the full member list (*note
Analysis_Focus_class_full_member_list::) section for this class.

Functions
.........

   * Focus(Sys::System &system)
   * const Math::VectorPair3 & get_best_focus()
   * Trace::Tracer & get_tracer()
   * const Trace::Tracer & get_tracer() const
   * virtual void invalidate()
   * void set_image(Sys::Image *image)

Members detail
--------------

Focus(Sys::System &system)
..........................

No documentation available

const Math::VectorPair3 & get_best_focus()
..........................................

Get best point of focus in system global coordinates.

virtual void invalidate()
.........................

This virtual function implements the 'invalidate (*note _31::)' pure
function declared in the 'PointImage' base abstract class.

   Documentation inherited from base class:

   invalidate current analysis data

Analysis::Focus class full member list
======================================

Functions
---------

   * Focus(Sys::System &system)
   * const Math::VectorPair3 & get_best_focus()
   * Trace::Tracer & get_tracer()
   * const Trace::Tracer & get_tracer() const
   * virtual void invalidate()
   * void set_image(Sys::Image *image)

Analysis::RayFan class reference
================================

Declaration
-----------

     #include <Goptical/Analysis/RayFan>

     namespace Goptical {
       namespace Analysis {
         class RayFan;
       };
     };


   This class is a member of the Analysis namespace.

Description
-----------

This class is designed to compute various ray fan plots.

   See also Performing a ray fan analysis (*note Performing a ray fan
analysis::) section and Plotting ray fans (*note Plotting ray fans::)
section.

Members
-------

See also the full member list (*note
Analysis_RayFan_class_full_member_list::) section for this class.

Types
.....

   * enum rayfan_plane_e
   * enum rayfan_plot_type_e

Functions
.........

   * RayFan(const Sys::System &system, rayfan_plane_e plane = _[...]_)
   * Trace::Distribution & get_distribution()
   * ref<Data::Plot> get_plot(rayfan_plot_type_e x, rayfan_plot_type_e
     y)
   * void invalidate()
   * void set_aberration_plane(rayfan_plane_e plane)
   * void set_entrance_surface(const Sys::Surface &s)
   * void set_longitudinal_reference(const Math::VectorPair3 &ref)
   * void set_plane(rayfan_plane_e plane)
   * void set_target_surface(const Sys::Surface &s)

Members detail
--------------

RayFan(const Sys::System &system, rayfan_plane_e plane = TangentialAberration)
..............................................................................

No documentation available

Trace::Distribution & get_distribution()
........................................

Get internal distribution object

ref <Data::Plot> get_plot(rayfan_plot_type_e x, rayfan_plot_type_e y)
.....................................................................

Get aberration plot, requested x value is plotted against requested y
value.

void invalidate()
.................

Invalidate current analysis data and raytrace again on next plot request

enum rayfan_plane_e
...................

Specify aberration analysis plane on target surface

Identifier             Description
--------------------------------------------------------------------------
SagittalAberration
TangentialAberration

enum rayfan_plot_type_e
.......................

Specify ray aberration values to plot.  Angle and Distance aberrations
values are considered in selected aberration plane.  Entrance Height and
Angle are considered in selected distribution plane.

Identifier             Description
--------------------------------------------------------------------------
EntranceHeight         Normalized ray height (radial distance) on
                       entrance pupil
                       
EntranceAngle          Angle of ray on entrance pupil
                       
TransverseDistance     Distance on the surface from the intercept of
                       the chief ray
                       
LongitudinalDistance   Distance along the chief ray from the surface to
                       the measured ray.
                       
ImageAngle             Angle of ray striking the target surface
                       
ExitAngle              Angle of ray leaving (generated by) the target
                       surface
                       
OpticalPathDiff        Optical path difference in waves
                       

void set_aberration_plane(rayfan_plane_e plane)
...............................................

Aberrations are considered in the given plane on the target surface.
Default is to use the same plane as entrance pupil ray distribution
plane.

void set_entrance_surface(const Sys::Surface &s)
................................................

Specify entrance pupil surface to use for analysis, query system for
entrance pupil if none defined here.

void set_longitudinal_reference(const Math::VectorPair3 &ref)
.............................................................

Set longitudinal reference ray (local to target surface).  Longitudinal
aberration computes distance between each rays and target surface plane
along this reference vector.  Default value is along the Z axis.

void set_plane(rayfan_plane_e plane)
....................................

Set entrance pupil ray distribution plane.

void set_target_surface(const Sys::Surface &s)
..............................................

Specify target surface (image or exit pupil) to use for analysis, query
system for image surface if none defined here.

Analysis::RayFan class full member list
=======================================

Types
-----

   * enum rayfan_plane_e
   * enum rayfan_plot_type_e

Functions
---------

   * RayFan(const Sys::System &system, rayfan_plane_e plane = _[...]_)
   * Trace::Distribution & get_distribution()
   * ref<Data::Plot> get_plot(rayfan_plot_type_e x, rayfan_plot_type_e
     y)
   * void invalidate()
   * void set_aberration_plane(rayfan_plane_e plane)
   * void set_entrance_surface(const Sys::Surface &s)
   * void set_longitudinal_reference(const Math::VectorPair3 &ref)
   * void set_plane(rayfan_plane_e plane)
   * void set_target_surface(const Sys::Surface &s)

Analysis::Spot class reference
==============================

Declaration
-----------

     #include <Goptical/Analysis/Spot>

     namespace Goptical {
       namespace Analysis {
         class Spot;
       };
     };


   This class is a member of the Analysis namespace.

Description
-----------

This class is designed to plot spot diagram and perform related
analysis.

   See also Plotting spot diagram (*note Plotting spot diagram::)
section and Using the new model in optical design (*note Using the new
model in optical design::) section.

Members
-------

See also the full member list (*note
Analysis_Spot_class_full_member_list::) section for this class.

Functions
.........

   * Spot(Sys::System &system)
   * void draw_diagram(Io::RendererViewport &renderer, bool
     centroid_origin = _[...]_)
   * void draw_spot(Io::RendererViewport &renderer)
   * Math::Vector3 get_center()
   * const Math::Vector3 & get_centroid()
   * Io::RendererAxes & get_diagram_axes()
   * double get_encircled_intensity(double radius)
   * ref<Data::Plot> get_encircled_intensity_plot(int zones = _[...]_)
   * double get_max_radius()
   * double get_rms_radius()
   * double get_total_intensity()
   * Trace::Tracer & get_tracer()
   * const Trace::Tracer & get_tracer() const
   * virtual void invalidate()
   * void set_image(Sys::Image *image)
   * void set_useful_radius(double radius)

Members detail
--------------

Spot(Sys::System &system)
.........................

No documentation available

void draw_diagram(Io::RendererViewport &renderer, bool centroid_origin = true)
..............................................................................

draw the spot diagram

void draw_spot(Io::RendererViewport &renderer)
..............................................

draw the rays intersection points only

Math::Vector3 get_center()
..........................

Get spot window center

const Math::Vector3 & get_centroid()
....................................

Get spot centroid

Io::RendererAxes & get_diagram_axes()
.....................................

Get a reference to axes object rendered with spot diagram.
Io::RendererAxes (*note Io_RendererAxes_class_reference::) coordinates
are updated on ray trace.

double get_encircled_intensity(double radius)
.............................................

Get amount of light intensity which falls in given radius from spot
center

ref <Data::Plot> get_encircled_intensity_plot(int zones = 100)
..............................................................

Get encircled energy plot

double get_max_radius()
.......................

Get spot maximum radius

double get_rms_radius()
.......................

Get spot root mean square radius

double get_total_intensity()
............................

Get amount of light intensity in the whole spot

virtual void invalidate()
.........................

This virtual function implements the 'invalidate (*note _31::)' pure
function declared in the 'PointImage' base abstract class.

   Documentation inherited from base class:

   invalidate current analysis data

void set_useful_radius(double radius)
.....................................

Set radius used for diagram drawing and encircled plots.  Updated with
spot max radius on ray trace

Analysis::Spot class full member list
=====================================

Functions
---------

   * Spot(Sys::System &system)
   * void draw_diagram(Io::RendererViewport &renderer, bool
     centroid_origin = _[...]_)
   * void draw_spot(Io::RendererViewport &renderer)
   * Math::Vector3 get_center()
   * const Math::Vector3 & get_centroid()
   * Io::RendererAxes & get_diagram_axes()
   * double get_encircled_intensity(double radius)
   * ref<Data::Plot> get_encircled_intensity_plot(int zones = _[...]_)
   * double get_max_radius()
   * double get_rms_radius()
   * double get_total_intensity()
   * Trace::Tracer & get_tracer()
   * const Trace::Tracer & get_tracer() const
   * virtual void invalidate()
   * void set_image(Sys::Image *image)
   * void set_useful_radius(double radius)

Analysis::PointImage internal class members
===========================================

PointImage(Sys::System &system)
-------------------------------

No documentation available

virtual ~PointImage()
---------------------

No documentation available

Trace::Tracer & get_tracer()
----------------------------

return tracer object used for ray tracing.  This will invalidate current
analysis data

const Trace::Tracer & get_tracer() const
----------------------------------------

return tracer object used for ray tracing

virtual void invalidate() = 0;
------------------------------

invalidate current analysis data

void set_image(Sys::Image *image)
---------------------------------

set Image which collect rays for analysis

Curve namespace reference
=========================

Description
-----------

Surface curvature models

Members
-------

Types
.....

   * class Array
   * class Base
   * class Composer
   * class Conic
   * class Flat
   * class Foucault
   * class Grid
   * class Parabola
   * class Polynomial
   * class Sphere
   * class Spline
   * class Zernike
   * class ConicBase
   * class CurveRoc
   * class Rotational

Variable
........

   * Flat flat

Members detail
--------------

Flat flat
.........

Preallocated flat curve object

Curve::Array class reference
============================

Declaration
-----------

     #include <Goptical/Curve/Array>

     namespace Goptical {
       namespace Curve {
         class Array;
       };
     };


   This class is a member of the Curve namespace.

Inheritance
-----------

Description
-----------

This class provides a way to build an array of an other curve.  It can
be used to design lenses array.

Members
-------

See also the full member list (*note
Curve_Array_class_full_member_list::) section for this class.

Inherited members
.................

   * 5 members inherited from Base (*note Curve_Base_class_reference::)

Type
....

   * enum pattern_e

Functions
.........

   * Array(const const_ref<Base> &curve, double pitch, pattern_e p =
     _[...]_)
   * virtual void derivative(const Math::Vector2 &xy, Math::Vector2
     &dxdy) const
   * virtual double sagitta(const Math::Vector2 &xy) const

Members detail
--------------

Array(const const_ref <Base> &curve, double pitch, pattern_e p = Square)
........................................................................

No documentation available

virtual void derivative(const Math::Vector2 &xy, Math::Vector2 &dxdy) const
...........................................................................

This virtual function overrides the 'derivative (*note _39::)' virtual
function defined in the 'Base (*note Curve_Base_class_reference::)' base
abstract class.

   Documentation inherited from base class:

   Get curve x and y derivative (gradient) at specified point

enum pattern_e
..............

Specify tessellation pattern used by Array (*note
Curve_Array_class_reference::) class

Identifier             Description
--------------------------------------------------------------------------
Square
SquareCenter
Hexagonal

virtual double sagitta(const Math::Vector2 &xy) const
.....................................................

This virtual function implements the 'sagitta (*note _42::)' pure
function declared in the 'Base (*note Curve_Base_class_reference::)'
base abstract class.

   Documentation inherited from base class:

   Get curve sagitta at specified point

Curve::Array class full member list
===================================

Type
----

   * enum pattern_e

Functions
---------

   * Array(const const_ref<Base> &curve, double pitch, pattern_e p =
     _[...]_)
   * virtual void derivative(const Math::Vector2 &xy, Math::Vector2
     &dxdy) const
   * virtual bool intersect(Math::Vector3 &point, const
     Math::VectorPair3 &ray) const
   * virtual void normal(Math::Vector3 &normal, const Math::Vector3
     &point) const
   * virtual double sagitta(const Math::Vector2 &xy) const

Curve::Base class reference
===========================

Declaration
-----------

     #include <Goptical/Curve/Base>

     namespace Goptical {
       namespace Curve {
         class Base;
       };
     };


   This class is a member of the Curve namespace.

   This abstract class contains pure virtuals.

Inheritance
-----------

Description
-----------

This class defines an interface for surface curvature implementations.
Curvature is defined as a surface curve in three dimensional space.  It
is mainly used by the Sys::Surface (*note Sys_Surface_class_reference::)
class to describe optical surface curvature.

   It provides access to sagitta (z) and gradient data on any curved
surface point (x, y).  Ability to find point of intersection between a
given 3d ray and the curve is also provided.

   See also A custom surface curve model (*note A custom surface curve
model::) section.

Members
-------

See also the full member list (*note
Curve_Base_class_full_member_list::) section for this class.

Functions
.........

   * virtual ~Base()
   * virtual void derivative(const Math::Vector2 &xy, Math::Vector2
     &dxdy) const
   * virtual bool intersect(Math::Vector3 &point, const
     Math::VectorPair3 &ray) const
   * virtual void normal(Math::Vector3 &normal, const Math::Vector3
     &point) const
   * virtual double sagitta(const Math::Vector2 &xy) const = 0;

Members detail
--------------

virtual ~Base()
...............

No documentation available

virtual void derivative(const Math::Vector2 &xy, Math::Vector2 &dxdy) const
...........................................................................

Get curve x and y derivative (gradient) at specified point

virtual bool intersect(Math::Vector3 &point, const Math::VectorPair3 &ray) const
................................................................................

Get intersection point between curve and 3d ray.  Return false if no
intersection occurred

virtual void normal(Math::Vector3 &normal, const Math::Vector3 &point) const
............................................................................

Get normal to curve surface at specified point

virtual double sagitta(const Math::Vector2 &xy) const = 0;
..........................................................

Get curve sagitta at specified point

Curve::Base class full member list
==================================

Functions
---------

   * virtual ~Base()
   * virtual void derivative(const Math::Vector2 &xy, Math::Vector2
     &dxdy) const
   * virtual bool intersect(Math::Vector3 &point, const
     Math::VectorPair3 &ray) const
   * virtual void normal(Math::Vector3 &normal, const Math::Vector3
     &point) const
   * virtual double sagitta(const Math::Vector2 &xy) const = 0;

Curve::Composer class reference
===============================

Declaration
-----------

     #include <Goptical/Curve/Composer>

     namespace Goptical {
       namespace Curve {
         class Composer;
       };
     };


   This class is a member of the Curve namespace.

Inheritance
-----------

Description
-----------

This class allows definition of a surface curve using the sum of several
base curves.  Each base curve involved can be translated, rotated and
scaled individually.

Members
-------

See also the full member list (*note
Curve_Composer_class_full_member_list::) section for this class.

Inherited members
.................

   * 5 members inherited from Base (*note Curve_Base_class_reference::)

Type
....

   * class Attributes

Functions
.........

   * Composer()
   * Attributes & add_curve(const const_ref<Base> &curve)
   * virtual void derivative(const Math::Vector2 &xy, Math::Vector2
     &dxdy) const
   * virtual double sagitta(const Math::Vector2 &xy) const

Members detail
--------------

Composer()
..........

No documentation available

Attributes & add_curve(const const_ref <Base> &curve)
.....................................................

Add a base curve to use for composition.  The returned
Composer::Attributes object may be used to apply base curve
transformations.

virtual void derivative(const Math::Vector2 &xy, Math::Vector2 &dxdy) const
...........................................................................

This virtual function overrides the 'derivative (*note _39::)' virtual
function defined in the 'Base (*note Curve_Base_class_reference::)' base
abstract class.

   Documentation inherited from base class:

   Get curve x and y derivative (gradient) at specified point

virtual double sagitta(const Math::Vector2 &xy) const
.....................................................

This virtual function implements the 'sagitta (*note _42::)' pure
function declared in the 'Base (*note Curve_Base_class_reference::)'
base abstract class.

   Documentation inherited from base class:

   Get curve sagitta at specified point

Curve::Composer class full member list
======================================

Type
----

   * class Attributes

Functions
---------

   * Composer()
   * Attributes & add_curve(const const_ref<Base> &curve)
   * virtual void derivative(const Math::Vector2 &xy, Math::Vector2
     &dxdy) const
   * virtual bool intersect(Math::Vector3 &point, const
     Math::VectorPair3 &ray) const
   * virtual void normal(Math::Vector3 &normal, const Math::Vector3
     &point) const
   * virtual double sagitta(const Math::Vector2 &xy) const

Curve::Composer::Attributes class reference
===========================================

Declaration
-----------

     #include <Goptical/Curve/Composer>

     namespace Goptical {
       namespace Curve {
         class Composer {
           class Attributes;
         };
       };
     };


   This class is a member of the Composer class.

Description
-----------

This class enables access to Composer base curve transformations.
Sagitta (z) scaling and (x, y) affine transforms (translation, rotation,
scaling) can be applied as needed in any order.

Members
-------

See also the full member list (*note
Curve_Composer_Attributes_class_full_member_list::) section for this
class.

Functions
.........

   * Attributes & rotate(double dangle)
   * Attributes & xy_scale(const Math::Vector2 &factor)
   * Attributes & xy_translate(const Math::Vector2 &offset)
   * Attributes & z_offset(double zoffset)
   * Attributes & z_scale(double zfactor)

Members detail
--------------

Attributes & rotate(double dangle)
..................................

Apply rotation affine transform.  Angle is in degree.

Attributes & xy_scale(const Math::Vector2 &factor)
..................................................

Apply scaling affine transform using scale factors (xscale, yscale)

Attributes & xy_translate(const Math::Vector2 &offset)
......................................................

Apply translation transform

Attributes & z_offset(double zoffset)
.....................................

Apply sagitta (z) offset.  default is 0

Attributes & z_scale(double zfactor)
....................................

Apply sagitta (z) scale factor.  default is 1

Curve::Composer::Attributes class full member list
==================================================

Functions
---------

   * Attributes & rotate(double dangle)
   * Attributes & xy_scale(const Math::Vector2 &factor)
   * Attributes & xy_translate(const Math::Vector2 &offset)
   * Attributes & z_offset(double zoffset)
   * Attributes & z_scale(double zfactor)

Curve::Conic class reference
============================

Declaration
-----------

     #include <Goptical/Curve/Conic>

     namespace Goptical {
       namespace Curve {
         class Conic;
       };
     };


   This class is a member of the Curve namespace.

Inheritance
-----------

Description
-----------

This class models a rotationally symmetric conic curves with given
radius of curvature and deformation coefficient.  The later can be
provided either as Schwarzschild constant or Eccentricity value.

   Fitting can be used to find best fit conic of an other rotationally
symmetric curve either with fixed or free deformation parameter.

   Sphere (*note Curve_Sphere_class_reference::) and Parabola (*note
Curve_Parabola_class_reference::) offer optimized implementations for
common special cases.

Members
-------

See also the full member list (*note
Curve_Conic_class_full_member_list::) section for this class.

Inherited members
.................

   * 13 members inherited from ConicBase (*note
     Curve_ConicBase_class_reference::)

Functions
.........

   * Conic(double roc, double sc)
   * virtual double derivative(double r) const
   * double fit(const Rotational &curve, double radius, unsigned int
     count)
   * virtual bool intersect(Math::Vector3 &point, const
     Math::VectorPair3 &ray) const
   * virtual double sagitta(double r) const
   * void set_eccentricity(double e)
   * void set_schwarzschild(double sc)

Members detail
--------------

Conic(double roc, double sc)
............................

Creates a conic curve with given radius of curvature and Schwarzschild
constant

virtual double derivative(double r) const
.........................................

This virtual function implements the 'derivative (*note _130::)' pure
function declared in the 'ConicBase (*note
Curve_ConicBase_class_reference::)' base abstract class.

   Documentation inherited from base class:

   Get curve derivative at specified distance from origin.

   * r: distance from curve origin (0, 0)

double fit(const Rotational &curve, double radius, unsigned int count)
......................................................................

Adjust radius of curvature _and_ deformation to best fit given curve

   Parameters list:

   * curve: Curve to fit
   * radius: Maximum radius used to get sample points
   * count: Number of sample points to use

virtual bool intersect(Math::Vector3 &point, const Math::VectorPair3 &ray) const
................................................................................

This virtual function implements the 'intersect (*note _134::)' pure
function declared in the 'ConicBase (*note
Curve_ConicBase_class_reference::)' base abstract class.

   Documentation inherited from base class:

   Get intersection point between curve and 3d ray.  Return false if no
intersection occurred

virtual double sagitta(double r) const
......................................

This virtual function implements the 'sagitta (*note _135::)' pure
function declared in the 'ConicBase (*note
Curve_ConicBase_class_reference::)' base abstract class.

   Documentation inherited from base class:

   Get curve sagitta at specified distance from origin.

   * r: distance from curve origin (0, 0)

void set_eccentricity(double e)
...............................

Set eccentricity

void set_schwarzschild(double sc)
.................................

Set Schwarzschild constant

Curve::Conic class full member list
===================================

Functions
---------

   * Conic(double roc, double sc)
   * virtual void derivative(const Math::Vector2 &xy, Math::Vector2
     &dxdy) const
   * virtual double derivative(double r) const
   * double fit(const Rotational &curve, double radius, unsigned int
     count)
   * double fit_roc(const Rotational &c, double radius, unsigned int
     count)
   * double get_eccentricity() const
   * double get_roc() const
   * virtual void get_sample(unsigned int index, double &r, double &z)
     const
   * virtual unsigned int get_sample_count() const
   * double get_schwarzschild() const
   * virtual bool intersect(Math::Vector3 &point, const
     Math::VectorPair3 &ray) const
   * virtual void normal(Math::Vector3 &normal, const Math::Vector3
     &point) const
   * virtual double sagitta(const Math::Vector2 &xy) const
   * virtual double sagitta(double r) const
   * void set_eccentricity(double e)
   * void set_roc(double roc)
   * void set_schwarzschild(double sc)

Curve::Flat class reference
===========================

Declaration
-----------

     #include <Goptical/Curve/Flat>

     namespace Goptical {
       namespace Curve {
         class Flat;
       };
     };


   This class is a member of the Curve namespace.

Inheritance
-----------

Description
-----------

The global variable flat (*note _33::) provides an instance of this
class.

Members
-------

See also the full member list (*note
Curve_Flat_class_full_member_list::) section for this class.

Inherited members
.................

   * 9 members inherited from Rotational (*note
     Curve_Rotational_class_reference::)

Functions
.........

   * Flat()
   * virtual double derivative(double r) const
   * virtual bool intersect(Math::Vector3 &point, const
     Math::VectorPair3 &ray) const
   * virtual void normal(Math::Vector3 &normal, const Math::Vector3
     &point) const
   * virtual double sagitta(double r) const

Members detail
--------------

Flat()
......

Creates a flat curve

virtual double derivative(double r) const
.........................................

This virtual function overrides the 'derivative (*note _139::)' virtual
function defined in the 'Rotational (*note
Curve_Rotational_class_reference::)' base abstract class.

   Documentation inherited from base class:

   Get curve derivative at specified distance from origin.

   * r: distance from curve origin (0, 0)

virtual bool intersect(Math::Vector3 &point, const Math::VectorPair3 &ray) const
................................................................................

This virtual function overrides the 'intersect (*note _40::)' virtual
function defined in the 'Base (*note Curve_Base_class_reference::)' base
abstract class.

   Documentation inherited from base class:

   Get intersection point between curve and 3d ray.  Return false if no
intersection occurred

virtual void normal(Math::Vector3 &normal, const Math::Vector3 &point) const
............................................................................

This virtual function overrides the 'normal (*note _143::)' virtual
function defined in the 'Rotational (*note
Curve_Rotational_class_reference::)' base abstract class.

   Documentation inherited from base class:

   Get normal to curve surface at specified point

virtual double sagitta(double r) const
......................................

This virtual function implements the 'sagitta (*note _144::)' pure
function declared in the 'Rotational (*note
Curve_Rotational_class_reference::)' base abstract class.

   Documentation inherited from base class:

   Get curve sagitta at specified distance from origin.

   * r: distance from curve origin (0, 0)

Curve::Flat class full member list
==================================

Functions
---------

   * Flat()
   * virtual void derivative(const Math::Vector2 &xy, Math::Vector2
     &dxdy) const
   * virtual double derivative(double r) const
   * virtual void get_sample(unsigned int index, double &r, double &z)
     const
   * virtual unsigned int get_sample_count() const
   * virtual bool intersect(Math::Vector3 &point, const
     Math::VectorPair3 &ray) const
   * virtual void normal(Math::Vector3 &normal, const Math::Vector3
     &point) const
   * virtual double sagitta(const Math::Vector2 &xy) const
   * virtual double sagitta(double r) const

Curve::Foucault class reference
===============================

Declaration
-----------

     #include <Goptical/Curve/Foucault>

     namespace Goptical {
       namespace Curve {
         class Foucault;
       };
     };


   This class is a member of the Curve namespace.

Inheritance
-----------

Description
-----------

This class allows definition of a rotationally symmetric curve from a
set of Foucault test data.  Fixed and moving light sources are
supported.

   Curve fitting can be used to find Foucault test readings from any
other rotationally symmetric curve.

   Foucault test data are reduced using numerical integration of a
differential equation to compute sagitta from slopes.

   Foucault data reduction algorithm based on "ATM Mirror Mathematics"
http://home.earthlink.net/~burrjaw/atm/atm_math.lwp/atm_math.htm

   Couder mask theory and formulas developed by Nils Olof Carlin
http://www.atmsite.org/contrib/Carlin/couder/

Members
-------

See also the full member list (*note
Curve_Foucault_class_full_member_list::) section for this class.

Inherited members
.................

   * 2 members inherited from CurveRoc (*note
     Curve_CurveRoc_class_reference::)
   * 9 members inherited from Rotational (*note
     Curve_Rotational_class_reference::)

Functions
.........

   * Foucault(double roc)
   * ~Foucault()
   * unsigned int add_couder_zones(double hole_radius, unsigned int
     count = _[...]_, std::vector<double> *edge = _[...]_)
   * void add_reading(double zone_radius, double knife_offset = _[...]_)
   * unsigned int add_uniform_zones(double hole_radius, unsigned int
     count)
   * void clear()
   * virtual double derivative(double r) const
   * void fit(const Rotational &c)
   * double get_radius() const
   * const std::pair<double, double> get_reading(unsigned int
     zone_number) const
   * unsigned int get_zones_count() const
   * virtual double sagitta(double r) const
   * void set_fixed_source(double source_to_surface)
   * void set_knife_offset(unsigned int zone_number, double
     knife_offset)
   * void set_moving_source(double source_offset = _[...]_)
   * void set_ode_stepsize(double step)
   * void set_radius(double radius)

Members detail
--------------

Foucault(double roc)
....................

Create an empty foucault curve with no reading with the given radius of
curvature

~Foucault()
...........

No documentation available

unsigned int add_couder_zones(double hole_radius, unsigned int count = 0, std:: vector <double> *edge = 0)
..........................................................................................................

Clear current zones and add zones readings to locations suited for
testing with a couder mask (as described on Nils Olof Carlin page).
Zone count may be guessed if zero, provided that radius has been
properly set before.  Knife edge reading (offset from radius of
curvature) is set to 0 for all zones.

   * edge: Couder zones edges will be saved here if != NULL.

   The return value is Zone count

void add_reading(double zone_radius, double knife_offset = 0.0)
...............................................................

Define a new zone at given zone radius and update knife edge reading
(offset from radius of curvature)

unsigned int add_uniform_zones(double hole_radius, unsigned int count)
......................................................................

Clear current zones and add equally spaced zones readings.  Knife edge
reading (offset from radius of curvature) is set to 0 for all zones.

   The return value is New zones count

void clear()
............

Clear all readings and zones

virtual double derivative(double r) const
.........................................

This virtual function overrides the 'derivative (*note _139::)' virtual
function defined in the 'Rotational (*note
Curve_Rotational_class_reference::)' base abstract class.

   Documentation inherited from base class:

   Get curve derivative at specified distance from origin.

   * r: distance from curve origin (0, 0)

void fit(const Rotational &c)
.............................

Switch to moving source test and update knife edge readings of
previously defined zone to fit provided rotationally symmetric curve.
This means simulating a foucault test of the given curve using existing
zones.

double get_radius() const
.........................

Get surface radius.

const std:: pair <double, double> get_reading(unsigned int zone_number) const
.............................................................................

Get reading data for a given zone number.

   The return value is std::pair with zone radius and knife offset

unsigned int get_zones_count() const
....................................

Get currently defined zones/readings count

virtual double sagitta(double r) const
......................................

This virtual function implements the 'sagitta (*note _144::)' pure
function declared in the 'Rotational (*note
Curve_Rotational_class_reference::)' base abstract class.

   Documentation inherited from base class:

   Get curve sagitta at specified distance from origin.

   * r: distance from curve origin (0, 0)

void set_fixed_source(double source_to_surface)
...............................................

Set fixed light source foucault test.  This clear all readings and
zones.

   * source_to_surface: Distance between surface and light source along
     the optical axis.

void set_knife_offset(unsigned int zone_number, double knife_offset)
....................................................................

Set knife edge reading of a previously defined zone

void set_moving_source(double source_offset = 0.0)
..................................................

Set moving light source foucault test.  This clear all readings and
zones.

   * source_offset: Distance between knife edge and light source along
     optical axis.

void set_ode_stepsize(double step)
..................................

Set surface integration (ODE) algorithm step size, default is 1mm

void set_radius(double radius)
..............................

Set surface radius.  Effective surface radius must be known to let the
surface integration algorithm run up to a given limit.  Sagitta and
gradient values above the define radius won't be accurate.

   Radius is adjusted to max zone radius + 10% when adding readings.

Curve::Foucault class full member list
======================================

Functions
---------

   * Foucault(double roc)
   * ~Foucault()
   * unsigned int add_couder_zones(double hole_radius, unsigned int
     count = _[...]_, std::vector<double> *edge = _[...]_)
   * void add_reading(double zone_radius, double knife_offset = _[...]_)
   * unsigned int add_uniform_zones(double hole_radius, unsigned int
     count)
   * void clear()
   * virtual void derivative(const Math::Vector2 &xy, Math::Vector2
     &dxdy) const
   * virtual double derivative(double r) const
   * void fit(const Rotational &c)
   * double get_radius() const
   * const std::pair<double, double> get_reading(unsigned int
     zone_number) const
   * double get_roc() const
   * virtual void get_sample(unsigned int index, double &r, double &z)
     const
   * virtual unsigned int get_sample_count() const
   * unsigned int get_zones_count() const
   * virtual bool intersect(Math::Vector3 &point, const
     Math::VectorPair3 &ray) const
   * virtual void normal(Math::Vector3 &normal, const Math::Vector3
     &point) const
   * virtual double sagitta(const Math::Vector2 &xy) const
   * virtual double sagitta(double r) const
   * void set_fixed_source(double source_to_surface)
   * void set_knife_offset(unsigned int zone_number, double
     knife_offset)
   * void set_moving_source(double source_offset = _[...]_)
   * void set_ode_stepsize(double step)
   * void set_radius(double radius)
   * void set_roc(double roc)

Curve::Grid class reference
===========================

Declaration
-----------

     #include <Goptical/Curve/Grid>

     namespace Goptical {
       namespace Curve {
         class Grid;
       };
     };


   This class is a member of the Curve namespace.

Inheritance
-----------

Description
-----------

This class use the Data::Grid (*note Data_Grid_class_reference::) 2d
data set container to define a 3d non-symmetric curve.  Several data
interpolation algorithms are available allowing use of Data::Bicubic
(*note _146::) spline interpolation with or without prescribed
derivative/gradient data.  .

   The Spline (*note Curve_Spline_class_reference::) curve model is
preferred when dealing with rotationally symmetric curves (*note
Curve_Rotational_class_reference::).

   See also Data::Grid (*note Data_Grid_class_reference::) class.

Members
-------

See also the full member list (*note
Curve_Grid_class_full_member_list::) section for this class.

Inherited members
.................

   * 5 members inherited from Base (*note Curve_Base_class_reference::)

Functions
.........

   * Grid(unsigned int n, double radius)
   * ~Grid()
   * virtual void derivative(const Math::Vector2 &xy, Math::Vector2
     &dxdy) const
   * void fit(const Base &c)
   * const Data::Grid & get_data() const
   * Data::Grid & get_data()
   * virtual double sagitta(const Math::Vector2 &xy) const

Members detail
--------------

Grid(unsigned int n, double radius)
...................................

Creates a grid curve with n*n sample points defined over the given
radius.

~Grid()
.......

No documentation available

virtual void derivative(const Math::Vector2 &xy, Math::Vector2 &dxdy) const
...........................................................................

This virtual function overrides the 'derivative (*note _39::)' virtual
function defined in the 'Base (*note Curve_Base_class_reference::)' base
abstract class.

   Documentation inherited from base class:

   Get curve x and y derivative (gradient) at specified point

void fit(const Base &c)
.......................

Set grid values to best fit an other curve.  Gradient data will be
extracted only if the interpolation have been set to Data::BicubicDeriv
previously

const Data::Grid & get_data() const
...................................

Get embedded sagitta/gradient data container

Data::Grid & get_data()
.......................

Get embedded sagitta/gradient data container

virtual double sagitta(const Math::Vector2 &xy) const
.....................................................

This virtual function implements the 'sagitta (*note _42::)' pure
function declared in the 'Base (*note Curve_Base_class_reference::)'
base abstract class.

   Documentation inherited from base class:

   Get curve sagitta at specified point

Curve::Grid class full member list
==================================

Functions
---------

   * Grid(unsigned int n, double radius)
   * ~Grid()
   * virtual void derivative(const Math::Vector2 &xy, Math::Vector2
     &dxdy) const
   * void fit(const Base &c)
   * const Data::Grid & get_data() const
   * Data::Grid & get_data()
   * virtual bool intersect(Math::Vector3 &point, const
     Math::VectorPair3 &ray) const
   * virtual void normal(Math::Vector3 &normal, const Math::Vector3
     &point) const
   * virtual double sagitta(const Math::Vector2 &xy) const

Curve::Parabola class reference
===============================

Declaration
-----------

     #include <Goptical/Curve/Parabola>

     namespace Goptical {
       namespace Curve {
         class Parabola;
       };
     };


   This class is a member of the Curve namespace.

Inheritance
-----------

Description
-----------

This class provides an efficient parabola curve implementation.

Members
-------

See also the full member list (*note
Curve_Parabola_class_full_member_list::) section for this class.

Inherited members
.................

   * 13 members inherited from ConicBase (*note
     Curve_ConicBase_class_reference::)

Functions
.........

   * Parabola(double roc)
   * virtual double derivative(double r) const
   * virtual bool intersect(Math::Vector3 &point, const
     Math::VectorPair3 &ray) const
   * virtual double sagitta(double r) const

Members detail
--------------

Parabola(double roc)
....................

Creates a parabola curve with given radius of curvature

virtual double derivative(double r) const
.........................................

This virtual function implements the 'derivative (*note _130::)' pure
function declared in the 'ConicBase (*note
Curve_ConicBase_class_reference::)' base abstract class.

   Documentation inherited from base class:

   Get curve derivative at specified distance from origin.

   * r: distance from curve origin (0, 0)

virtual bool intersect(Math::Vector3 &point, const Math::VectorPair3 &ray) const
................................................................................

This virtual function implements the 'intersect (*note _134::)' pure
function declared in the 'ConicBase (*note
Curve_ConicBase_class_reference::)' base abstract class.

   Documentation inherited from base class:

   Get intersection point between curve and 3d ray.  Return false if no
intersection occurred

virtual double sagitta(double r) const
......................................

This virtual function implements the 'sagitta (*note _135::)' pure
function declared in the 'ConicBase (*note
Curve_ConicBase_class_reference::)' base abstract class.

   Documentation inherited from base class:

   Get curve sagitta at specified distance from origin.

   * r: distance from curve origin (0, 0)

Curve::Parabola class full member list
======================================

Functions
---------

   * Parabola(double roc)
   * virtual void derivative(const Math::Vector2 &xy, Math::Vector2
     &dxdy) const
   * virtual double derivative(double r) const
   * double fit_roc(const Rotational &c, double radius, unsigned int
     count)
   * double get_eccentricity() const
   * double get_roc() const
   * virtual void get_sample(unsigned int index, double &r, double &z)
     const
   * virtual unsigned int get_sample_count() const
   * double get_schwarzschild() const
   * virtual bool intersect(Math::Vector3 &point, const
     Math::VectorPair3 &ray) const
   * virtual void normal(Math::Vector3 &normal, const Math::Vector3
     &point) const
   * virtual double sagitta(const Math::Vector2 &xy) const
   * virtual double sagitta(double r) const
   * void set_roc(double roc)

Curve::Polynomial class reference
=================================

Declaration
-----------

     #include <Goptical/Curve/Polynomial>

     namespace Goptical {
       namespace Curve {
         class Polynomial;
       };
     };


   This class is a member of the Curve namespace.

Inheritance
-----------

Description
-----------

This class allow definition of rotationally symmetric high order
polynomial curves.  Unlimited number of terms can be used.

Members
-------

See also the full member list (*note
Curve_Polynomial_class_full_member_list::) section for this class.

Inherited members
.................

   * 9 members inherited from Rotational (*note
     Curve_Rotational_class_reference::)

Functions
.........

   * Polynomial()
   * Polynomial(unsigned int first_term, unsigned int last_term, ...)
   * virtual double derivative(double r) const
   * virtual double sagitta(double r) const
   * void set(unsigned int first_term, unsigned int last_term, ...)
   * void set_even(unsigned int first_term, unsigned int last_term, ...)
   * void set_first_term(unsigned int n)
   * void set_last_term(unsigned int n)
   * void set_odd(unsigned int first_term, unsigned int last_term, ...)
   * void set_term_factor(unsigned int n, double c)

Members detail
--------------

Polynomial()
............

Create a new zero polynomial

Polynomial(unsigned int first_term, unsigned int last_term, ...)
................................................................

Create a new polynomial with given order and coefficients.  Same syntax
as set() function.

virtual double derivative(double r) const
.........................................

This virtual function overrides the 'derivative (*note _139::)' virtual
function defined in the 'Rotational (*note
Curve_Rotational_class_reference::)' base abstract class.

   Documentation inherited from base class:

   Get curve derivative at specified distance from origin.

   * r: distance from curve origin (0, 0)

virtual double sagitta(double r) const
......................................

This virtual function implements the 'sagitta (*note _144::)' pure
function declared in the 'Rotational (*note
Curve_Rotational_class_reference::)' base abstract class.

   Documentation inherited from base class:

   Get curve sagitta at specified distance from origin.

   * r: distance from curve origin (0, 0)

void set(unsigned int first_term, unsigned int last_term, ...)
..............................................................

Set polynomial order and coefficients.

   * first_term: order of first (lowest) term.
   * last_term: order of last (highest) term.
   * ...: list of coefficient starting at lowest term

void set_even(unsigned int first_term, unsigned int last_term, ...)
...................................................................

Set even polynomial order and coefficients.

   * first_term: order of first (lowest) term, must be even.
   * last_term: order of last (highest) term, must be even.
   * ...: list of even coefficient starting at lowest term

void set_first_term(unsigned int n)
...................................

Set order of first (lowest) term.  Polynomial may be truncated or
extended with 0 coefficients.

void set_last_term(unsigned int n)
..................................

Set order of last (highest) term.  Polynomial may be truncated or
extended with 0 coefficients.

void set_odd(unsigned int first_term, unsigned int last_term, ...)
..................................................................

Set odd polynomial order and coefficients.

   * first_term: order of first (lowest) term, must be odd.
   * last_term: order of last (highest) term, must be odd.
   * ...: list of odd coefficient starting at lowest term

void set_term_factor(unsigned int n, double c)
..............................................

Adjust coefficient of a single term.  Adujst polynomial length as
needed, setting additional coefficients to 0.

Curve::Polynomial class full member list
========================================

Functions
---------

   * Polynomial()
   * Polynomial(unsigned int first_term, unsigned int last_term, ...)
   * virtual void derivative(const Math::Vector2 &xy, Math::Vector2
     &dxdy) const
   * virtual double derivative(double r) const
   * virtual void get_sample(unsigned int index, double &r, double &z)
     const
   * virtual unsigned int get_sample_count() const
   * virtual bool intersect(Math::Vector3 &point, const
     Math::VectorPair3 &ray) const
   * virtual void normal(Math::Vector3 &normal, const Math::Vector3
     &point) const
   * virtual double sagitta(const Math::Vector2 &xy) const
   * virtual double sagitta(double r) const
   * void set(unsigned int first_term, unsigned int last_term, ...)
   * void set_even(unsigned int first_term, unsigned int last_term, ...)
   * void set_first_term(unsigned int n)
   * void set_last_term(unsigned int n)
   * void set_odd(unsigned int first_term, unsigned int last_term, ...)
   * void set_term_factor(unsigned int n, double c)

Curve::Sphere class reference
=============================

Declaration
-----------

     #include <Goptical/Curve/Sphere>

     namespace Goptical {
       namespace Curve {
         class Sphere;
       };
     };


   This class is a member of the Curve namespace.

Inheritance
-----------

Description
-----------

This class provides an efficient spherical curve implementation.

Members
-------

See also the full member list (*note
Curve_Sphere_class_full_member_list::) section for this class.

Inherited members
.................

   * 13 members inherited from ConicBase (*note
     Curve_ConicBase_class_reference::)

Functions
.........

   * Sphere(double roc)
   * virtual double derivative(double r) const
   * virtual bool intersect(Math::Vector3 &point, const
     Math::VectorPair3 &ray) const
   * virtual void normal(Math::Vector3 &normal, const Math::Vector3
     &point) const
   * virtual double sagitta(double r) const

Members detail
--------------

Sphere(double roc)
..................

Creates a spherical curve with given radius of curvature

virtual double derivative(double r) const
.........................................

This virtual function implements the 'derivative (*note _130::)' pure
function declared in the 'ConicBase (*note
Curve_ConicBase_class_reference::)' base abstract class.

   Documentation inherited from base class:

   Get curve derivative at specified distance from origin.

   * r: distance from curve origin (0, 0)

virtual bool intersect(Math::Vector3 &point, const Math::VectorPair3 &ray) const
................................................................................

This virtual function implements the 'intersect (*note _134::)' pure
function declared in the 'ConicBase (*note
Curve_ConicBase_class_reference::)' base abstract class.

   Documentation inherited from base class:

   Get intersection point between curve and 3d ray.  Return false if no
intersection occurred

virtual void normal(Math::Vector3 &normal, const Math::Vector3 &point) const
............................................................................

This virtual function overrides the 'normal (*note _143::)' virtual
function defined in the 'Rotational (*note
Curve_Rotational_class_reference::)' base abstract class.

   Documentation inherited from base class:

   Get normal to curve surface at specified point

virtual double sagitta(double r) const
......................................

This virtual function implements the 'sagitta (*note _135::)' pure
function declared in the 'ConicBase (*note
Curve_ConicBase_class_reference::)' base abstract class.

   Documentation inherited from base class:

   Get curve sagitta at specified distance from origin.

   * r: distance from curve origin (0, 0)

Curve::Sphere class full member list
====================================

Functions
---------

   * Sphere(double roc)
   * virtual void derivative(const Math::Vector2 &xy, Math::Vector2
     &dxdy) const
   * virtual double derivative(double r) const
   * double fit_roc(const Rotational &c, double radius, unsigned int
     count)
   * double get_eccentricity() const
   * double get_roc() const
   * virtual void get_sample(unsigned int index, double &r, double &z)
     const
   * virtual unsigned int get_sample_count() const
   * double get_schwarzschild() const
   * virtual bool intersect(Math::Vector3 &point, const
     Math::VectorPair3 &ray) const
   * virtual void normal(Math::Vector3 &normal, const Math::Vector3
     &point) const
   * virtual double sagitta(const Math::Vector2 &xy) const
   * virtual double sagitta(double r) const
   * void set_roc(double roc)

Curve::Spline class reference
=============================

Declaration
-----------

     #include <Goptical/Curve/Spline>

     namespace Goptical {
       namespace Curve {
         class Spline;
       };
     };


   This class is a member of the Curve namespace.

Inheritance
-----------

Description
-----------

This class uses a 1d discrete data set to define a rotationally
symmetric sagitta/gradient curve.  Several data interpolations algorithm
are available allowing use of Smooth Cubic spline interpolation with or
without prescribed derivative/gradient data.

   See also Data::DiscreteSet (*note Data_DiscreteSet_class_reference::)
class.

Members
-------

See also the full member list (*note
Curve_Spline_class_full_member_list::) section for this class.

Inherited members
.................

   * 9 members inherited from Rotational (*note
     Curve_Rotational_class_reference::)

Functions
.........

   * Spline()
   * ~Spline()
   * virtual double derivative(double r) const
   * void fit(const Rotational &c, double radius, unsigned int points)
   * const Data::DiscreteSet & get_data() const
   * Data::DiscreteSet & get_data()
   * virtual double sagitta(double r) const

Members detail
--------------

Spline()
........

Create an empty spline curve with no defined point

~Spline()
.........

No documentation available

virtual double derivative(double r) const
.........................................

This virtual function overrides the 'derivative (*note _139::)' virtual
function defined in the 'Rotational (*note
Curve_Rotational_class_reference::)' base abstract class.

   Documentation inherited from base class:

   Get curve derivative at specified distance from origin.

   * r: distance from curve origin (0, 0)

void fit(const Rotational &c, double radius, unsigned int points)
.................................................................

Clear all points and fit to an other rotationally symmetric curve.

   * c: Curve to fit
   * radius: Maximum radius where curve is defined
   * points: Number of sample points

const Data::DiscreteSet & get_data() const
..........................................

Get sagitta/derivative data container

Data::DiscreteSet & get_data()
..............................

get sagitta/derivative data container

virtual double sagitta(double r) const
......................................

This virtual function implements the 'sagitta (*note _144::)' pure
function declared in the 'Rotational (*note
Curve_Rotational_class_reference::)' base abstract class.

   Documentation inherited from base class:

   Get curve sagitta at specified distance from origin.

   * r: distance from curve origin (0, 0)

Curve::Spline class full member list
====================================

Functions
---------

   * Spline()
   * ~Spline()
   * virtual void derivative(const Math::Vector2 &xy, Math::Vector2
     &dxdy) const
   * virtual double derivative(double r) const
   * void fit(const Rotational &c, double radius, unsigned int points)
   * const Data::DiscreteSet & get_data() const
   * Data::DiscreteSet & get_data()
   * virtual void get_sample(unsigned int index, double &r, double &z)
     const
   * virtual unsigned int get_sample_count() const
   * virtual bool intersect(Math::Vector3 &point, const
     Math::VectorPair3 &ray) const
   * virtual void normal(Math::Vector3 &normal, const Math::Vector3
     &point) const
   * virtual double sagitta(const Math::Vector2 &xy) const
   * virtual double sagitta(double r) const

Curve::Zernike class reference
==============================

Declaration
-----------

     #include <Goptical/Curve/Zernike>

     namespace Goptical {
       namespace Curve {
         class Zernike;
       };
     };


   This class is a member of the Curve namespace.

Inheritance
-----------

Description
-----------

This class enables use of zernikes polynomials to define a surface
curve.  Zernikes terms can be enabled and disabled individually.

   Fitting can be used to get best fit Zernike polynomials coefficients
of an other curve.

   This implementation uses Zernike polynomials set as described in ISO
standard 10110-5.

   Based on Zernikes pages by James C Wyant and Michael Koch.
http://www.optics.arizona.edu/jcwyant/Zernikes/ZernikePolynomials.htm
and http://www.astro-electronic.de/faq2.htm

Members
-------

See also the full member list (*note
Curve_Zernike_class_full_member_list::) section for this class.

Inherited members
.................

   * 5 members inherited from Base (*note Curve_Base_class_reference::)

Functions
.........

   * Zernike(double radius, double unit_scale = _[...]_)
   * Zernike(double radius, double coefs[], unsigned int coefs_count,
     double unit_scale = _[...]_)
   * virtual void derivative(const Math::Vector2 &xy, Math::Vector2
     &dxdy) const
   * double fit(const Base &c, const Trace::Distribution &d = _[...]_)
   * double get_coefficient(unsigned int n) const
   * double get_radius() const
   * bool get_term_state(unsigned int n)
   * virtual double sagitta(const Math::Vector2 &xy) const
   * void set_coefficient(unsigned int n, double c)
   * void set_coefficients_scale(double s)
   * void set_coefficients_threshold(double t)
   * void set_radius(double radius)
   * void set_term_state(unsigned int n, bool enabled)

Static functions
................

   * static double zernike_poly(unsigned int n, const Math::Vector2 &xy)
   * static void zernike_poly_d(unsigned int n, const Math::Vector2 &xy,
     Math::Vector2 &dxdy)

Constant
........

   * static const unsigned int term_count

Members detail
--------------

Zernike(double radius, double unit_scale = 1.0)
...............................................

Create a Zernike curve defined over the given circle radius.

   * radius: Zernike circle radius
   * unit_scale: Sagitta scale factor used to change units globally

Zernike(double radius, double coefs[], unsigned int coefs_count, double unit_scale = 1.0)
.........................................................................................

Create a Zernike curve defined over the given circle radius and
initialize coefficients from table.

   * radius: Zernike circle radius
   * coefs: Table of Zernike coefficients starting with z0 (piston)
   * coefs_count: Number of coefficients available in the table
   * unit_scale: Sagitta scale factor used to change units globally

virtual void derivative(const Math::Vector2 &xy, Math::Vector2 &dxdy) const
...........................................................................

This virtual function overrides the 'derivative (*note _39::)' virtual
function defined in the 'Base (*note Curve_Base_class_reference::)' base
abstract class.

   Documentation inherited from base class:

   Get curve x and y derivative (gradient) at specified point

double fit(const Base &c, const Trace::Distribution &d = default_dist)
......................................................................

Compute all zernike coefficient to best fit the given curve.  RMS
difference is returned.  The specified distribution is used to choose
sampling points on curve.  Terms state is adjusted according to current
threshold

double get_coefficient(unsigned int n) const
............................................

Get coefficient associated with zernike term n

double get_radius() const
.........................

Get Zernike circle radius

bool get_term_state(unsigned int n)
...................................

Get current term enable state

virtual double sagitta(const Math::Vector2 &xy) const
.....................................................

This virtual function implements the 'sagitta (*note _42::)' pure
function declared in the 'Base (*note Curve_Base_class_reference::)'
base abstract class.

   Documentation inherited from base class:

   Get curve sagitta at specified point

void set_coefficient(unsigned int n, double c)
..............................................

Set coefficient associated with zernike term n and enable term according
to current threshold.  See set_coefficients_threshold()

void set_coefficients_scale(double s)
.....................................

Set coefficients unit scale factor.  default is 1 (1 mm).

void set_coefficients_threshold(double t)
.........................................

Set new coefficient threshold and adjust all term states
(enabled/disabled) depending on new threshold.  Term with coefficient
absolute value below the specified threshold will be disabled.
Disabling useless terms improve performance.  Default threshold is
10^-10.

void set_radius(double radius)
..............................

Set Zernike circle radius

void set_term_state(unsigned int n, bool enabled)
.................................................

This functions must be used to enable/disable a zernike term without
changing its coefficient

static const unsigned int term_count
....................................

Number of implemented zernike polynomials

static double zernike_poly(unsigned int n, const Math::Vector2 &xy)
...................................................................

Evaluate zernike polynomial n

static void zernike_poly_d(unsigned int n, const Math::Vector2 &xy, Math::Vector2 &dxdy)
........................................................................................

Evaluate x and y derivatives of zernike polynomial n

Curve::Zernike class full member list
=====================================

Functions
---------

   * Zernike(double radius, double unit_scale = _[...]_)
   * Zernike(double radius, double coefs[], unsigned int coefs_count,
     double unit_scale = _[...]_)
   * virtual void derivative(const Math::Vector2 &xy, Math::Vector2
     &dxdy) const
   * double fit(const Base &c, const Trace::Distribution &d = _[...]_)
   * double get_coefficient(unsigned int n) const
   * double get_radius() const
   * bool get_term_state(unsigned int n)
   * virtual bool intersect(Math::Vector3 &point, const
     Math::VectorPair3 &ray) const
   * virtual void normal(Math::Vector3 &normal, const Math::Vector3
     &point) const
   * virtual double sagitta(const Math::Vector2 &xy) const
   * void set_coefficient(unsigned int n, double c)
   * void set_coefficients_scale(double s)
   * void set_coefficients_threshold(double t)
   * void set_radius(double radius)
   * void set_term_state(unsigned int n, bool enabled)

Static functions
----------------

   * static double zernike_poly(unsigned int n, const Math::Vector2 &xy)
   * static void zernike_poly_d(unsigned int n, const Math::Vector2 &xy,
     Math::Vector2 &dxdy)

Constant
--------

   * static const unsigned int term_count

Curve::ConicBase class reference
================================

Declaration
-----------

     #include <Goptical/Curve/ConicBase>

     namespace Goptical {
       namespace Curve {
         class ConicBase;
       };
     };


   This class is a member of the Curve namespace.

   This abstract class contains pure virtuals.

Inheritance
-----------

Description
-----------

This base class defines common properties of rotationally symmetric
conic curves.  These curves are all defined by a radius of curvature and
deformation coefficient.

   Fitting can be used to find best fit conic of an other rotationally
symmetric curve either with fixed or free deformation parameter.

Members
-------

See also the full member list (*note
Curve_ConicBase_class_full_member_list::) section for this class.

Inherited members
.................

   * 2 members inherited from CurveRoc (*note
     Curve_CurveRoc_class_reference::)
   * 9 members inherited from Rotational (*note
     Curve_Rotational_class_reference::)

Functions
.........

   * virtual double derivative(double r) const = 0;
   * double fit_roc(const Rotational &c, double radius, unsigned int
     count)
   * double get_eccentricity() const
   * double get_schwarzschild() const
   * virtual bool intersect(Math::Vector3 &point, const
     Math::VectorPair3 &ray) const = 0;
   * virtual double sagitta(double r) const = 0;

Members detail
--------------

virtual double derivative(double r) const = 0;
..............................................

This pure virtual function shadows the 'derivative (*note _139::)'
virtual function defined in the 'Rotational (*note
Curve_Rotational_class_reference::)' base abstract class.

   Documentation inherited from base class:

   Get curve derivative at specified distance from origin.

   * r: distance from curve origin (0, 0)

double fit_roc(const Rotational &c, double radius, unsigned int count)
......................................................................

Adjust radius of curvature to best fit given curve.  Deformation Won't
be changed by this function.  See Conic::fit() to adjust deformation
too.

   Parameters list:

   * curve: Curve to fit
   * radius: Maximum radius used to get sample points
   * count: Number of sample points to use

double get_eccentricity() const
...............................

get eccentricity

double get_schwarzschild() const
................................

get Schwarzschild constant

virtual bool intersect(Math::Vector3 &point, const Math::VectorPair3 &ray) const = 0;
.....................................................................................

This pure virtual function shadows the 'intersect (*note _40::)' virtual
function defined in the 'Base (*note Curve_Base_class_reference::)' base
abstract class.

   Documentation inherited from base class:

   Get intersection point between curve and 3d ray.  Return false if no
intersection occurred

virtual double sagitta(double r) const = 0;
...........................................

This pure virtual function shadows the 'sagitta (*note _144::)' pure
virtual function defined in the 'Rotational (*note
Curve_Rotational_class_reference::)' base abstract class.

   Documentation inherited from base class:

   Get curve sagitta at specified distance from origin.

   * r: distance from curve origin (0, 0)

Curve::ConicBase class full member list
=======================================

Functions
---------

   * virtual void derivative(const Math::Vector2 &xy, Math::Vector2
     &dxdy) const
   * virtual double derivative(double r) const = 0;
   * double fit_roc(const Rotational &c, double radius, unsigned int
     count)
   * double get_eccentricity() const
   * double get_roc() const
   * virtual void get_sample(unsigned int index, double &r, double &z)
     const
   * virtual unsigned int get_sample_count() const
   * double get_schwarzschild() const
   * virtual bool intersect(Math::Vector3 &point, const
     Math::VectorPair3 &ray) const = 0;
   * virtual void normal(Math::Vector3 &normal, const Math::Vector3
     &point) const
   * virtual double sagitta(const Math::Vector2 &xy) const
   * virtual double sagitta(double r) const = 0;
   * void set_roc(double roc)

Curve::CurveRoc class reference
===============================

Declaration
-----------

     #include <Goptical/Curve/CurveRoc>

     namespace Goptical {
       namespace Curve {
         class CurveRoc;
       };
     };


   This class is a member of the Curve namespace.

Inheritance
-----------

Description
-----------

Base class for curves with a radius of curvature

Members
-------

See also the full member list (*note
Curve_CurveRoc_class_full_member_list::) section for this class.

Functions
.........

   * double get_roc() const
   * void set_roc(double roc)

Members detail
--------------

double get_roc() const
......................

Get the radius of curvature

void set_roc(double roc)
........................

Set the radius of curvature

Curve::CurveRoc class full member list
======================================

Functions
---------

   * double get_roc() const
   * void set_roc(double roc)

Curve::Rotational class reference
=================================

Declaration
-----------

     #include <Goptical/Curve/Rotational>

     namespace Goptical {
       namespace Curve {
         class Rotational;
       };
     };


   This class is a member of the Curve namespace.

   This abstract class contains pure virtuals.

Inheritance
-----------

Description
-----------

This class defines rotationally symmetric curve interface and provide
default implementation as generic non symmetric curve.

Members
-------

See also the full member list (*note
Curve_Rotational_class_full_member_list::) section for this class.

Inherited members
.................

   * 5 members inherited from Base (*note Curve_Base_class_reference::)

Functions
.........

   * Rotational()
   * virtual double derivative(double r) const
   * virtual void derivative(const Math::Vector2 &xy, Math::Vector2
     &dxdy) const
   * virtual void get_sample(unsigned int index, double &r, double &z)
     const
   * virtual unsigned int get_sample_count() const
   * virtual void normal(Math::Vector3 &normal, const Math::Vector3
     &point) const
   * virtual double sagitta(double r) const = 0;
   * virtual double sagitta(const Math::Vector2 &xy) const

Members detail
--------------

Rotational()
............

No documentation available

virtual double derivative(double r) const
.........................................

Get curve derivative at specified distance from origin.

   * r: distance from curve origin (0, 0)

virtual void derivative(const Math::Vector2 &xy, Math::Vector2 &dxdy) const
...........................................................................

This virtual function overrides the 'derivative (*note _39::)' virtual
function defined in the 'Base (*note Curve_Base_class_reference::)' base
abstract class.

   Documentation inherited from base class:

   Get curve x and y derivative (gradient) at specified point

virtual void get_sample(unsigned int index, double &r, double &z) const
.......................................................................

Get a sample point on curve.  (0,0) is not included.

virtual unsigned int get_sample_count() const
.............................................

Get number of available sample points.  Samples points may be used by
curve fitting algorithms and are choosen to avoid using interpolated
points.  return 0 when not applicable.

virtual void normal(Math::Vector3 &normal, const Math::Vector3 &point) const
............................................................................

This virtual function overrides the 'normal (*note _41::)' virtual
function defined in the 'Base (*note Curve_Base_class_reference::)' base
abstract class.

   Documentation inherited from base class:

   Get normal to curve surface at specified point

virtual double sagitta(double r) const = 0;
...........................................

Get curve sagitta at specified distance from origin.

   * r: distance from curve origin (0, 0)

virtual double sagitta(const Math::Vector2 &xy) const
.....................................................

This virtual function implements the 'sagitta (*note _42::)' pure
function declared in the 'Base (*note Curve_Base_class_reference::)'
base abstract class.

   Documentation inherited from base class:

   Get curve sagitta at specified point

Curve::Rotational class full member list
========================================

Functions
---------

   * Rotational()
   * virtual double derivative(double r) const
   * virtual void derivative(const Math::Vector2 &xy, Math::Vector2
     &dxdy) const
   * virtual void get_sample(unsigned int index, double &r, double &z)
     const
   * virtual unsigned int get_sample_count() const
   * virtual bool intersect(Math::Vector3 &point, const
     Math::VectorPair3 &ray) const
   * virtual void normal(Math::Vector3 &normal, const Math::Vector3
     &point) const
   * virtual double sagitta(double r) const = 0;
   * virtual double sagitta(const Math::Vector2 &xy) const

Data namespace reference
========================

Description
-----------

Numerical data interpolation and plotting

Members
-------

Types
.....

   * class DiscreteSet
   * class Grid
   * class Plot
   * class PlotData
   * class SampleSet
   * enum Interpolation
   * enum PlotStyleMask
   * class Set
   * class Set1d

Functions
.........

   * PlotStyleMask operator&(PlotStyleMask a, PlotStyleMask b)
   * std::ostream & operator<<(std::ostream &o, const Set &s)
   * PlotStyleMask operator|(PlotStyleMask a, PlotStyleMask b)
   * PlotStyleMask operator~(PlotStyleMask a)

Members detail
--------------

enum Interpolation
..................

Specifies data interpolation methods.  Availability depends on data
container used.

Identifier             Description
--------------------------------------------------------------------------
Nearest                1d and 2d nearest interpolation
                       
Linear                 1d linear and 2d bilinear interpolations
                       
Quadratic              1d quadratic interpolation
                       
CubicSimple            1d cubic piecewise interpolation.  It has
                       continuous piecewise first derivative,
                       non-continuous piecewise linear second
                       derivative.  Use segments slope as first
                       derivative.  Less accurate than other cubic
                       interpolants but requires less computation on
                       data set change.
                       
Cubic                  1d cubic piecewise interpolation.  It has smooth
                       first derivative and continuous piecewise linear
                       second derivative.  Derivatives for first and
                       last entries are based on first and last
                       segments slope.  It uses linear extrapolation
                       (continuous but non-smooth first derivative on
                       both ends).
                       
Cubic2                 Same interpolation as Cubic, with quadratic
                       extrapolation (continous and smooth first
                       derivative on both ends).
                       
CubicDerivInit         Same as Cubic with first derivative prescribed
                       for first and last entries only.
                       
Cubic2DerivInit        Same as Cubic2 with first derivative prescribed
                       for first and last entries only.
                       
CubicDeriv             1d cubic piecewise interpolation.  First
                       derivatives must be provided for all entries.
                       It uses linear extrapolation.
                       
Cubic2Deriv            1d cubic piecewise interpolation.  First
                       derivatives must be provided for all entries.
                       It uses quadratic extrapolation.
                       
Bicubic                2d bicubic interpolation.  Use smooth first
                       derivative and continuous piecewise linear
                       second derivative.  Use 1d cubic curve to
                       extract gradients (smooth first derivative and
                       continuous piecewise linear second derivative).
                       This is the best 2d interpolation when
                       derivatives are non-prescribed.
                       
BicubicDiff            2d bicubic interpolation.  Use numerical
                       differencing to extract gradients.  Less
                       accurate than Bicubic (*note _146::) but
                       requires less computation on data set change.
                       
BicubicDeriv           2d bicubic interpolation.  x and y gradients
                       must be provided.  This is the best 2d
                       interpolation when derivatives values are
                       available.
                       

enum PlotStyleMask
..................

Specifies available styles for 2d and 3d plot data rendering

Identifier             Description
--------------------------------------------------------------------------
LinePlot               Draw lines between knots
                       
PointPlot              Draw points for each knot
                       
InterpolatePlot        Draw a smooth curve
                       
ValuePlot              Print ploted values near knots
                       
Filled                 Draw filled 3d surface
                       

PlotStyleMask operator&(PlotStyleMask a, PlotStyleMask b)
.........................................................

Bitwise and operation for use on PlotStyleMask (*note _147::) enum.

std:: ostream & operator<<(std:: ostream &o, const Set &s)
..........................................................

No documentation available

PlotStyleMask operator|(PlotStyleMask a, PlotStyleMask b)
.........................................................

Bitwise or operation for use on PlotStyleMask (*note _147::) enum.

PlotStyleMask operator~(PlotStyleMask a)
........................................

Bitwise not operation for use on PlotStyleMask (*note _147::) enum.

Data::DiscreteSet class reference
=================================

Declaration
-----------

     #include <Goptical/Data/DiscreteSet>

     namespace Goptical {
       namespace Data {
         class DiscreteSet;
       };
     };


   This class is a member of the Data namespace.

Inheritance
-----------

Description
-----------

This class provides a numerical data container where value pairs can be
defined at arbitrary positions (x, y).

   Severals interpolation algorithms are available to guess values
between defined knots, see Interpolation (*note _146::).

   See also SampleSet (*note Data_SampleSet_class_reference::) class.

Members
-------

See also the full member list (*note
Data_DiscreteSet_class_full_member_list::) section for this class.

Inherited members
.................

   * 19 members inherited from Set1d (*note
     Data_Set1d_class_reference::)

Functions
.........

   * DiscreteSet()
   * void add_data(double x, double y, double yp = _[...]_)
   * void clear()
   * virtual unsigned int get_count() const
   * double get_d_value(unsigned int x) const
   * double & get_d_value(unsigned int x)
   * virtual Math::range_t get_x_range() const
   * virtual double get_x_value(unsigned int x) const
   * virtual double get_y_value(unsigned int x) const
   * virtual double & get_y_value(unsigned int x)
   * virtual double interpolate(const double x) const
   * virtual double interpolate(const double x, unsigned int deriv)
     const
   * void reserve(size_t n)
   * virtual void set_interpolation(Interpolation i)

Members detail
--------------

DiscreteSet()
.............

No documentation available

Data::DiscreteSet class full member list
========================================

Functions
---------

   * DiscreteSet()
   * void add_data(double x, double y, double yp = _[...]_)
   * void clear()
   * virtual unsigned int get_count(unsigned int dim) const
   * virtual unsigned int get_count() const
   * double get_d_value(unsigned int x) const
   * double & get_d_value(unsigned int x)
   * virtual unsigned int get_dimensions() const
   * Interpolation get_interpolation()
   * unsigned int get_version() const
   * virtual Math::range_t get_x_range(unsigned int dimension) const
   * virtual Math::range_t get_x_range() const
   * virtual double get_x_value(unsigned int n, unsigned int dim) const
   * virtual double get_x_value(unsigned int x) const
   * virtual Math::range_t get_y_range() const
   * virtual double get_y_value(const unsigned int x[]) const
   * virtual double get_y_value(unsigned int x) const
   * virtual double & get_y_value(unsigned int x)
   * virtual double interpolate(const double x[]) const
   * virtual double interpolate(const double x[], unsigned int deriv,
     unsigned int dimension) const
   * virtual double interpolate(const double x) const
   * virtual double interpolate(const double x, unsigned int deriv)
     const
   * void reserve(size_t n)
   * virtual void set_interpolation(Interpolation i)

Data::Grid class reference
==========================

Declaration
-----------

     #include <Goptical/Data/Grid>

     namespace Goptical {
       namespace Data {
         class Grid;
       };
     };


   This class is a member of the Data namespace.

Inheritance
-----------

Description
-----------

This class provides a numerical data container where data value can be
defined for each point of a 2d rectangular grid.  The grid is defined by
grid samples count (n1, n2), a 2d origin vector and 2 steps values.

   Severals interpolation algorithms are available to guess values
between grid defined knots, see Interpolation (*note _146::).

Members
-------

See also the full member list (*note Data_Grid_class_full_member_list::)
section for this class.

Inherited members
.................

   * 12 members inherited from Set (*note Data_Set_class_reference::)

Functions
.........

   * Grid(unsigned int n1, unsigned int n2, const Math::Vector2 &origin
     = _[...]_, const Math::Vector2 &step = _[...]_)
   * ~Grid()
   * virtual unsigned int get_count(unsigned int dimension) const
   * const Math::Vector2 & get_d_value(unsigned int n1, unsigned int n2)
     const
   * Math::Vector2 & get_d_value(unsigned int n1, unsigned int n2)
   * virtual unsigned int get_dimensions() const
   * const Math::Vector2 & get_nearest_d(const Math::Vector2 &v) const
   * Math::Vector2 & get_nearest_d(const Math::Vector2 &v)
   * double get_nearest_y(const Math::Vector2 &v) const
   * double & get_nearest_y(const Math::Vector2 &v)
   * const Math::Vector2 & get_origin() const
   * const Math::Vector2 & get_step() const
   * virtual Math::range_t get_x_range(unsigned int dimension) const
   * virtual double get_x_value(unsigned int x, unsigned int dimension)
     const
   * Math::Vector2 get_x_value_i(unsigned int n1, unsigned int n2) const
   * double get_y_value(unsigned int n1, unsigned int n2) const
   * double & get_y_value(unsigned int n1, unsigned int n2)
   * virtual double get_y_value(const unsigned int n[]) const
   * double interpolate(const Math::Vector2 &v) const
   * virtual double interpolate(const double x[]) const
   * virtual double interpolate(const double x[], unsigned int deriv,
     unsigned int dimension) const
   * Math::Vector2 interpolate_deriv(const Math::Vector2 &v) const
   * void resize(unsigned int n1, unsigned int n2)
   * void set_all_d(const Math::Vector2 &deriv = _[...]_)
   * void set_all_y(double y = _[...]_)
   * virtual void set_interpolation(Interpolation i)
   * void set_metrics(const Math::Vector2 &origin, const Math::Vector2
     &step)

Members detail
--------------

Grid(unsigned int n1, unsigned int n2, const Math::Vector2 &origin = Math::Vector2(0,0), const Math::Vector2 &step = Math::Vector2(1,1))
........................................................................................................................................

Create a Grid object with given sample counts and metrics.

   * n1: Number of samples along the first dimension axis.
   * n2: Number of samples along the second dimension axis.
   * origin: Grid origin point
   * step: Step values for each grid dimensions

~Grid()
.......

No documentation available

virtual unsigned int get_count(unsigned int dimension) const
............................................................

This virtual function implements the 'get_count (*note _223::)' pure
function declared in the 'Set (*note Data_Set_class_reference::)' base
abstract class.

   Documentation inherited from base class:

   Get total number of data stored for dimension n in data set

const Math::Vector2 & get_d_value(unsigned int n1, unsigned int n2) const
.........................................................................

Get 1st derivative/gradient vector at sample point index (n1, n2).  Only
available when Data::BicubicDeriv interpolation is selected.

Math::Vector2 & get_d_value(unsigned int n1, unsigned int n2)
.............................................................

Get modifiable reference to 1st derivative/gradient vector at sample
point index (n1, n2).  Only available when Data::BicubicDeriv
interpolation is selected.

virtual unsigned int get_dimensions() const
...........................................

This virtual function implements the 'get_dimensions (*note _224::)'
pure function declared in the 'Set (*note Data_Set_class_reference::)'
base abstract class.

   Documentation inherited from base class:

   Get total number of dimensions

const Math::Vector2 & get_nearest_d(const Math::Vector2 &v) const
.................................................................

Get 1st derivative/gradient vector stored at nearest sample point from
2d vector on grid.  Only available when Data::BicubicDeriv interpolation
is selected.

Math::Vector2 & get_nearest_d(const Math::Vector2 &v)
.....................................................

Get modifiable reference to 1st derivative/gradient vector stored at
nearest sample point from 2d vector on grid.  Only available when
Data::BicubicDeriv interpolation is selected.

double get_nearest_y(const Math::Vector2 &v) const
..................................................

Get value stored at nearest sample point from 2d vector on grid

double & get_nearest_y(const Math::Vector2 &v)
..............................................

Get modifiable reference to value stored at nearest sample point from 2d
vector on grid

const Math::Vector2 & get_origin() const
........................................

Get origin vector

const Math::Vector2 & get_step() const
......................................

Get step values vector

virtual Math::range_t get_x_range(unsigned int dimension) const
...............................................................

This virtual function implements the 'get_x_range (*note _227::)' pure
function declared in the 'Set (*note Data_Set_class_reference::)' base
abstract class.

   Documentation inherited from base class:

   Get minimal and maximal x values on dimension n found in data set

virtual double get_x_value(unsigned int x, unsigned int dimension) const
........................................................................

This virtual function implements the 'get_x_value (*note _228::)' pure
function declared in the 'Set (*note Data_Set_class_reference::)' base
abstract class.

   Documentation inherited from base class:

   Get data stored at position n on dimension dim in data set

Math::Vector2 get_x_value_i(unsigned int n1, unsigned int n2) const
...................................................................

Get 2d vector on grid of the sample point at index (n1, n2)

double get_y_value(unsigned int n1, unsigned int n2) const
..........................................................

Get value stored at sample point index (n1, n2)

double & get_y_value(unsigned int n1, unsigned int n2)
......................................................

Get modifiable reference to value stored at sample point index (n1, n2)

virtual double get_y_value(const unsigned int n[]) const
........................................................

This virtual function implements the 'get_y_value (*note _230::)' pure
function declared in the 'Set (*note Data_Set_class_reference::)' base
abstract class.

   Documentation inherited from base class:

   Get y data stored at position (x0, x1, ...)  in data set

double interpolate(const Math::Vector2 &v) const
................................................

Interpolate data at given 2d vector point on grid using currently
selected interpolation algorithm

virtual double interpolate(const double x[]) const
..................................................

This virtual function implements the 'interpolate (*note _231::)' pure
function declared in the 'Set (*note Data_Set_class_reference::)' base
abstract class.

   Documentation inherited from base class:

   Interpolate y value corresponding to given x value(s) in data set.

virtual double interpolate(const double x[], unsigned int deriv, unsigned int dimension) const
..............................................................................................

This virtual function implements the 'interpolate (*note _232::)' pure
function declared in the 'Set (*note Data_Set_class_reference::)' base
abstract class.

   Documentation inherited from base class:

   Interpolate y value corresponding to given x value in data set.  Data
may be differentiated several times along the requested dimension.

   * deriv: Differentiation count, 0 means y value, 1 means 1st
     derivative...
   * dim: Differentiation dimension

Math::Vector2 interpolate_deriv(const Math::Vector2 &v) const
.............................................................

Interpolate gradient at given 2d vector point on grid using currently
selected interpolation algorithm

void resize(unsigned int n1, unsigned int n2)
.............................................

Change grid size by defining new sample counts for each dimensions

void set_all_d(const Math::Vector2 &deriv = Math::Vector2(0,0))
...............................................................

Change all grid points stored gradient.  Only available when
Data::BicubicDeriv interpolation is selected.

void set_all_y(double y = 0.0)
..............................

Change all grid points stored values

virtual void set_interpolation(Interpolation i)
...............................................

This virtual function implements the 'set_interpolation (*note _233::)'
pure function declared in the 'Set (*note Data_Set_class_reference::)'
base abstract class.

   Documentation inherited from base class:

   Select interpolation method

void set_metrics(const Math::Vector2 &origin, const Math::Vector2 &step)
........................................................................

Set grid origin 2d vector and step values

Data::Grid class full member list
=================================

Functions
---------

   * Grid(unsigned int n1, unsigned int n2, const Math::Vector2 &origin
     = _[...]_, const Math::Vector2 &step = _[...]_)
   * ~Grid()
   * virtual unsigned int get_count(unsigned int dimension) const
   * const Math::Vector2 & get_d_value(unsigned int n1, unsigned int n2)
     const
   * Math::Vector2 & get_d_value(unsigned int n1, unsigned int n2)
   * virtual unsigned int get_dimensions() const
   * Interpolation get_interpolation()
   * const Math::Vector2 & get_nearest_d(const Math::Vector2 &v) const
   * Math::Vector2 & get_nearest_d(const Math::Vector2 &v)
   * double get_nearest_y(const Math::Vector2 &v) const
   * double & get_nearest_y(const Math::Vector2 &v)
   * const Math::Vector2 & get_origin() const
   * const Math::Vector2 & get_step() const
   * unsigned int get_version() const
   * virtual Math::range_t get_x_range(unsigned int dimension) const
   * virtual double get_x_value(unsigned int x, unsigned int dimension)
     const
   * Math::Vector2 get_x_value_i(unsigned int n1, unsigned int n2) const
   * virtual Math::range_t get_y_range() const
   * double get_y_value(unsigned int n1, unsigned int n2) const
   * double & get_y_value(unsigned int n1, unsigned int n2)
   * virtual double get_y_value(const unsigned int n[]) const
   * double interpolate(const Math::Vector2 &v) const
   * virtual double interpolate(const double x[]) const
   * virtual double interpolate(const double x[], unsigned int deriv,
     unsigned int dimension) const
   * Math::Vector2 interpolate_deriv(const Math::Vector2 &v) const
   * void resize(unsigned int n1, unsigned int n2)
   * void set_all_d(const Math::Vector2 &deriv = _[...]_)
   * void set_all_y(double y = _[...]_)
   * virtual void set_interpolation(Interpolation i)
   * void set_metrics(const Math::Vector2 &origin, const Math::Vector2
     &step)

Data::Plot class reference
==========================

Declaration
-----------

     #include <Goptical/Data/Plot>

     namespace Goptical {
       namespace Data {
         class Plot;
       };
     };


   This class is a member of the Data namespace.

Inheritance
-----------

Description
-----------

This class is used to describe a data plot.  It contains a list of
PlotData (*note Data_PlotData_class_reference::) objects and describes
some plot properties (title, range, ...).

   Plots can be built from data sets or obtained directly from various
analysis functions.  They can be rendered on a Io::RendererViewport
(*note Io_RendererViewport_class_reference::) object with the draw
(*note _183::) function.

Members
-------

See also the full member list (*note Data_Plot_class_full_member_list::)
section for this class.

Functions
.........

   * Plot()
   * PlotData & add_plot_data(const Set &data, const Io::Rgb &color =
     _[...]_, const std::string &label = _[...]_, PlotStyleMask style =
     _[...]_)
   * void add_plot_data(PlotData &data)
   * void draw(Io::RendererViewport &r)
   * void erase_plot_data()
   * void fit_axes_range()
   * Io::RendererAxes & get_axes()
   * const Io::RendererAxes & get_axes() const
   * unsigned int get_dimensions() const
   * unsigned int get_plot_count() const
   * PlotData & get_plot_data(unsigned int index)
   * const PlotData & get_plot_data(unsigned int index) const
   * const std::string & get_title() const
   * Math::range_t get_x_data_range(unsigned int dimension = _[...]_)
     const
   * bool get_xy_swap() const
   * Math::range_t get_y_data_range() const
   * void set_color(const Io::Rgb &color)
   * void set_different_colors()
   * void set_style(PlotStyleMask style)
   * void set_title(const std::string &title)
   * void set_xy_swap(bool doswap)

Members detail
--------------

Plot()
......

Create a new empty plot

PlotData & add_plot_data(const Set &data, const Io::Rgb &color = Io::rgb_red, const std:: string &label = "data", PlotStyleMask style = InterpolatePlot|PointPlot)
..................................................................................................................................................................

Create and add plot data from specified data set.

void add_plot_data(PlotData &data)
..................................

Add plot data

void draw(Io::RendererViewport &r)
..................................

draw

void erase_plot_data()
......................

Discard all plot data set

void fit_axes_range()
.....................

Set axis position to dataset range

Io::RendererAxes & get_axes()
.............................

Get plot axes object

const Io::RendererAxes & get_axes() const
.........................................

Get plot axes object

unsigned int get_dimensions() const
...................................

Get data sets dimensions, return 0 if inconsistent

unsigned int get_plot_count() const
...................................

Get plot data set count

PlotData & get_plot_data(unsigned int index)
............................................

Get plot data set at given index

const PlotData & get_plot_data(unsigned int index) const
........................................................

Get plot data set at given index

const std:: string & get_title() const
......................................

Get plot main title

Math::range_t get_x_data_range(unsigned int dimension = 0) const
................................................................

Get range of x data in sets

bool get_xy_swap() const
........................

Get x and y axis swap state for 2d plots

Math::range_t get_y_data_range() const
......................................

Get range of y data in sets

void set_color(const Io::Rgb &color)
....................................

Set color for all plots

void set_different_colors()
...........................

Automatically choose different colors for each plot

void set_style(PlotStyleMask style)
...................................

Set plot style for all plot

void set_title(const std:: string &title)
.........................................

Set plot main title

void set_xy_swap(bool doswap)
.............................

Swap x and y axis for 2d plots

Data::Plot class full member list
=================================

Functions
---------

   * Plot()
   * PlotData & add_plot_data(const Set &data, const Io::Rgb &color =
     _[...]_, const std::string &label = _[...]_, PlotStyleMask style =
     _[...]_)
   * void add_plot_data(PlotData &data)
   * void draw(Io::RendererViewport &r)
   * void erase_plot_data()
   * void fit_axes_range()
   * Io::RendererAxes & get_axes()
   * const Io::RendererAxes & get_axes() const
   * unsigned int get_dimensions() const
   * unsigned int get_plot_count() const
   * PlotData & get_plot_data(unsigned int index)
   * const PlotData & get_plot_data(unsigned int index) const
   * const std::string & get_title() const
   * Math::range_t get_x_data_range(unsigned int dimension = _[...]_)
     const
   * bool get_xy_swap() const
   * Math::range_t get_y_data_range() const
   * void set_color(const Io::Rgb &color)
   * void set_different_colors()
   * void set_style(PlotStyleMask style)
   * void set_title(const std::string &title)
   * void set_xy_swap(bool doswap)

Data::PlotData class reference
==============================

Declaration
-----------

     #include <Goptical/Data/PlotData>

     namespace Goptical {
       namespace Data {
         class PlotData;
       };
     };


   This class is a member of the Data namespace.

Description
-----------

This class is used to describe a data set as part of a data plot.  It
contains a pointer to the data set and plotting informations (title,
color, ...)

Members
-------

See also the full member list (*note
Data_PlotData_class_full_member_list::) section for this class.

Functions
.........

   * PlotData(const const_ref<Set> &s)
   * void disable_style(PlotStyleMask style)
   * void enable_style(PlotStyleMask style)
   * const Io::Rgb & get_color() const
   * const std::string & get_label() const
   * const Set & get_set() const
   * PlotStyleMask get_style() const
   * void set_color(const Io::Rgb &color)
   * void set_label(const std::string &title)
   * void set_style(PlotStyleMask style)

Members detail
--------------

PlotData(const const_ref <Set> &s)
..................................

Create a new data plot descriptor which describe the specified dataset.

void disable_style(PlotStyleMask style)
.......................................

Disable a plotting style

void enable_style(PlotStyleMask style)
......................................

Enable a plotting style

const Io::Rgb & get_color() const
.................................

Set data set plotting color

const std:: string & get_label() const
......................................

Get data set plotting label

const Set & get_set() const
...........................

Get the described data set

PlotStyleMask get_style() const
...............................

Get the plotting style mask

void set_color(const Io::Rgb &color)
....................................

Set data set plotting color

void set_label(const std:: string &title)
.........................................

Set data set plotting label

void set_style(PlotStyleMask style)
...................................

Set the plotting style mask

Data::PlotData class full member list
=====================================

Functions
---------

   * PlotData(const const_ref<Set> &s)
   * void disable_style(PlotStyleMask style)
   * void enable_style(PlotStyleMask style)
   * const Io::Rgb & get_color() const
   * const std::string & get_label() const
   * const Set & get_set() const
   * PlotStyleMask get_style() const
   * void set_color(const Io::Rgb &color)
   * void set_label(const std::string &title)
   * void set_style(PlotStyleMask style)

Data::SampleSet class reference
===============================

Declaration
-----------

     #include <Goptical/Data/SampleSet>

     namespace Goptical {
       namespace Data {
         class SampleSet;
       };
     };


   This class is a member of the Data namespace.

Inheritance
-----------

Description
-----------

This class provides a numerical data container where sample values (y)
are defined for uniformly distributed (x) values.

   Severals interpolation algorithms are available to guess values
between defined knots, see Interpolation (*note _146::).

   See also DiscreteSet (*note Data_DiscreteSet_class_reference::)
class.

Members
-------

See also the full member list (*note
Data_SampleSet_class_full_member_list::) section for this class.

Inherited members
.................

   * 19 members inherited from Set1d (*note
     Data_Set1d_class_reference::)

Functions
.........

   * SampleSet()
   * void clear()
   * virtual unsigned int get_count() const
   * double get_d_value(unsigned int x) const
   * double & get_d_value(unsigned int x)
   * double get_origin() const
   * double get_step() const
   * virtual Math::range_t get_x_range() const
   * virtual double get_x_value(unsigned int x) const
   * virtual double get_y_value(unsigned int x) const
   * virtual double & get_y_value(unsigned int x)
   * virtual double interpolate(const double x) const
   * virtual double interpolate(const double x, unsigned int deriv)
     const
   * void resize(unsigned int n)
   * virtual void set_interpolation(Interpolation i)
   * void set_metrics(double origin, double step)
   * void set_value(unsigned int x, double y, double d = _[...]_)
   * void set_value_near(double x, double y, double d = _[...]_)

Members detail
--------------

SampleSet()
...........

No documentation available

Data::SampleSet class full member list
======================================

Functions
---------

   * SampleSet()
   * void clear()
   * virtual unsigned int get_count(unsigned int dim) const
   * virtual unsigned int get_count() const
   * double get_d_value(unsigned int x) const
   * double & get_d_value(unsigned int x)
   * virtual unsigned int get_dimensions() const
   * Interpolation get_interpolation()
   * double get_origin() const
   * double get_step() const
   * unsigned int get_version() const
   * virtual Math::range_t get_x_range(unsigned int dimension) const
   * virtual Math::range_t get_x_range() const
   * virtual double get_x_value(unsigned int n, unsigned int dim) const
   * virtual double get_x_value(unsigned int x) const
   * virtual Math::range_t get_y_range() const
   * virtual double get_y_value(const unsigned int x[]) const
   * virtual double get_y_value(unsigned int x) const
   * virtual double & get_y_value(unsigned int x)
   * virtual double interpolate(const double x[]) const
   * virtual double interpolate(const double x[], unsigned int deriv,
     unsigned int dimension) const
   * virtual double interpolate(const double x) const
   * virtual double interpolate(const double x, unsigned int deriv)
     const
   * void resize(unsigned int n)
   * virtual void set_interpolation(Interpolation i)
   * void set_metrics(double origin, double step)
   * void set_value(unsigned int x, double y, double d = _[...]_)
   * void set_value_near(double x, double y, double d = _[...]_)

Data::Interpolate1d<Data::DiscreteSetBase> internal class members
=================================================================

Interpolate1d()
---------------

No documentation available

virtual double interpolate(const double x) const
------------------------------------------------

This virtual function implements the 'interpolate (*note _245::)' pure
function declared in the 'Set1d (*note Data_Set1d_class_reference::)'
base abstract class.

virtual double interpolate(const double x, unsigned int deriv) const
--------------------------------------------------------------------

This virtual function implements the 'interpolate (*note _246::)' pure
function declared in the 'Set1d (*note Data_Set1d_class_reference::)'
base abstract class.

virtual void set_interpolation(Interpolation i)
-----------------------------------------------

This virtual function implements the 'set_interpolation (*note _233::)'
pure function declared in the 'Set (*note Data_Set_class_reference::)'
base abstract class.

~Interpolate1d()
----------------

No documentation available

Data::Interpolate1d<Data::SampleSetBase> internal class members
===============================================================

Interpolate1d()
---------------

No documentation available

virtual double interpolate(const double x) const
------------------------------------------------

This virtual function implements the 'interpolate (*note _245::)' pure
function declared in the 'Set1d (*note Data_Set1d_class_reference::)'
base abstract class.

virtual double interpolate(const double x, unsigned int deriv) const
--------------------------------------------------------------------

This virtual function implements the 'interpolate (*note _246::)' pure
function declared in the 'Set1d (*note Data_Set1d_class_reference::)'
base abstract class.

virtual void set_interpolation(Interpolation i)
-----------------------------------------------

This virtual function implements the 'set_interpolation (*note _233::)'
pure function declared in the 'Set (*note Data_Set_class_reference::)'
base abstract class.

~Interpolate1d()
----------------

No documentation available

Data::Set class reference
=========================

Declaration
-----------

     #include <Goptical/Data/Set>

     namespace Goptical {
       namespace Data {
         class Set;
       };
     };


   This class is a member of the Data namespace.

   This abstract class contains pure virtuals.

Inheritance
-----------

Description
-----------

This class is a base class for all numerical data sets implementations.
It defines an interface to access data in a way independent from data
storage and dimensions count.

   Each data set implementation may define a alternative specific
interface to access their data.

   Here x is seen as value used to access the container.  Containers
with more than one dimension will require x0, x1, ..., xn known
parameters to access the stored y value.

Members
-------

See also the full member list (*note Data_Set_class_full_member_list::)
section for this class.

Functions
.........

   * virtual ~Set()
   * virtual unsigned int get_count(unsigned int dim = _[...]_)  const =
     0;
   * virtual unsigned int get_dimensions() const = 0;
   * Interpolation get_interpolation()
   * unsigned int get_version() const
   * virtual Math::range_t get_x_range(unsigned int dim = _[...]_)
     const = 0;
   * virtual double get_x_value(unsigned int n, unsigned int dim =
     _[...]_)  const = 0;
   * virtual Math::range_t get_y_range() const
   * virtual double get_y_value(const unsigned int x[]) const = 0;
   * virtual double interpolate(const double x[]) const = 0;
   * virtual double interpolate(const double x[], unsigned int deriv,
     unsigned int dim) const = 0;
   * virtual void set_interpolation(Interpolation i) = 0;

Members detail
--------------

virtual ~Set()
..............

No documentation available

virtual unsigned int get_count(unsigned int dim = 0) const = 0;
...............................................................

Get total number of data stored for dimension n in data set

virtual unsigned int get_dimensions() const = 0;
................................................

Get total number of dimensions

Interpolation get_interpolation()
.................................

Get current interpolation method

unsigned int get_version() const
................................

Return version number which is incremented on each data set change/clear

virtual Math::range_t get_x_range(unsigned int dim = 0) const = 0;
..................................................................

Get minimal and maximal x values on dimension n found in data set

virtual double get_x_value(unsigned int n, unsigned int dim = 0) const = 0;
...........................................................................

Get data stored at position n on dimension dim in data set

virtual Math::range_t get_y_range() const
.........................................

Get minimal and maximal y values found in data set

virtual double get_y_value(const unsigned int x[]) const = 0;
.............................................................

Get y data stored at position (x0, x1, ...)  in data set

virtual double interpolate(const double x[]) const = 0;
.......................................................

Interpolate y value corresponding to given x value(s) in data set.

virtual double interpolate(const double x[], unsigned int deriv, unsigned int dim) const = 0;
.............................................................................................

Interpolate y value corresponding to given x value in data set.  Data
may be differentiated several times along the requested dimension.

   * deriv: Differentiation count, 0 means y value, 1 means 1st
     derivative...
   * dim: Differentiation dimension

virtual void set_interpolation(Interpolation i) = 0;
....................................................

Select interpolation method

Data::Set class full member list
================================

Functions
---------

   * virtual ~Set()
   * virtual unsigned int get_count(unsigned int dim = _[...]_)  const =
     0;
   * virtual unsigned int get_dimensions() const = 0;
   * Interpolation get_interpolation()
   * unsigned int get_version() const
   * virtual Math::range_t get_x_range(unsigned int dim = _[...]_)
     const = 0;
   * virtual double get_x_value(unsigned int n, unsigned int dim =
     _[...]_)  const = 0;
   * virtual Math::range_t get_y_range() const
   * virtual double get_y_value(const unsigned int x[]) const = 0;
   * virtual double interpolate(const double x[]) const = 0;
   * virtual double interpolate(const double x[], unsigned int deriv,
     unsigned int dim) const = 0;
   * virtual void set_interpolation(Interpolation i) = 0;

Data::Set1d class reference
===========================

Declaration
-----------

     #include <Goptical/Data/Set1d>

     namespace Goptical {
       namespace Data {
         class Set1d;
       };
     };


   This class is a member of the Data namespace.

   This abstract class contains pure virtuals.

Inheritance
-----------

Description
-----------

Base class for 1d y = f(x) numerical data set

Members
-------

See also the full member list (*note
Data_Set1d_class_full_member_list::) section for this class.

Inherited members
.................

   * 12 members inherited from Set (*note Data_Set_class_reference::)

Functions
.........

   * virtual ~Set1d()
   * virtual unsigned int get_count() const = 0;
   * virtual unsigned int get_count(unsigned int dim) const
   * virtual unsigned int get_dimensions() const
   * virtual Math::range_t get_x_range() const = 0;
   * virtual Math::range_t get_x_range(unsigned int dimension) const
   * virtual double get_x_value(unsigned int n) const = 0;
   * virtual double get_x_value(unsigned int n, unsigned int dim) const
   * virtual double get_y_value(unsigned int n) const = 0;
   * virtual double & get_y_value(unsigned int n) = 0;
   * virtual double get_y_value(const unsigned int x[]) const
   * virtual double interpolate(const double x) const = 0;
   * virtual double interpolate(const double x, unsigned int deriv)
     const = 0;
   * virtual double interpolate(const double x[]) const
   * virtual double interpolate(const double x[], unsigned int deriv,
     unsigned int dimension) const

Members detail
--------------

virtual ~Set1d()
................

No documentation available

virtual unsigned int get_count() const = 0;
...........................................

Get total number of data stored in data set

virtual unsigned int get_count(unsigned int dim) const
......................................................

This virtual function implements the 'get_count (*note _223::)' pure
function declared in the 'Set (*note Data_Set_class_reference::)' base
abstract class.

   Documentation inherited from base class:

   Get total number of data stored for dimension n in data set

virtual unsigned int get_dimensions() const
...........................................

This virtual function implements the 'get_dimensions (*note _224::)'
pure function declared in the 'Set (*note Data_Set_class_reference::)'
base abstract class.

   Documentation inherited from base class:

   Get total number of dimensions

virtual Math::range_t get_x_range() const = 0;
..............................................

Get minimal and maximal x values on found in data set

virtual Math::range_t get_x_range(unsigned int dimension) const
...............................................................

This virtual function implements the 'get_x_range (*note _227::)' pure
function declared in the 'Set (*note Data_Set_class_reference::)' base
abstract class.

   Documentation inherited from base class:

   Get minimal and maximal x values on dimension n found in data set

virtual double get_x_value(unsigned int n) const = 0;
.....................................................

Get x data at index n in data set

virtual double get_x_value(unsigned int n, unsigned int dim) const
..................................................................

This virtual function implements the 'get_x_value (*note _228::)' pure
function declared in the 'Set (*note Data_Set_class_reference::)' base
abstract class.

   Documentation inherited from base class:

   Get data stored at position n on dimension dim in data set

virtual double get_y_value(unsigned int n) const = 0;
.....................................................

Get y data stored at index n in data set

virtual double & get_y_value(unsigned int n) = 0;
.................................................

Get modifiable reference to y data stored at index n in data set

virtual double get_y_value(const unsigned int x[]) const
........................................................

This virtual function implements the 'get_y_value (*note _230::)' pure
function declared in the 'Set (*note Data_Set_class_reference::)' base
abstract class.

   Documentation inherited from base class:

   Get y data stored at position (x0, x1, ...)  in data set

virtual double interpolate(const double x) const = 0;
.....................................................

Interpolate y value corresponding to given x value in data set.

virtual double interpolate(const double x, unsigned int deriv) const = 0;
.........................................................................

Interpolate y value corresponding to given x value in data set.  Data
may be differentiated several times.

   * deriv: Differentiation count, 0 means y value, 1 means 1st
     derivative...

virtual double interpolate(const double x[]) const
..................................................

This virtual function implements the 'interpolate (*note _231::)' pure
function declared in the 'Set (*note Data_Set_class_reference::)' base
abstract class.

   Documentation inherited from base class:

   Interpolate y value corresponding to given x value(s) in data set.

virtual double interpolate(const double x[], unsigned int deriv, unsigned int dimension) const
..............................................................................................

This virtual function implements the 'interpolate (*note _232::)' pure
function declared in the 'Set (*note Data_Set_class_reference::)' base
abstract class.

   Documentation inherited from base class:

   Interpolate y value corresponding to given x value in data set.  Data
may be differentiated several times along the requested dimension.

   * deriv: Differentiation count, 0 means y value, 1 means 1st
     derivative...
   * dim: Differentiation dimension

Data::Set1d class full member list
==================================

Functions
---------

   * virtual ~Set1d()
   * virtual unsigned int get_count() const = 0;
   * virtual unsigned int get_count(unsigned int dim) const
   * virtual unsigned int get_dimensions() const
   * Interpolation get_interpolation()
   * unsigned int get_version() const
   * virtual Math::range_t get_x_range() const = 0;
   * virtual Math::range_t get_x_range(unsigned int dimension) const
   * virtual double get_x_value(unsigned int n) const = 0;
   * virtual double get_x_value(unsigned int n, unsigned int dim) const
   * virtual Math::range_t get_y_range() const
   * virtual double get_y_value(unsigned int n) const = 0;
   * virtual double & get_y_value(unsigned int n) = 0;
   * virtual double get_y_value(const unsigned int x[]) const
   * virtual double interpolate(const double x) const = 0;
   * virtual double interpolate(const double x, unsigned int deriv)
     const = 0;
   * virtual double interpolate(const double x[]) const
   * virtual double interpolate(const double x[], unsigned int deriv,
     unsigned int dimension) const
   * virtual void set_interpolation(Interpolation i) = 0;

Data::DiscreteSetBase internal class members
============================================

DiscreteSetBase()
-----------------

No documentation available

~DiscreteSetBase()
------------------

No documentation available

void add_data(double x, double y, double yp = 0.0)
--------------------------------------------------

Insert data pair in data set.  If a pair with the same x value exists,
it will be replaced by the new value.  Derivative value may be provided
as well.

void clear()
------------

Clear all data

virtual unsigned int get_count() const
--------------------------------------

This virtual function implements the 'get_count (*note _235::)' pure
function declared in the 'Set1d (*note Data_Set1d_class_reference::)'
base abstract class.

   Documentation inherited from base class:

   Get total number of data stored in data set

double get_d_value(unsigned int x) const
----------------------------------------

Get stored derivative value at index x

double & get_d_value(unsigned int x)
------------------------------------

Get modifiable reference to stored derivative value at index x

virtual Math::range_t get_x_range() const
-----------------------------------------

This virtual function implements the 'get_x_range (*note _238::)' pure
function declared in the 'Set1d (*note Data_Set1d_class_reference::)'
base abstract class.

   Documentation inherited from base class:

   Get minimal and maximal x values on found in data set

virtual double get_x_value(unsigned int x) const
------------------------------------------------

This virtual function implements the 'get_x_value (*note _240::)' pure
function declared in the 'Set1d (*note Data_Set1d_class_reference::)'
base abstract class.

   Documentation inherited from base class:

   Get x data at index n in data set

virtual double get_y_value(unsigned int x) const
------------------------------------------------

This virtual function implements the 'get_y_value (*note _242::)' pure
function declared in the 'Set1d (*note Data_Set1d_class_reference::)'
base abstract class.

   Documentation inherited from base class:

   Get y data stored at index n in data set

virtual double & get_y_value(unsigned int x)
--------------------------------------------

This virtual function implements the 'get_y_value (*note _243::)' pure
function declared in the 'Set1d (*note Data_Set1d_class_reference::)'
base abstract class.

   Documentation inherited from base class:

   Get modifiable reference to y data stored at index n in data set

void reserve( size_t n)
-----------------------

Reserve data entries

Data::Interpolate1d internal class members
==========================================

Interpolate1d()
---------------

No documentation available

~Interpolate1d()
----------------

No documentation available

double interpolate(const double x) const
----------------------------------------

No documentation available

double interpolate(const double x, unsigned int deriv) const
------------------------------------------------------------

No documentation available

void set_interpolation(Interpolation i)
---------------------------------------

No documentation available

Data::SampleSetBase internal class members
==========================================

SampleSetBase()
---------------

No documentation available

~SampleSetBase()
----------------

No documentation available

void clear()
------------

Clear all data

virtual unsigned int get_count() const
--------------------------------------

This virtual function implements the 'get_count (*note _235::)' pure
function declared in the 'Set1d (*note Data_Set1d_class_reference::)'
base abstract class.

   Documentation inherited from base class:

   Get total number of data stored in data set

double get_d_value(unsigned int x) const
----------------------------------------

Get stored derivative value at index x

double & get_d_value(unsigned int x)
------------------------------------

Get modifiable reference to stored derivative value at index x

double get_origin() const
-------------------------

Get x value of first sample

double get_step() const
-----------------------

Get step size between consecutive x values

virtual Math::range_t get_x_range() const
-----------------------------------------

This virtual function implements the 'get_x_range (*note _238::)' pure
function declared in the 'Set1d (*note Data_Set1d_class_reference::)'
base abstract class.

   Documentation inherited from base class:

   Get minimal and maximal x values on found in data set

virtual double get_x_value(unsigned int x) const
------------------------------------------------

This virtual function implements the 'get_x_value (*note _240::)' pure
function declared in the 'Set1d (*note Data_Set1d_class_reference::)'
base abstract class.

   Documentation inherited from base class:

   Get x data at index n in data set

virtual double get_y_value(unsigned int x) const
------------------------------------------------

This virtual function implements the 'get_y_value (*note _242::)' pure
function declared in the 'Set1d (*note Data_Set1d_class_reference::)'
base abstract class.

   Documentation inherited from base class:

   Get y data stored at index n in data set

virtual double & get_y_value(unsigned int x)
--------------------------------------------

This virtual function implements the 'get_y_value (*note _243::)' pure
function declared in the 'Set1d (*note Data_Set1d_class_reference::)'
base abstract class.

   Documentation inherited from base class:

   Get modifiable reference to y data stored at index n in data set

void resize(unsigned int n)
---------------------------

Set number of samples

void set_metrics(double origin, double step)
--------------------------------------------

Set x origin and step values

void set_value(unsigned int x, double y, double d = 0.0)
--------------------------------------------------------

Set y value and its derivative at index x

void set_value_near(double x, double y, double d = 0.0)
-------------------------------------------------------

Set y value and its derivative at nearest x value

Design namespace reference
==========================

Description
-----------

Design module classes

Members
-------

Namespace
.........

   * Telescope

Design::Telescope namespace reference
=====================================

Description
-----------

Telescope designs

Members
-------

Types
.....

   * template class Cassegrain
   * enum CassegrainType
   * class Newton
   * class Telescope

Members detail
--------------

enum CassegrainType
...................

Specify Cassegrain telescope type

Identifier             Description
--------------------------------------------------------------------------
ClassicalCassegrain
RitcheyChretien
DallKirkham
PressmannCamichel

Design::Telescope::Cassegrain class reference
=============================================

Declaration
-----------

     #include <Goptical/Design/Telescope/Cassegrain>

     namespace Goptical {
       namespace Design {
         namespace Telescope {
           template <CassegrainType type> class Cassegrain;
         };
       };
     };


   This class is a member of the Telescope namespace.

Inheritance
-----------

Description
-----------

This class is a group of optical elements forming a Cassegrain
telescope.  Optical elements are adjusted as needed from prescribed
telescope parameters.

   The CassegrainType (*note _282::) enum specifies type of Cassegrain
telescope.

Members
-------

See also the full member list (*note
Design_Telescope_Cassegrain_class_full_member_list::) section for this
class.

Inherited members
.................

   * 60 members inherited from Telescope (*note
     Design_Telescope_Telescope_class_reference::)

Functions
.........

   * Cassegrain(const Math::VectorPair3 &p, double focal, double
     diameter, double magnification = _[...]_, double bwd = _[...]_,
     double field_angle = _[...]_)
   * virtual double get_bwd() const
   * virtual double get_diameter() const
   * virtual double get_field_angle() const
   * virtual double get_focal() const
   * virtual Math::VectorPair3 get_focal_plane() const
   * double get_magnification() const
   * double get_mirrors_separation() const
   * const Sys::Mirror & get_primary() const
   * Sys::Mirror & get_primary()
   * double get_primary_conic() const
   * const Sys::Mirror & get_secondary() const
   * Sys::Mirror & get_secondary()
   * double get_secondary_conic() const
   * double get_secondary_diameter() const
   * virtual double get_unvignetted_image_diameter() const
   * virtual void set_bwd(double e)
   * virtual void set_diameter(double d1)
   * virtual void set_field_angle(double fa)
   * virtual void set_focal(double f)
   * void set_magnification(double m)
   * void set_secondary_diameter(double d2)

Members detail
--------------

Cassegrain(const Math::VectorPair3 &p, double focal, double diameter, double magnification = 3., double bwd = 100, double field_angle = 1.)
...........................................................................................................................................

No documentation available

virtual double get_bwd() const
..............................

This virtual function implements the 'get_bwd (*note _325::)' pure
function declared in the 'Telescope (*note
Design_Telescope_Telescope_class_reference::)' base abstract class.

   Documentation inherited from base class:

   Get telescope back working distance

virtual double get_diameter() const
...................................

This virtual function implements the 'get_diameter (*note _326::)' pure
function declared in the 'Telescope (*note
Design_Telescope_Telescope_class_reference::)' base abstract class.

   Documentation inherited from base class:

   Get telescope primary mirror diameter

virtual double get_field_angle() const
......................................

This virtual function implements the 'get_field_angle (*note _327::)'
pure function declared in the 'Telescope (*note
Design_Telescope_Telescope_class_reference::)' base abstract class.

   Documentation inherited from base class:

   Get telescope field angle

virtual double get_focal() const
................................

This virtual function implements the 'get_focal (*note _328::)' pure
function declared in the 'Telescope (*note
Design_Telescope_Telescope_class_reference::)' base abstract class.

   Documentation inherited from base class:

   Get telescope focal length

virtual Math::VectorPair3 get_focal_plane() const
.................................................

This virtual function implements the 'get_focal_plane (*note _329::)'
pure function declared in the 'Telescope (*note
Design_Telescope_Telescope_class_reference::)' base abstract class.

   Documentation inherited from base class:

   Get telescope focal plane in parent coordinate system

double get_magnification() const
................................

Get telescope secondary mirror magnification

double get_mirrors_separation() const
.....................................

Get distance between mirrors

const Sys::Mirror & get_primary() const
.......................................

Get telescope primary mirror component

Sys::Mirror & get_primary()
...........................

Get telescope primary mirror component

double get_primary_conic() const
................................

Get primary mirror schwarzschild constant

const Sys::Mirror & get_secondary() const
.........................................

Get telescope secondary mirror component

Sys::Mirror & get_secondary()
.............................

Get telescope secondary mirror component

double get_secondary_conic() const
..................................

Get secondary mirror schwarzschild constant

double get_secondary_diameter() const
.....................................

Get telescope secondary mirror diameter

virtual double get_unvignetted_image_diameter() const
.....................................................

This virtual function implements the 'get_unvignetted_image_diameter
(*note _330::)' pure function declared in the 'Telescope (*note
Design_Telescope_Telescope_class_reference::)' base abstract class.

   Documentation inherited from base class:

   Get diameter of unvignetted image on focal plane

virtual void set_bwd(double e)
..............................

This virtual function implements the 'set_bwd (*note _331::)' pure
function declared in the 'Telescope (*note
Design_Telescope_Telescope_class_reference::)' base abstract class.

   Documentation inherited from base class:

   Set telescope back working distance

virtual void set_diameter(double d1)
....................................

This virtual function implements the 'set_diameter (*note _332::)' pure
function declared in the 'Telescope (*note
Design_Telescope_Telescope_class_reference::)' base abstract class.

   Documentation inherited from base class:

   Set telescope primary mirror diameter

virtual void set_field_angle(double fa)
.......................................

This virtual function implements the 'set_field_angle (*note _333::)'
pure function declared in the 'Telescope (*note
Design_Telescope_Telescope_class_reference::)' base abstract class.

   Documentation inherited from base class:

   Set telescope field angle

virtual void set_focal(double f)
................................

This virtual function implements the 'set_focal (*note _334::)' pure
function declared in the 'Telescope (*note
Design_Telescope_Telescope_class_reference::)' base abstract class.

   Documentation inherited from base class:

   Set telescope focal length

void set_magnification(double m)
................................

Set telescope secondary mirror magnification

void set_secondary_diameter(double d2)
......................................

Set telescope secondary mirror diameter

Design::Telescope::Cassegrain class full member list
====================================================

Types
-----

   * typedef _ [...]  _ element_list_t
   * typedef _ [...]  _ mod_delegate_t
   * typedef _ [...]  _ put_delegate_t

Functions
---------

   * Cassegrain(const Math::VectorPair3 &p, double focal, double
     diameter, double magnification = _[...]_, double bwd = _[...]_,
     double field_angle = _[...]_)
   * void add(const ref<Sys::Element> &e)
   * template bool contains(const X *x) const
   * void draw_2d(Io::Renderer &r) const
   * void draw_2d_fit(Io::RendererViewport &r, bool keep_aspect =
     _[...]_)  const
   * void draw_3d(Io::Renderer &r) const
   * void draw_3d_fit(Io::RendererViewport &r, double z_offset =
     _[...]_)  const
   * template void enable_single(const X &e)
   * template X * find() const
   * virtual Math::VectorPair3 get_bounding_box() const
   * virtual double get_bwd() const
   * virtual double get_diameter() const
   * Math::Vector3 get_direction(const Sys::Element &e) const
   * Math::Vector3 get_direction() const
   * const Sys::Container::element_list_t & get_element_list() const
   * template void get_elements(const delegate<void(const X&)> &d) const
   * template void get_elements(const delegate<void(X&)> &d)
   * virtual double get_field_angle() const
   * virtual double get_focal() const
   * virtual Math::VectorPair3 get_focal_plane() const
   * const Math::Transform<3> & get_global_transform() const
   * Math::Vector3 get_local_direction() const
   * Math::VectorPair3 get_local_plane() const
   * const Math::Vector3 & get_local_position() const
   * const Math::Transform<3> & get_local_transform() const
   * double get_magnification() const
   * double get_mirrors_separation() const
   * Sys::Group * get_parent() const
   * Math::VectorPair3 get_plane() const
   * Math::VectorPair3 get_plane(const Sys::Element &e) const
   * Math::Vector3 get_position(const Sys::Element &e) const
   * Math::Vector3 get_position() const
   * const Sys::Mirror & get_primary() const
   * Sys::Mirror & get_primary()
   * double get_primary_conic() const
   * const Sys::Mirror & get_secondary() const
   * Sys::Mirror & get_secondary()
   * double get_secondary_conic() const
   * double get_secondary_diameter() const
   * Sys::System * get_system() const
   * const Math::Transform<3> & get_transform() const
   * const Math::Transform<3> & get_transform_from(const Sys::Element
     &e) const
   * const Math::Transform<3> & get_transform_from(const Sys::Element
     *e) const
   * const Math::Transform<3> & get_transform_to(const Sys::Element &e)
     const
   * const Math::Transform<3> & get_transform_to(const Sys::Element *e)
     const
   * virtual double get_unvignetted_image_diameter() const
   * unsigned int get_version() const
   * unsigned int id() const
   * bool is_enabled() const
   * virtual void print(std::ostream &o) const
   * template void process_rays(Trace::Result &result,
     Trace::rays_queue_t *input) const
   * void remove(Sys::Element &e)
   * void rotate(double x, double y, double z)
   * virtual void set_bwd(double e)
   * virtual void set_diameter(double d1)
   * void set_direction(const Math::Vector3 &v)
   * void set_enable_state(bool enabled)
   * virtual void set_field_angle(double fa)
   * virtual void set_focal(double f)
   * void set_local_direction(const Math::Vector3 &v)
   * void set_local_plane(const Math::VectorPair3 &p)
   * void set_local_position(const Math::Vector3 &v)
   * void set_magnification(double m)
   * void set_plane(const Math::VectorPair3 &p)
   * void set_position(const Math::Vector3 &v)
   * void set_secondary_diameter(double d2)
   * void set_transform(const Math::Transform<3> &t)
   * void update_version()

Design::Telescope::Newton class reference
=========================================

Declaration
-----------

     #include <Goptical/Design/Telescope/Newton>

     namespace Goptical {
       namespace Design {
         namespace Telescope {
           class Newton;
         };
       };
     };


   This class is a member of the Telescope namespace.

Inheritance
-----------

Description
-----------

This class is a group of optical elements forming a Newton telescope.
Optical elements are adjusted as needed from prescribed telescope
parameters.

   See also A newton telescope with corrector (*note A newton telescope
with corrector::) section.

Members
-------

See also the full member list (*note
Design_Telescope_Newton_class_full_member_list::) section for this
class.

Inherited members
.................

   * 60 members inherited from Telescope (*note
     Design_Telescope_Telescope_class_reference::)

Functions
.........

   * Newton(const Math::VectorPair3 &p, double focal, double diameter,
     double bwd = _[...]_, double field_angle = _[...]_)
   * virtual double get_bwd() const
   * virtual double get_diameter() const
   * virtual double get_field_angle() const
   * virtual double get_focal() const
   * virtual Math::VectorPair3 get_focal_plane() const
   * Sys::Mirror & get_primary()
   * const Sys::Mirror & get_primary() const
   * Sys::Mirror & get_secondary()
   * const Sys::Mirror & get_secondary() const
   * double get_secondary_major_axis() const
   * double get_secondary_minor_axis() const
   * double get_secondary_offset() const
   * virtual double get_unvignetted_image_diameter() const
   * virtual void set_bwd(double bwd)
   * virtual void set_diameter(double diameter)
   * virtual void set_field_angle(double fa)
   * virtual void set_focal(double focal)
   * void set_secondary_minor_axis(double diameter)

Members detail
--------------

Newton(const Math::VectorPair3 &p, double focal, double diameter, double bwd = 100, double field_angle = 1.)
............................................................................................................

No documentation available

virtual double get_bwd() const
..............................

This virtual function implements the 'get_bwd (*note _325::)' pure
function declared in the 'Telescope (*note
Design_Telescope_Telescope_class_reference::)' base abstract class.

   Documentation inherited from base class:

   Get telescope back working distance

virtual double get_diameter() const
...................................

This virtual function implements the 'get_diameter (*note _326::)' pure
function declared in the 'Telescope (*note
Design_Telescope_Telescope_class_reference::)' base abstract class.

   Documentation inherited from base class:

   Get telescope primary mirror diameter

virtual double get_field_angle() const
......................................

This virtual function implements the 'get_field_angle (*note _327::)'
pure function declared in the 'Telescope (*note
Design_Telescope_Telescope_class_reference::)' base abstract class.

   Documentation inherited from base class:

   Get telescope field angle

virtual double get_focal() const
................................

This virtual function implements the 'get_focal (*note _328::)' pure
function declared in the 'Telescope (*note
Design_Telescope_Telescope_class_reference::)' base abstract class.

   Documentation inherited from base class:

   Get telescope focal length

virtual Math::VectorPair3 get_focal_plane() const
.................................................

This virtual function implements the 'get_focal_plane (*note _329::)'
pure function declared in the 'Telescope (*note
Design_Telescope_Telescope_class_reference::)' base abstract class.

   Documentation inherited from base class:

   Get telescope focal plane in parent coordinate system

Sys::Mirror & get_primary()
...........................

Get telescope primary mirror component

const Sys::Mirror & get_primary() const
.......................................

Get telescope primary mirror component

Sys::Mirror & get_secondary()
.............................

Get telescope secondary mirror component

const Sys::Mirror & get_secondary() const
.........................................

Get telescope secondary mirror component

double get_secondary_major_axis() const
.......................................

Get secondary mirror major axis length

double get_secondary_minor_axis() const
.......................................

Get secondary mirror minor axis length

double get_secondary_offset() const
...................................

Get secondary mirror offset

virtual double get_unvignetted_image_diameter() const
.....................................................

This virtual function implements the 'get_unvignetted_image_diameter
(*note _330::)' pure function declared in the 'Telescope (*note
Design_Telescope_Telescope_class_reference::)' base abstract class.

   Documentation inherited from base class:

   Get diameter of unvignetted image on focal plane

virtual void set_bwd(double bwd)
................................

This virtual function implements the 'set_bwd (*note _331::)' pure
function declared in the 'Telescope (*note
Design_Telescope_Telescope_class_reference::)' base abstract class.

   Documentation inherited from base class:

   Set telescope back working distance

virtual void set_diameter(double diameter)
..........................................

This virtual function implements the 'set_diameter (*note _332::)' pure
function declared in the 'Telescope (*note
Design_Telescope_Telescope_class_reference::)' base abstract class.

   Documentation inherited from base class:

   Set telescope primary mirror diameter

virtual void set_field_angle(double fa)
.......................................

This virtual function implements the 'set_field_angle (*note _333::)'
pure function declared in the 'Telescope (*note
Design_Telescope_Telescope_class_reference::)' base abstract class.

   Documentation inherited from base class:

   Set telescope field angle

virtual void set_focal(double focal)
....................................

This virtual function implements the 'set_focal (*note _334::)' pure
function declared in the 'Telescope (*note
Design_Telescope_Telescope_class_reference::)' base abstract class.

   Documentation inherited from base class:

   Set telescope focal length

void set_secondary_minor_axis(double diameter)
..............................................

Set telescope secondary mirror diameter

Design::Telescope::Newton class full member list
================================================

Types
-----

   * typedef _ [...]  _ element_list_t
   * typedef _ [...]  _ mod_delegate_t
   * typedef _ [...]  _ put_delegate_t

Functions
---------

   * Newton(const Math::VectorPair3 &p, double focal, double diameter,
     double bwd = _[...]_, double field_angle = _[...]_)
   * void add(const ref<Sys::Element> &e)
   * template bool contains(const X *x) const
   * void draw_2d(Io::Renderer &r) const
   * void draw_2d_fit(Io::RendererViewport &r, bool keep_aspect =
     _[...]_)  const
   * void draw_3d(Io::Renderer &r) const
   * void draw_3d_fit(Io::RendererViewport &r, double z_offset =
     _[...]_)  const
   * template void enable_single(const X &e)
   * template X * find() const
   * virtual Math::VectorPair3 get_bounding_box() const
   * virtual double get_bwd() const
   * virtual double get_diameter() const
   * Math::Vector3 get_direction(const Sys::Element &e) const
   * Math::Vector3 get_direction() const
   * const Sys::Container::element_list_t & get_element_list() const
   * template void get_elements(const delegate<void(const X&)> &d) const
   * template void get_elements(const delegate<void(X&)> &d)
   * virtual double get_field_angle() const
   * virtual double get_focal() const
   * virtual Math::VectorPair3 get_focal_plane() const
   * const Math::Transform<3> & get_global_transform() const
   * Math::Vector3 get_local_direction() const
   * Math::VectorPair3 get_local_plane() const
   * const Math::Vector3 & get_local_position() const
   * const Math::Transform<3> & get_local_transform() const
   * Sys::Group * get_parent() const
   * Math::VectorPair3 get_plane() const
   * Math::VectorPair3 get_plane(const Sys::Element &e) const
   * Math::Vector3 get_position(const Sys::Element &e) const
   * Math::Vector3 get_position() const
   * Sys::Mirror & get_primary()
   * const Sys::Mirror & get_primary() const
   * Sys::Mirror & get_secondary()
   * const Sys::Mirror & get_secondary() const
   * double get_secondary_major_axis() const
   * double get_secondary_minor_axis() const
   * double get_secondary_offset() const
   * Sys::System * get_system() const
   * const Math::Transform<3> & get_transform() const
   * const Math::Transform<3> & get_transform_from(const Sys::Element
     &e) const
   * const Math::Transform<3> & get_transform_from(const Sys::Element
     *e) const
   * const Math::Transform<3> & get_transform_to(const Sys::Element &e)
     const
   * const Math::Transform<3> & get_transform_to(const Sys::Element *e)
     const
   * virtual double get_unvignetted_image_diameter() const
   * unsigned int get_version() const
   * unsigned int id() const
   * bool is_enabled() const
   * virtual void print(std::ostream &o) const
   * template void process_rays(Trace::Result &result,
     Trace::rays_queue_t *input) const
   * void remove(Sys::Element &e)
   * void rotate(double x, double y, double z)
   * virtual void set_bwd(double bwd)
   * virtual void set_diameter(double diameter)
   * void set_direction(const Math::Vector3 &v)
   * void set_enable_state(bool enabled)
   * virtual void set_field_angle(double fa)
   * virtual void set_focal(double focal)
   * void set_local_direction(const Math::Vector3 &v)
   * void set_local_plane(const Math::VectorPair3 &p)
   * void set_local_position(const Math::Vector3 &v)
   * void set_plane(const Math::VectorPair3 &p)
   * void set_position(const Math::Vector3 &v)
   * void set_secondary_minor_axis(double diameter)
   * void set_transform(const Math::Transform<3> &t)
   * void update_version()

Design::Telescope::Telescope class reference
============================================

Declaration
-----------

     #include <Goptical/Design/Telescope/Telescope>

     namespace Goptical {
       namespace Design {
         namespace Telescope {
           class Telescope;
         };
       };
     };


   This class is a member of the Telescope namespace.

   This abstract class contains pure virtuals.

Inheritance
-----------

Description
-----------

Base class for telescope optical designs

Members
-------

See also the full member list (*note
Design_Telescope_Telescope_class_full_member_list::) section for this
class.

Inherited members
.................

   * 51 members inherited from Sys::Group (*note
     Sys_Group_class_reference::)

Functions
.........

   * Telescope(const Math::VectorPair3 &p)
   * virtual double get_bwd() const = 0;
   * virtual double get_diameter() const = 0;
   * virtual double get_field_angle() const = 0;
   * virtual double get_focal() const = 0;
   * virtual Math::VectorPair3 get_focal_plane() const = 0;
   * virtual double get_unvignetted_image_diameter() const = 0;
   * virtual void set_bwd(double bwd) = 0;
   * virtual void set_diameter(double diameter) = 0;
   * virtual void set_field_angle(double bwd) = 0;
   * virtual void set_focal(double focal) = 0;

Members detail
--------------

Telescope(const Math::VectorPair3 &p)
.....................................

No documentation available

virtual double get_bwd() const = 0;
...................................

Get telescope back working distance

virtual double get_diameter() const = 0;
........................................

Get telescope primary mirror diameter

virtual double get_field_angle() const = 0;
...........................................

Get telescope field angle

virtual double get_focal() const = 0;
.....................................

Get telescope focal length

virtual Math::VectorPair3 get_focal_plane() const = 0;
......................................................

Get telescope focal plane in parent coordinate system

virtual double get_unvignetted_image_diameter() const = 0;
..........................................................

Get diameter of unvignetted image on focal plane

virtual void set_bwd(double bwd) = 0;
.....................................

Set telescope back working distance

virtual void set_diameter(double diameter) = 0;
...............................................

Set telescope primary mirror diameter

virtual void set_field_angle(double bwd) = 0;
.............................................

Set telescope field angle

virtual void set_focal(double focal) = 0;
.........................................

Set telescope focal length

Design::Telescope::Telescope class full member list
===================================================

Types
-----

   * typedef _ [...]  _ element_list_t
   * typedef _ [...]  _ mod_delegate_t
   * typedef _ [...]  _ put_delegate_t

Functions
---------

   * Telescope(const Math::VectorPair3 &p)
   * void add(const ref<Sys::Element> &e)
   * template bool contains(const X *x) const
   * void draw_2d(Io::Renderer &r) const
   * void draw_2d_fit(Io::RendererViewport &r, bool keep_aspect =
     _[...]_)  const
   * void draw_3d(Io::Renderer &r) const
   * void draw_3d_fit(Io::RendererViewport &r, double z_offset =
     _[...]_)  const
   * template void enable_single(const X &e)
   * template X * find() const
   * virtual Math::VectorPair3 get_bounding_box() const
   * virtual double get_bwd() const = 0;
   * virtual double get_diameter() const = 0;
   * Math::Vector3 get_direction(const Sys::Element &e) const
   * Math::Vector3 get_direction() const
   * const Sys::Container::element_list_t & get_element_list() const
   * template void get_elements(const delegate<void(const X&)> &d) const
   * template void get_elements(const delegate<void(X&)> &d)
   * virtual double get_field_angle() const = 0;
   * virtual double get_focal() const = 0;
   * virtual Math::VectorPair3 get_focal_plane() const = 0;
   * const Math::Transform<3> & get_global_transform() const
   * Math::Vector3 get_local_direction() const
   * Math::VectorPair3 get_local_plane() const
   * const Math::Vector3 & get_local_position() const
   * const Math::Transform<3> & get_local_transform() const
   * Sys::Group * get_parent() const
   * Math::VectorPair3 get_plane() const
   * Math::VectorPair3 get_plane(const Sys::Element &e) const
   * Math::Vector3 get_position(const Sys::Element &e) const
   * Math::Vector3 get_position() const
   * Sys::System * get_system() const
   * const Math::Transform<3> & get_transform() const
   * const Math::Transform<3> & get_transform_from(const Sys::Element
     &e) const
   * const Math::Transform<3> & get_transform_from(const Sys::Element
     *e) const
   * const Math::Transform<3> & get_transform_to(const Sys::Element &e)
     const
   * const Math::Transform<3> & get_transform_to(const Sys::Element *e)
     const
   * virtual double get_unvignetted_image_diameter() const = 0;
   * unsigned int get_version() const
   * unsigned int id() const
   * bool is_enabled() const
   * virtual void print(std::ostream &o) const
   * template void process_rays(Trace::Result &result,
     Trace::rays_queue_t *input) const
   * void remove(Sys::Element &e)
   * void rotate(double x, double y, double z)
   * virtual void set_bwd(double bwd) = 0;
   * virtual void set_diameter(double diameter) = 0;
   * void set_direction(const Math::Vector3 &v)
   * void set_enable_state(bool enabled)
   * virtual void set_field_angle(double bwd) = 0;
   * virtual void set_focal(double focal) = 0;
   * void set_local_direction(const Math::Vector3 &v)
   * void set_local_plane(const Math::VectorPair3 &p)
   * void set_local_position(const Math::Vector3 &v)
   * void set_plane(const Math::VectorPair3 &p)
   * void set_position(const Math::Vector3 &v)
   * void set_transform(const Math::Transform<3> &t)
   * void update_version()

Error class reference
=====================

Declaration
-----------

     #include <Goptical/Error>

     namespace Goptical {
       class Error;
     };


   This class is a member of the Goptical namespace.

Inheritance
-----------

Description
-----------

Base class used for Goptical exceptions.

Members
-------

See also the full member list (*note Error_class_full_member_list::)
section for this class.

Function
........

   * Error(const std::string &msg = _[...]_)

Members detail
--------------

Error(const std:: string &msg = "")
...................................

No documentation available

Error class full member list
============================

Function
--------

   * Error(const std::string &msg = _[...]_)

Io namespace reference
======================

Description
-----------

Data input/output and graphical rendering

Members
-------

Types
.....

   * class ImportOslo
   * class ImportZemax
   * class Renderer
   * class RendererDxf
   * class RendererGd
   * class RendererOpengl
   * class RendererPlplot
   * class RendererSvg
   * class RendererX11
   * class RendererX3d
   * class Export
   * class Import
   * enum IntensityMode
   * enum PointStyle
   * enum RayColorMode
   * class RendererAxes
   * class RendererViewport
   * struct Rgb
   * enum Style
   * enum TextAlignMask

Functions
.........

   * TextAlignMask operator&(TextAlignMask a, TextAlignMask b)
   * TextAlignMask operator|(TextAlignMask a, TextAlignMask b)
   * TextAlignMask operator~(TextAlignMask a)

Constants
.........

   * const Rgb rgb_black
   * const Rgb rgb_blue
   * const Rgb rgb_cyan
   * const Rgb rgb_gray
   * const Rgb rgb_green
   * const Rgb rgb_magenta
   * const Rgb rgb_red
   * const Rgb rgb_table[]
   * const size_t rgb_table_size
   * const Rgb rgb_white
   * const Rgb rgb_yellow

Members detail
--------------

enum IntensityMode
..................

Specifies light ray intensity rendering mode

Identifier             Description
--------------------------------------------------------------------------
IntensityIgnore        Light ray intensity is ignored, no blending is
                       performed while rendering ray
                       
IntensityShade         Light ray intensity is used to blend rendered
                       ray
                       
IntensityLogShade      Light ray intensity logarithm is used to blend
                       rendered ray.  This enable faint rays to remain
                       visible.
                       

enum PointStyle
...............

Identifier             Description
--------------------------------------------------------------------------
PointStyleDot
PointStyleCross
PointStyleRound
PointStyleSquare
PointStyleTriangle

enum RayColorMode
.................

Specifies light ray color rendering

Identifier             Description
--------------------------------------------------------------------------
RayColorWavelen        Compute ray color from its wavelength
                       
RayColorFixed          Use fixed ray color
                       

enum Style
..........

Specifies rendering elements which can have modified colors and style

Identifier             Description
--------------------------------------------------------------------------
StyleBackground
StyleForeground
StyleRay
StyleSurface
StyleGlass
StyleLast

enum TextAlignMask
..................

Specifies rendered text alignment

Identifier             Description
--------------------------------------------------------------------------
TextAlignCenter        Vertically centered
                       
TextAlignLeft
TextAlignRight
TextAlignTop
TextAlignBottom
TextAlignMiddle        Horizontally centered
                       

TextAlignMask operator&(TextAlignMask a, TextAlignMask b)
.........................................................

Bitwise and operation for use on TextAlignMask (*note _340::) enum.

TextAlignMask operator|(TextAlignMask a, TextAlignMask b)
.........................................................

Bitwise or operation for use on TextAlignMask (*note _340::) enum.

TextAlignMask operator~(TextAlignMask a)
........................................

Bitwise not operation for use on TextAlignMask (*note _340::) enum.

const Rgb rgb_black
...................

No documentation available

const Rgb rgb_blue
..................

No documentation available

const Rgb rgb_cyan
..................

No documentation available

const Rgb rgb_gray
..................

No documentation available

const Rgb rgb_green
...................

No documentation available

const Rgb rgb_magenta
.....................

No documentation available

const Rgb rgb_red
.................

No documentation available

const Rgb rgb_table[]
.....................

This table contains some common colors.

   See also rgb_table_size (*note _352::) variable.

const size_t rgb_table_size = 9
...............................

This constant specifies the number of entries in rgb_table (*note
_351::).

const Rgb rgb_white
...................

No documentation available

const Rgb rgb_yellow
....................

No documentation available

Io::ImportOslo class reference
==============================

Declaration
-----------

     #include <Goptical/Io/ImportOslo>

     namespace Goptical {
       namespace Io {
         class ImportOslo;
       };
     };


   This class is a member of the Io namespace.

Description
-----------

This class implements an Oslo glass catalog loader.

Members
-------

See also the full member list (*note
Io_ImportOslo_class_full_member_list::) section for this class.

Static function
...............

   * static Material::Catalog & import_catalog(const std::string
     &filename)

Members detail
--------------

static Material::Catalog & import_catalog(const std:: string &filename)
.......................................................................

import Oslo glass catalog file (.glc)

Io::ImportOslo class full member list
=====================================

Static function
---------------

   * static Material::Catalog & import_catalog(const std::string
     &filename)

Io::ImportZemax class reference
===============================

Declaration
-----------

This class is flagged as experimental.

     #include <Goptical/Io/ImportZemax>

     namespace Goptical {
       namespace Io {
         class ImportZemax;
       };
     };


   This class is a member of the Io namespace.

Description
-----------

This class implements a zemax optical design file and glass catalog
loader.

Members
-------

See also the full member list (*note
Io_ImportZemax_class_full_member_list::) section for this class.

Functions
.........

   * ref<Material::Catalog> get_catalog(const std::string &name)
   * ref<Material::Catalog> import_catalog(const std::string &name)
   * ref<Material::Catalog> import_catalog(const std::string &path,
     const std::string &name)
   * ref<Material::Catalog> import_catalog_file(const std::string &path)
   * ref<Sys::System> import_design(const std::string &filename)
   * ref<Material::Dielectric> import_table_glass(const std::string
     &filename)
   * void set_catalog_path(const std::string &path)

Members detail
--------------

ref <Material::Catalog> get_catalog(const std:: string &name)
.............................................................

This function is flagged as experimental.

   Get already imported catalog

ref <Material::Catalog> import_catalog(const std:: string &name)
................................................................

This function is flagged as experimental.

   Import Zemax ascii glass catalog, guess filename from default path
and name

ref <Material::Catalog> import_catalog(const std:: string &path, const std:: string &name)
..........................................................................................

This function is flagged as experimental.

   Import Zemax ascii glass catalog file ('.agf)'

ref <Material::Catalog> import_catalog_file(const std:: string &path)
.....................................................................

This function is flagged as experimental.

   Import Zemax ascii glass catalog file ('.agf).' Guess catalog name
from file name

ref <Sys::System> import_design(const std:: string &filename)
.............................................................

This function is flagged as experimental.

ref <Material::Dielectric> import_table_glass(const std:: string &filename)
...........................................................................

This function is flagged as experimental.

   Import Zemax table glass material file ('.ztg)'

void set_catalog_path(const std:: string &path)
...............................................

This function is flagged as experimental.

   Set glass catalogs default path

Io::ImportZemax class full member list
======================================

Functions
---------

   * ref<Material::Catalog> get_catalog(const std::string &name)
   * ref<Material::Catalog> import_catalog(const std::string &name)
   * ref<Material::Catalog> import_catalog(const std::string &path,
     const std::string &name)
   * ref<Material::Catalog> import_catalog_file(const std::string &path)
   * ref<Sys::System> import_design(const std::string &filename)
   * ref<Material::Dielectric> import_table_glass(const std::string
     &filename)
   * void set_catalog_path(const std::string &path)

Io::Renderer class reference
============================

Declaration
-----------

     #include <Goptical/Io/Renderer>

     namespace Goptical {
       namespace Io {
         class Renderer;
       };
     };


   This class is a member of the Io namespace.

   This abstract class contains pure virtuals.

Inheritance
-----------

Description
-----------

This class define the interface for graphical rendering drivers and
provide a default implementation for some functions.

Members
-------

See also the full member list (*note
Io_Renderer_class_full_member_list::) section for this class.

Functions
.........

   * Renderer()
   * virtual ~Renderer()
   * double get_feature_size() const
   * const Rgb & get_style_color(Style s) const
   * const Rgb & rgb_background() const
   * const Rgb & rgb_foreground() const
   * void set_feature_size(double feature_size)
   * void set_ray_color_mode(RayColorMode m)
   * void set_ray_intensity_mode(IntensityMode m)
   * void set_style_color(Style s, const Rgb &rgb)

Members detail
--------------

Renderer()
..........

No documentation available

virtual ~Renderer()
...................

No documentation available

double get_feature_size() const
...............................

Get size of lines and triangles used to render curved shapes..

   See also set_feature_size (*note _369::) function.

const Rgb & get_style_color(Style s) const
..........................................

Get rgb color from style specifier

const Rgb & rgb_background() const
..................................

Get foreground rgb color

const Rgb & rgb_foreground() const
..................................

Get foreground rgb color

void set_feature_size(double feature_size)
..........................................

Set size of lines and triangles used to render curved shapes..

   See also get_feature_size (*note _365::) function.

void set_ray_color_mode(RayColorMode m)
.......................................

Set color mode for light ray drawing.  Default is RayColorWavelen (*note
_338::).

void set_ray_intensity_mode(IntensityMode m)
............................................

Set light ray intensity display mode

void set_style_color(Style s, const Rgb &rgb)
.............................................

Set rgb color for given style specifier.

   Some drivers do not support changing background color after
initialization.

Io::Renderer class full member list
===================================

Functions
---------

   * Renderer()
   * virtual ~Renderer()
   * double get_feature_size() const
   * const Rgb & get_style_color(Style s) const
   * const Rgb & rgb_background() const
   * const Rgb & rgb_foreground() const
   * void set_feature_size(double feature_size)
   * void set_ray_color_mode(RayColorMode m)
   * void set_ray_intensity_mode(IntensityMode m)
   * void set_style_color(Style s, const Rgb &rgb)

Io::RendererDxf class reference
===============================

Declaration
-----------

This class is flagged as experimental.

     #include <Goptical/Io/RendererDxf>

     namespace Goptical {
       namespace Io {
         class RendererDxf;
       };
     };


   This class is a member of the Io namespace.

Inheritance
-----------

Description
-----------

This class implements a 2d and 3d Dxf CAD format output driver.  It
requires the Dime library to compile.

Members
-------

See also the full member list (*note
Io_RendererDxf_class_full_member_list::) section for this class.

Inherited members
.................

   * 10 members inherited from Renderer (*note
     Io_Renderer_class_reference::)

Functions
.........

   * RendererDxf()
   * RendererDxf(const char *filename)
   * ~RendererDxf()
   * unsigned int add_layer(std::string name)
   * void use_layer(unsigned int id)
   * void write(const std::string &filename)

Members detail
--------------

RendererDxf()
.............

This constructor is flagged as experimental.

   Create a DXF renderer

RendererDxf(const char *filename)
.................................

This constructor is flagged as experimental.

   Create a DXF renderer, output will be written to given filename when
the renderer is destroyed.

~RendererDxf()
..............

This destructor is flagged as experimental.

unsigned int add_layer(std:: string name)
.........................................

This function is flagged as experimental.

   Add a new layer in dxf file and return its index

void use_layer(unsigned int id)
...............................

This function is flagged as experimental.

   Set current layer

void write(const std:: string &filename)
........................................

This function is flagged as experimental.

   Save output to a DXF file

Io::RendererDxf class full member list
======================================

Functions
---------

   * RendererDxf()
   * RendererDxf(const char *filename)
   * ~RendererDxf()
   * unsigned int add_layer(std::string name)
   * double get_feature_size() const
   * const Rgb & get_style_color(Style s) const
   * const Rgb & rgb_background() const
   * const Rgb & rgb_foreground() const
   * void set_feature_size(double feature_size)
   * void set_ray_color_mode(RayColorMode m)
   * void set_ray_intensity_mode(IntensityMode m)
   * void set_style_color(Style s, const Rgb &rgb)
   * void use_layer(unsigned int id)
   * void write(const std::string &filename)

Io::RendererGd class reference
==============================

Declaration
-----------

     #include <Goptical/Io/RendererGd>

     namespace Goptical {
       namespace Io {
         class RendererGd;
       };
     };


   This class is a member of the Io namespace.

Inheritance
-----------

Description
-----------

This class implements a Gd graphic output driver.  It needs the gd
library to compile.

Members
-------

See also the full member list (*note
Io_RendererGd_class_full_member_list::) section for this class.

Inherited members
.................

   * 31 members inherited from RendererViewport (*note
     Io_RendererViewport_class_reference::)

Functions
.........

   * RendererGd(gdImagePtr im, const Rgb &background = _[...]_,
     gdFontPtr font = _[...]_, const char *TFfontlist = _[...]_)
   * RendererGd(const char *filename, unsigned int width = _[...]_,
     unsigned int height = _[...]_, const Rgb &background = _[...]_,
     const char *TFfontlist = _[...]_)
   * RendererGd(unsigned int width = _[...]_, unsigned int height =
     _[...]_, const Rgb &background = _[...]_, const char *TFfontlist =
     _[...]_)
   * ~RendererGd()
   * virtual void clear()
   * void set_brush_thickness(unsigned int t)
   * void write(const std::string &filename)

Members detail
--------------

RendererGd(gdImagePtr im, const Rgb &background = rgb_white, gdFontPtr font = 0, const char *TFfontlist = 0)
............................................................................................................

Create a new gd renderer using specified gd resources

RendererGd(const char *filename, unsigned int width = 800, unsigned int height = 600, const Rgb &background = rgb_white, const char *TFfontlist = 0)
....................................................................................................................................................

Create a new gd renderer with given resolution, png output will be
written to file on renderer destruction.

RendererGd(unsigned int width = 800, unsigned int height = 600, const Rgb &background = rgb_white, const char *TFfontlist = 0)
..............................................................................................................................

Create a new gd renderer with given resolution

~RendererGd()
.............

No documentation available

virtual void clear()
....................

This virtual function overrides the 'clear' virtual function defined in
the 'RendererViewport (*note Io_RendererViewport_class_reference::)'
base abstract class for internal purposes.

   Clear current image buffer

void set_brush_thickness(unsigned int t)
........................................

No documentation available

void write(const std:: string &filename)
........................................

Write image to file in png format

Io::RendererGd class full member list
=====================================

Functions
---------

   * RendererGd(gdImagePtr im, const Rgb &background = _[...]_,
     gdFontPtr font = _[...]_, const char *TFfontlist = _[...]_)
   * RendererGd(const char *filename, unsigned int width = _[...]_,
     unsigned int height = _[...]_, const Rgb &background = _[...]_,
     const char *TFfontlist = _[...]_)
   * RendererGd(unsigned int width = _[...]_, unsigned int height =
     _[...]_, const Rgb &background = _[...]_, const char *TFfontlist =
     _[...]_)
   * ~RendererGd()
   * virtual void clear()
   * virtual void draw_pages_grid(const Rgb &rgb = _[...]_)
   * double get_feature_size() const
   * double get_fov() const
   * const Rgb & get_style_color(Style s) const
   * const Math::VectorPair2 & get_window() const
   * const Rgb & rgb_background() const
   * const Rgb & rgb_foreground() const
   * void set_brush_thickness(unsigned int t)
   * void set_camera_direction(const Math::Vector3 &dir)
   * void set_camera_position(const Math::Vector3 &pos)
   * void set_feature_size(double feature_size)
   * void set_fov(double fov)
   * void set_margin(double left, double bottom, double right, double
     top)
   * void set_margin(double width, double height)
   * void set_margin_output(double left, double bottom, double right,
     double top)
   * void set_margin_output(double width, double height)
   * void set_margin_ratio(double left, double bottom, double right,
     double top)
   * void set_margin_ratio(double width, double height)
   * void set_numeric_format(std::ios_base::fmtflags format, unsigned
     int precision)
   * virtual void set_page(unsigned int page)
   * virtual void set_page_layout(unsigned int cols, unsigned int rows)
   * void set_ray_color_mode(RayColorMode m)
   * void set_ray_intensity_mode(IntensityMode m)
   * void set_style_color(Style s, const Rgb &rgb)
   * virtual void set_window(const Math::Vector2 &center, const
     Math::Vector2 &size, bool keep_aspect = _[...]_)
   * void set_window(const Math::VectorPair2 &window, bool keep_aspect =
     _[...]_)
   * void set_window(const Math::Vector2 &center, double radius, bool
     keep_aspect = _[...]_)
   * void write(const std::string &filename)

Io::RendererOpengl class reference
==================================

Declaration
-----------

     #include <Goptical/Io/RendererOpengl>

     namespace Goptical {
       namespace Io {
         class RendererOpengl;
       };
     };


   This class is a member of the Io namespace.

Inheritance
-----------

Description
-----------

This class implements an Opengl graphic output driver.  It needs the
opengl library to compile.

Members
-------

See also the full member list (*note
Io_RendererOpengl_class_full_member_list::) section for this class.

Inherited members
.................

   * 31 members inherited from RendererViewport (*note
     Io_RendererViewport_class_reference::)

Functions
.........

   * RendererOpengl(double near, double far, double width = _[...]_,
     double height = _[...]_, const Rgb &background = _[...]_)
   * void set_z_range(double near, double far)

Static functions
................

   * static void apply_transform(const Math::Transform<3> &t)
   * static void get_transform(GLenum name, Math::Transform<3> &t)
   * static void glColor(const Rgb &rgb)
   * static void glNormal(const Math::Vector3 &v)
   * static void glVertex(const Math::Vector2 &v)
   * static void glVertex(const Math::Vector3 &v)

Members detail
--------------

RendererOpengl(double near, double far, double width = 800, double height = 600, const Rgb &background = rgb_black)
...................................................................................................................

No documentation available

static void apply_transform(const Math::Transform<3> &t)
........................................................

No documentation available

static void get_transform(GLenum name, Math::Transform<3> &t)
.............................................................

No documentation available

static void glColor(const Rgb &rgb)
...................................

No documentation available

static void glNormal(const Math::Vector3 &v)
............................................

No documentation available

static void glVertex(const Math::Vector2 &v)
............................................

No documentation available

static void glVertex(const Math::Vector3 &v)
............................................

No documentation available

void set_z_range(double near, double far)
.........................................

No documentation available

Io::RendererOpengl class full member list
=========================================

Functions
---------

   * RendererOpengl(double near, double far, double width = _[...]_,
     double height = _[...]_, const Rgb &background = _[...]_)
   * virtual void draw_pages_grid(const Rgb &rgb = _[...]_)
   * double get_feature_size() const
   * double get_fov() const
   * const Rgb & get_style_color(Style s) const
   * const Math::VectorPair2 & get_window() const
   * const Rgb & rgb_background() const
   * const Rgb & rgb_foreground() const
   * void set_camera_direction(const Math::Vector3 &dir)
   * void set_camera_position(const Math::Vector3 &pos)
   * void set_feature_size(double feature_size)
   * void set_fov(double fov)
   * void set_margin(double left, double bottom, double right, double
     top)
   * void set_margin(double width, double height)
   * void set_margin_output(double left, double bottom, double right,
     double top)
   * void set_margin_output(double width, double height)
   * void set_margin_ratio(double left, double bottom, double right,
     double top)
   * void set_margin_ratio(double width, double height)
   * void set_numeric_format(std::ios_base::fmtflags format, unsigned
     int precision)
   * virtual void set_page(unsigned int page)
   * virtual void set_page_layout(unsigned int cols, unsigned int rows)
   * void set_ray_color_mode(RayColorMode m)
   * void set_ray_intensity_mode(IntensityMode m)
   * void set_style_color(Style s, const Rgb &rgb)
   * virtual void set_window(const Math::Vector2 &center, const
     Math::Vector2 &size, bool keep_aspect = _[...]_)
   * void set_window(const Math::VectorPair2 &window, bool keep_aspect =
     _[...]_)
   * void set_window(const Math::Vector2 &center, double radius, bool
     keep_aspect = _[...]_)
   * void set_z_range(double near, double far)

Static functions
----------------

   * static void apply_transform(const Math::Transform<3> &t)
   * static void get_transform(GLenum name, Math::Transform<3> &t)
   * static void glColor(const Rgb &rgb)
   * static void glNormal(const Math::Vector3 &v)
   * static void glVertex(const Math::Vector2 &v)
   * static void glVertex(const Math::Vector3 &v)

Io::RendererPlplot class reference
==================================

Declaration
-----------

     #include <Goptical/Io/RendererPlplot>

     namespace Goptical {
       namespace Io {
         class RendererPlplot;
       };
     };


   This class is a member of the Io namespace.

Inheritance
-----------

Description
-----------

This class implements a Plplot graphic output driver.  It needs the
plplot library to compile.

Members
-------

See also the full member list (*note
Io_RendererPlplot_class_full_member_list::) section for this class.

Inherited members
.................

   * 31 members inherited from RendererViewport (*note
     Io_RendererViewport_class_reference::)

Functions
.........

   * RendererPlplot(plstream *pls)
   * RendererPlplot(const char *device, const char *filename, unsigned
     int width = _[...]_, unsigned int height = _[...]_, const Rgb
     &background = _[...]_)
   * ~RendererPlplot()
   * plstream * get_pls()
   * virtual void set_page(unsigned int page)
   * virtual void set_page_layout(unsigned int cols, unsigned int rows)

Members detail
--------------

RendererPlplot(plstream *pls)
.............................

Initialize renderer from existing plplot context

RendererPlplot(const char *device, const char *filename, unsigned int width = 800, unsigned int height = 600, const Rgb &background = rgb_white)
................................................................................................................................................

Create a plplot renderer with specified output size

~RendererPlplot()
.................

No documentation available

plstream * get_pls()
....................

get plplot context object

virtual void set_page(unsigned int page)
........................................

This virtual function overrides the 'set_page (*note _475::)' virtual
function defined in the 'RendererViewport (*note
Io_RendererViewport_class_reference::)' base abstract class.

   Documentation inherited from base class:

   Select current page when multiple pages layout is in use.

   See also set_page_layout (*note _476::) function.

virtual void set_page_layout(unsigned int cols, unsigned int rows)
..................................................................

This virtual function overrides the 'set_page_layout (*note _476::)'
virtual function defined in the 'RendererViewport (*note
Io_RendererViewport_class_reference::)' base abstract class.

   Documentation inherited from base class:

   This function can be used to setup a pages grid.  Current output page
must be selected with set_page (*note _475::).

Io::RendererPlplot class full member list
=========================================

Functions
---------

   * RendererPlplot(plstream *pls)
   * RendererPlplot(const char *device, const char *filename, unsigned
     int width = _[...]_, unsigned int height = _[...]_, const Rgb
     &background = _[...]_)
   * ~RendererPlplot()
   * virtual void draw_pages_grid(const Rgb &rgb = _[...]_)
   * double get_feature_size() const
   * double get_fov() const
   * plstream * get_pls()
   * const Rgb & get_style_color(Style s) const
   * const Math::VectorPair2 & get_window() const
   * const Rgb & rgb_background() const
   * const Rgb & rgb_foreground() const
   * void set_camera_direction(const Math::Vector3 &dir)
   * void set_camera_position(const Math::Vector3 &pos)
   * void set_feature_size(double feature_size)
   * void set_fov(double fov)
   * void set_margin(double left, double bottom, double right, double
     top)
   * void set_margin(double width, double height)
   * void set_margin_output(double left, double bottom, double right,
     double top)
   * void set_margin_output(double width, double height)
   * void set_margin_ratio(double left, double bottom, double right,
     double top)
   * void set_margin_ratio(double width, double height)
   * void set_numeric_format(std::ios_base::fmtflags format, unsigned
     int precision)
   * virtual void set_page(unsigned int page)
   * virtual void set_page_layout(unsigned int cols, unsigned int rows)
   * void set_ray_color_mode(RayColorMode m)
   * void set_ray_intensity_mode(IntensityMode m)
   * void set_style_color(Style s, const Rgb &rgb)
   * virtual void set_window(const Math::Vector2 &center, const
     Math::Vector2 &size, bool keep_aspect = _[...]_)
   * void set_window(const Math::VectorPair2 &window, bool keep_aspect =
     _[...]_)
   * void set_window(const Math::Vector2 &center, double radius, bool
     keep_aspect = _[...]_)

Io::RendererSvg class reference
===============================

Declaration
-----------

     #include <Goptical/Io/RendererSvg>

     namespace Goptical {
       namespace Io {
         class RendererSvg;
       };
     };


   This class is a member of the Io namespace.

Inheritance
-----------

Description
-----------

This class implements a SVG graphic output driver.

Members
-------

See also the full member list (*note
Io_RendererSvg_class_full_member_list::) section for this class.

Inherited members
.................

   * 31 members inherited from RendererViewport (*note
     Io_RendererViewport_class_reference::)

Functions
.........

   * RendererSvg(double width = _[...]_, double height = _[...]_, const
     Rgb &background = _[...]_)
   * RendererSvg(const char *filename, double width = _[...]_, double
     height = _[...]_, const Rgb &background = _[...]_)
   * ~RendererSvg()
   * void write(std::ostream &s)

Members detail
--------------

RendererSvg(double width = 800, double height = 600, const Rgb &background = rgb_white)
.......................................................................................

Create a new svg renderer with given resolution.  The write (*note
_403::) function must be used to write svg to output stream.

RendererSvg(const char *filename, double width = 800, double height = 600, const Rgb &background = rgb_white)
.............................................................................................................

Create a new svg renderer with given resolution and viewport window.
Svg output will be written to given filename when the renderer object is
destroyed.

~RendererSvg()
..............

No documentation available

void write(std:: ostream &s)
............................

Write svg output to given stream.

Io::RendererSvg class full member list
======================================

Functions
---------

   * RendererSvg(double width = _[...]_, double height = _[...]_, const
     Rgb &background = _[...]_)
   * RendererSvg(const char *filename, double width = _[...]_, double
     height = _[...]_, const Rgb &background = _[...]_)
   * ~RendererSvg()
   * virtual void draw_pages_grid(const Rgb &rgb = _[...]_)
   * double get_feature_size() const
   * double get_fov() const
   * const Rgb & get_style_color(Style s) const
   * const Math::VectorPair2 & get_window() const
   * const Rgb & rgb_background() const
   * const Rgb & rgb_foreground() const
   * virtual void set_2d_size(double width, double height)
   * void set_camera_direction(const Math::Vector3 &dir)
   * void set_camera_position(const Math::Vector3 &pos)
   * void set_feature_size(double feature_size)
   * void set_fov(double fov)
   * void set_margin(double left, double bottom, double right, double
     top)
   * void set_margin(double width, double height)
   * void set_margin_output(double left, double bottom, double right,
     double top)
   * void set_margin_output(double width, double height)
   * void set_margin_ratio(double left, double bottom, double right,
     double top)
   * void set_margin_ratio(double width, double height)
   * void set_numeric_format(std::ios_base::fmtflags format, unsigned
     int precision)
   * virtual void set_page(unsigned int page)
   * virtual void set_page_layout(unsigned int cols, unsigned int rows)
   * void set_ray_color_mode(RayColorMode m)
   * void set_ray_intensity_mode(IntensityMode m)
   * void set_style_color(Style s, const Rgb &rgb)
   * virtual void set_window(const Math::Vector2 &center, const
     Math::Vector2 &size, bool keep_aspect = _[...]_)
   * void set_window(const Math::VectorPair2 &window, bool keep_aspect =
     _[...]_)
   * void set_window(const Math::Vector2 &center, double radius, bool
     keep_aspect = _[...]_)
   * void write(std::ostream &s)

Io::RendererX11 class reference
===============================

Declaration
-----------

     #include <Goptical/Io/RendererX11>

     namespace Goptical {
       namespace Io {
         class RendererX11;
       };
     };


   This class is a member of the Io namespace.

Inheritance
-----------

Description
-----------

This class implements a X11 graphic output driver.

Members
-------

See also the full member list (*note
Io_RendererX11_class_full_member_list::) section for this class.

Inherited members
.................

   * 31 members inherited from RendererViewport (*note
     Io_RendererViewport_class_reference::)

Functions
.........

   * RendererX11(unsigned int width = _[...]_, unsigned int height =
     _[...]_, const Rgb &background = _[...]_, Display *disp = _[...]_,
     int src = _[...]_, Window win = _[...]_, GC gc = _[...]_)
   * ~RendererX11()
   * Display * get_disp() const
   * GC get_gc() const
   * int get_scr() const
   * Window get_win() const

Members detail
--------------

RendererX11(unsigned int width = 800, unsigned int height = 600, const Rgb &background = rgb_white, Display *disp = 0, int src = -1, Window win = -1, GC gc = 0)
................................................................................................................................................................

No documentation available

~RendererX11()
..............

No documentation available

Display * get_disp() const
..........................

Get X11 display.

   See also set_disp.

GC get_gc() const
.................

Get X11 graphics context.

   See also set_gc.

int get_scr() const
...................

Get X11 screen.

   See also set_scr.

Window get_win() const
......................

Get X11 window.

   See also set_win.

Io::RendererX11 class full member list
======================================

Functions
---------

   * RendererX11(unsigned int width = _[...]_, unsigned int height =
     _[...]_, const Rgb &background = _[...]_, Display *disp = _[...]_,
     int src = _[...]_, Window win = _[...]_, GC gc = _[...]_)
   * ~RendererX11()
   * virtual void draw_pages_grid(const Rgb &rgb = _[...]_)
   * Display * get_disp() const
   * double get_feature_size() const
   * double get_fov() const
   * GC get_gc() const
   * int get_scr() const
   * const Rgb & get_style_color(Style s) const
   * Window get_win() const
   * const Math::VectorPair2 & get_window() const
   * const Rgb & rgb_background() const
   * const Rgb & rgb_foreground() const
   * virtual void set_2d_size(double width, double height)
   * void set_camera_direction(const Math::Vector3 &dir)
   * void set_camera_position(const Math::Vector3 &pos)
   * void set_feature_size(double feature_size)
   * void set_fov(double fov)
   * void set_margin(double left, double bottom, double right, double
     top)
   * void set_margin(double width, double height)
   * void set_margin_output(double left, double bottom, double right,
     double top)
   * void set_margin_output(double width, double height)
   * void set_margin_ratio(double left, double bottom, double right,
     double top)
   * void set_margin_ratio(double width, double height)
   * void set_numeric_format(std::ios_base::fmtflags format, unsigned
     int precision)
   * virtual void set_page(unsigned int page)
   * virtual void set_page_layout(unsigned int cols, unsigned int rows)
   * void set_ray_color_mode(RayColorMode m)
   * void set_ray_intensity_mode(IntensityMode m)
   * void set_style_color(Style s, const Rgb &rgb)
   * virtual void set_window(const Math::Vector2 &center, const
     Math::Vector2 &size, bool keep_aspect = _[...]_)
   * void set_window(const Math::VectorPair2 &window, bool keep_aspect =
     _[...]_)
   * void set_window(const Math::Vector2 &center, double radius, bool
     keep_aspect = _[...]_)

Io::RendererX3d class reference
===============================

Declaration
-----------

This class is flagged as experimental.

     #include <Goptical/Io/RendererX3d>

     namespace Goptical {
       namespace Io {
         class RendererX3d;
       };
     };


   This class is a member of the Io namespace.

Inheritance
-----------

Description
-----------

This class implements an X3d graphic output driver.

Members
-------

See also the full member list (*note
Io_RendererX3d_class_full_member_list::) section for this class.

Inherited members
.................

   * 10 members inherited from Renderer (*note
     Io_Renderer_class_reference::)

Functions
.........

   * RendererX3d(const Rgb &background = _[...]_)
   * RendererX3d(const char *filename, const Rgb &background = _[...]_)
   * ~RendererX3d()
   * void clear()
   * void flush()
   * void write(std::ostream &s)

Members detail
--------------

RendererX3d(const Rgb &background = rgb_white)
..............................................

This constructor is flagged as experimental.

   Create a new X3d renderer.  The write (*note _415::) function must be
used to write x3d to output stream.

RendererX3d(const char *filename, const Rgb &background = rgb_white)
....................................................................

This constructor is flagged as experimental.

   Create a new X3d renderer.  X3d output will be written to given
filename when the renderer object is destroyed.

~RendererX3d()
..............

This destructor is flagged as experimental.

void clear()
............

This function is flagged as experimental.

void flush()
............

This function is flagged as experimental.

void write(std:: ostream &s)
............................

This function is flagged as experimental.

   Write svg output to given stream.

Io::RendererX3d class full member list
======================================

Functions
---------

   * RendererX3d(const Rgb &background = _[...]_)
   * RendererX3d(const char *filename, const Rgb &background = _[...]_)
   * ~RendererX3d()
   * void clear()
   * void flush()
   * double get_feature_size() const
   * const Rgb & get_style_color(Style s) const
   * const Rgb & rgb_background() const
   * const Rgb & rgb_foreground() const
   * void set_feature_size(double feature_size)
   * void set_ray_color_mode(RayColorMode m)
   * void set_ray_intensity_mode(IntensityMode m)
   * void set_style_color(Style s, const Rgb &rgb)
   * void write(std::ostream &s)

Io::Export class reference
==========================

Declaration
-----------

     #include <Goptical/Io/Export>

     namespace Goptical {
       namespace Io {
         class Export;
       };
     };


   This class is a member of the Io namespace.

   This abstract class contains pure virtuals.

Description
-----------

File export class interface

Members
-------

See also the full member list (*note Io_Export_class_full_member_list::)
section for this class.

Functions
.........

   * virtual void export_catalog(const Material::Catalog &catalog, const
     std::string &filename) = 0;
   * virtual void export_design(const Sys::System &sys, const
     std::string &filename) = 0;

Members detail
--------------

virtual void export_catalog(const Material::Catalog &catalog, const std:: string &filename) = 0;
................................................................................................

Export material catalog to file

virtual void export_design(const Sys::System &sys, const std:: string &filename) = 0;
.....................................................................................

Export optical design to file

Io::Export class full member list
=================================

Functions
---------

   * virtual void export_catalog(const Material::Catalog &catalog, const
     std::string &filename) = 0;
   * virtual void export_design(const Sys::System &sys, const
     std::string &filename) = 0;

Io::Import class reference
==========================

Declaration
-----------

     #include <Goptical/Io/Import>

     namespace Goptical {
       namespace Io {
         class Import;
       };
     };


   This class is a member of the Io namespace.

   This abstract class contains pure virtuals.

Description
-----------

File import class interface

Members
-------

See also the full member list (*note Io_Import_class_full_member_list::)
section for this class.

Functions
.........

   * virtual Material::Catalog & import_catalog(const std::string
     &filename) = 0;
   * virtual Set & import_dataset(const std::string &filename) = 0;
   * virtual Sys::System & import_design(const std::string &filename) =
     0;

Members detail
--------------

virtual Material::Catalog & import_catalog(const std:: string &filename) = 0;
.............................................................................

Import material catalog from file

virtual Set & import_dataset(const std:: string &filename) = 0;
...............................................................

Import dataset from file

virtual Sys::System & import_design(const std:: string &filename) = 0;
......................................................................

Import optical design from file

Io::Import class full member list
=================================

Functions
---------

   * virtual Material::Catalog & import_catalog(const std::string
     &filename) = 0;
   * virtual Set & import_dataset(const std::string &filename) = 0;
   * virtual Sys::System & import_design(const std::string &filename) =
     0;

Io::RendererAxes class reference
================================

Declaration
-----------

     #include <Goptical/Io/RendererAxes>

     namespace Goptical {
       namespace Io {
         class RendererAxes;
       };
     };


   This class is a member of the Io namespace.

Description
-----------

This class describe how axes must be rendered on graphical output.

Members
-------

See also the full member list (*note
Io_RendererAxes_class_full_member_list::) section for this class.

Type
....

   * enum AxisMask

Functions
.........

   * RendererAxes()
   * const std::string & get_label(unsigned int axis) const
   * const Math::Vector3 & get_origin() const
   * const Math::Vector3 & get_position() const
   * bool get_show_axes(unsigned int axis) const
   * bool get_show_frame() const
   * bool get_show_grid() const
   * bool get_show_tics(unsigned int axis) const
   * bool get_show_values(unsigned int axis) const
   * double get_tics_step(int index, const Math::range_t &r) const
   * void set_label(const std::string &label, AxisMask a = _[...]_)
   * void set_origin(const Math::Vector3 &origin)
   * void set_position(const Math::Vector3 &position)
   * void set_range(const Math::range_t &r, AxisMask a = _[...]_)
   * void set_show_axes(bool show = _[...]_, AxisMask a = _[...]_)
   * void set_show_frame(bool show = _[...]_)
   * void set_show_grid(bool show = _[...]_)
   * void set_show_tics(bool show = _[...]_, AxisMask a = _[...]_)
   * void set_show_values(bool show = _[...]_, AxisMask a = _[...]_)
   * void set_tics_base(unsigned int min_count = _[...]_, double base =
     _[...]_, AxisMask a = _[...]_)
   * void set_tics_count(unsigned int count, AxisMask a = _[...]_)
   * void set_tics_step(double step, AxisMask a = _[...]_)
   * void set_unit(const std::string &unit, bool pow10_scale = _[...]_,
     bool si_prefix = _[...]_, int si_pow10 = _[...]_, AxisMask a =
     _[...]_)

Members detail
--------------

RendererAxes()
..............

No documentation available

enum AxisMask
.............

Specify axes

Identifier             Description
--------------------------------------------------------------------------
X
Y
Z
XY
YZ
XZ
XYZ

const std:: string & get_label(unsigned int axis) const
.......................................................

Get axis label

const Math::Vector3 & get_origin() const
........................................

This function returns axes tics values origin.

const Math::Vector3 & get_position() const
..........................................

This function returns axis position

bool get_show_axes(unsigned int axis) const
...........................................

See set_show_axes (*note _436::) function.

bool get_show_frame() const
...........................

See set_show_frame (*note _437::) function.

bool get_show_grid() const
..........................

See set_show_grid (*note _438::) function.

bool get_show_tics(unsigned int axis) const
...........................................

See set_show_tics (*note _439::) function.

bool get_show_values(unsigned int axis) const
.............................................

See set_show_values (*note _440::) function.

double get_tics_step(int index, const Math::range_t &r) const
.............................................................

get distance between axis tics

void set_label(const std:: string &label, AxisMask a = XYZ)
...........................................................

This function set axis label

void set_origin(const Math::Vector3 &origin)
............................................

This function sets axis tics values origin.

void set_position(const Math::Vector3 &position)
................................................

This function returns axis position

void set_range(const Math::range_t &r, AxisMask a = XYZ)
........................................................

Set value range for given axis.  Default range is [0,0] which means
automatic range.

void set_show_axes(bool show = true, AxisMask a = XYZ)
......................................................

This function sets axes visibility.

void set_show_frame(bool show = true)
.....................................

This function sets frame visibility.

void set_show_grid(bool show = true)
....................................

This function sets grid visibility.  Grid points use tic step.

void set_show_tics(bool show = true, AxisMask a = XYZ)
......................................................

This function sets tics visibility.  Tics are located on axes and frame.

   See also set_show_axes (*note _436::) function and set_show_frame
(*note _437::) function.

void set_show_values(bool show = true, AxisMask a = XYZ)
........................................................

This function sets tics value visibility.  When frame is visible, tics
value is located on frame tics instead of axes tics.

   See also set_show_axes (*note _436::) function and set_show_frame
(*note _437::) function.

void set_tics_base(unsigned int min_count = 5, double base = 10.0, AxisMask a = XYZ)
....................................................................................

This function sets distance between axis tics to best fit power of
specified base divided by sufficient factor of 2 and 5 to have at least
'min_count' tics.

   See also set_tics_step (*note _443::) function and set_tics_count
(*note _442::) function.

void set_tics_count(unsigned int count, AxisMask a = XYZ)
.........................................................

This function sets tics count.

   See also set_tics_step (*note _443::) function and set_tics_base
(*note _441::) function.

void set_tics_step(double step, AxisMask a = XYZ)
.................................................

This function sets distance between axis tics to specified value.

   See also set_tics_count (*note _442::) function and set_tics_base
(*note _441::) function.

void set_unit(const std:: string &unit, bool pow10_scale = true, bool si_prefix = true, int si_pow10 = 0, AxisMask a = XYZ)
...........................................................................................................................

This function sets axis unit.

   When 'pow10_scale' is set, value will be scaled to shorten their
length and appropriate power of 10 factor will be displayed in axis
label.

   If 'si_prefix' is set, SI letter decimal prefix is used and the
'pow10' parameter can be used to scale base unit by power of ten (useful
when input data use scaled SI base unit).

Io::RendererAxes class full member list
=======================================

Type
----

   * enum AxisMask

Functions
---------

   * RendererAxes()
   * const std::string & get_label(unsigned int axis) const
   * const Math::Vector3 & get_origin() const
   * const Math::Vector3 & get_position() const
   * bool get_show_axes(unsigned int axis) const
   * bool get_show_frame() const
   * bool get_show_grid() const
   * bool get_show_tics(unsigned int axis) const
   * bool get_show_values(unsigned int axis) const
   * double get_tics_step(int index, const Math::range_t &r) const
   * void set_label(const std::string &label, AxisMask a = _[...]_)
   * void set_origin(const Math::Vector3 &origin)
   * void set_position(const Math::Vector3 &position)
   * void set_range(const Math::range_t &r, AxisMask a = _[...]_)
   * void set_show_axes(bool show = _[...]_, AxisMask a = _[...]_)
   * void set_show_frame(bool show = _[...]_)
   * void set_show_grid(bool show = _[...]_)
   * void set_show_tics(bool show = _[...]_, AxisMask a = _[...]_)
   * void set_show_values(bool show = _[...]_, AxisMask a = _[...]_)
   * void set_tics_base(unsigned int min_count = _[...]_, double base =
     _[...]_, AxisMask a = _[...]_)
   * void set_tics_count(unsigned int count, AxisMask a = _[...]_)
   * void set_tics_step(double step, AxisMask a = _[...]_)
   * void set_unit(const std::string &unit, bool pow10_scale = _[...]_,
     bool si_prefix = _[...]_, int si_pow10 = _[...]_, AxisMask a =
     _[...]_)

Io::RendererAxes::Axis internal struct members
==============================================

Axis()
------

No documentation available

bool _axis
----------

No documentation available

unsigned int _count
-------------------

No documentation available

std:: string _label
-------------------

No documentation available

int _pow10
----------

No documentation available

bool _pow10_scale
-----------------

No documentation available

Math::range_t _range
--------------------

No documentation available

bool _si_prefix
---------------

No documentation available

double _step_base
-----------------

No documentation available

step_mode_e _step_mode
----------------------

No documentation available

bool _tics
----------

No documentation available

std:: string _unit
------------------

No documentation available

bool _values
------------

No documentation available

Io::RendererViewport class reference
====================================

Declaration
-----------

     #include <Goptical/Io/RendererViewport>

     namespace Goptical {
       namespace Io {
         class RendererViewport;
       };
     };


   This class is a member of the Io namespace.

   This abstract class contains pure virtuals.

Inheritance
-----------

Description
-----------

This class defines an interface for rendering drivers which rely on
viewport windows, scaling and 2d projection operations.  It's designed
to be used as a base class for such renderers; this mainly includes
pixel based output renderers.

   Renderers which write output in vector format in world coordinates
directly do not need this class as base.

Members
-------

See also the full member list (*note
Io_RendererViewport_class_full_member_list::) section for this class.

Inherited members
.................

   * 10 members inherited from Renderer (*note
     Io_Renderer_class_reference::)

Functions
.........

   * RendererViewport()
   * virtual void draw_pages_grid(const Rgb &rgb = _[...]_)
   * virtual Math::Transform<3> get_camera_transform() const = 0;
   * double get_fov() const
   * const Math::VectorPair2 & get_window() const
   * virtual void set_2d_size(double width, double height)
   * void set_camera_direction(const Math::Vector3 &dir)
   * void set_camera_position(const Math::Vector3 &pos)
   * virtual void set_camera_transform(const Math::Transform<3> &t) = 0;
   * void set_fov(double fov)
   * void set_margin(double left, double bottom, double right, double
     top)
   * void set_margin(double width, double height)
   * void set_margin_output(double left, double bottom, double right,
     double top)
   * void set_margin_output(double width, double height)
   * void set_margin_ratio(double left, double bottom, double right,
     double top)
   * void set_margin_ratio(double width, double height)
   * void set_numeric_format(std::ios_base::fmtflags format, unsigned
     int precision)
   * virtual void set_page(unsigned int page)
   * virtual void set_page_layout(unsigned int cols, unsigned int rows)
   * virtual void set_perspective() = 0;
   * virtual void set_window(const Math::Vector2 &center, const
     Math::Vector2 &size, bool keep_aspect = _[...]_)
   * void set_window(const Math::VectorPair2 &window, bool keep_aspect =
     _[...]_)
   * void set_window(const Math::Vector2 &center, double radius, bool
     keep_aspect = _[...]_)

Members detail
--------------

RendererViewport()
..................

No documentation available

virtual void draw_pages_grid(const Rgb &rgb = rgb_gray)
.......................................................

Draw separations between pages, output window must have been setup
before.

virtual Math::Transform<3> get_camera_transform() const = 0;
............................................................

Get reference to 3d camera transform

double get_fov() const
......................

Get field of view in degrees.

   See also set_fov (*note _467::) function.

const Math::VectorPair2 & get_window() const
............................................

Get current viewport window

virtual void set_2d_size(double width, double height)
.....................................................

Update 2d output size, not all drivers support this

void set_camera_direction(const Math::Vector3 &dir)
...................................................

Set 3d camera rotation from direction vector

void set_camera_position(const Math::Vector3 &pos)
..................................................

Set 3d camera rotation from direction vector

virtual void set_camera_transform(const Math::Transform<3> &t) = 0;
...................................................................

Get modifiable reference to 3d camera transform

void set_fov(double fov)
........................

Set field of view in degrees.

   See also get_fov (*note _461::) function.

void set_margin(double left, double bottom, double right, double top)
.....................................................................

Set amount of 2d margin space for set_window (*note _478::) operation in
world coordinates units.

void set_margin(double width, double height)
............................................

See set_margin (*note _468::) function.

void set_margin_output(double left, double bottom, double right, double top)
............................................................................

Set amount of 2d margin space for set_window (*note _478::) operation in
output size units (usually pixels).

void set_margin_output(double width, double height)
...................................................

See set_margin_output (*note _470::) function.

void set_margin_ratio(double left, double bottom, double right, double top)
...........................................................................

Set amount of 2d margin space for set_window (*note _478::) operation as
ratio of window.

void set_margin_ratio(double width, double height)
..................................................

See set_margin_ratio (*note _472::) function.

void set_numeric_format(std::ios_base:: fmtflags format, unsigned int precision)
................................................................................

Set format used to print numeric values

virtual void set_page(unsigned int page)
........................................

Select current page when multiple pages layout is in use.

   See also set_page_layout (*note _476::) function.

virtual void set_page_layout(unsigned int cols, unsigned int rows)
..................................................................

This function can be used to setup a pages grid.  Current output page
must be selected with set_page (*note _475::).

virtual void set_perspective() = 0;
...................................

Set 3d perspective projection mode.  This function reset the viewport
window to (-1,1).

   See also set_window (*note _478::) function and set_fov (*note
_467::) function.

virtual void set_window(const Math::Vector2 &center, const Math::Vector2 &size, bool keep_aspect = true)
........................................................................................................

Set 2d viewport window.  This function set 3d projection to
orthographic.

void set_window(const Math::VectorPair2 &window, bool keep_aspect = true)
.........................................................................

Set 2d viewport window.  This function set 3d projection to
orthographic.

void set_window(const Math::Vector2 &center, double radius, bool keep_aspect = true)
....................................................................................

Set 2d viewport window.  This function set 3d projection to
orthographic.

Io::RendererViewport class full member list
===========================================

Functions
---------

   * RendererViewport()
   * virtual void draw_pages_grid(const Rgb &rgb = _[...]_)
   * virtual Math::Transform<3> get_camera_transform() const = 0;
   * double get_feature_size() const
   * double get_fov() const
   * const Rgb & get_style_color(Style s) const
   * const Math::VectorPair2 & get_window() const
   * const Rgb & rgb_background() const
   * const Rgb & rgb_foreground() const
   * virtual void set_2d_size(double width, double height)
   * void set_camera_direction(const Math::Vector3 &dir)
   * void set_camera_position(const Math::Vector3 &pos)
   * virtual void set_camera_transform(const Math::Transform<3> &t) = 0;
   * void set_feature_size(double feature_size)
   * void set_fov(double fov)
   * void set_margin(double left, double bottom, double right, double
     top)
   * void set_margin(double width, double height)
   * void set_margin_output(double left, double bottom, double right,
     double top)
   * void set_margin_output(double width, double height)
   * void set_margin_ratio(double left, double bottom, double right,
     double top)
   * void set_margin_ratio(double width, double height)
   * void set_numeric_format(std::ios_base::fmtflags format, unsigned
     int precision)
   * virtual void set_page(unsigned int page)
   * virtual void set_page_layout(unsigned int cols, unsigned int rows)
   * virtual void set_perspective() = 0;
   * void set_ray_color_mode(RayColorMode m)
   * void set_ray_intensity_mode(IntensityMode m)
   * void set_style_color(Style s, const Rgb &rgb)
   * virtual void set_window(const Math::Vector2 &center, const
     Math::Vector2 &size, bool keep_aspect = _[...]_)
   * void set_window(const Math::VectorPair2 &window, bool keep_aspect =
     _[...]_)
   * void set_window(const Math::Vector2 &center, double radius, bool
     keep_aspect = _[...]_)

Io::Rgb struct reference
========================

Declaration
-----------

     #include <Goptical/Io/Rgb>

     namespace Goptical {
       namespace Io {
         struct Rgb;
       };
     };


   This struct is a member of the Io namespace.

Description
-----------

RGB color descriptor

Members
-------

See also the full member list (*note Io_Rgb_struct_full_member_list::)
section for this struct.

Functions
.........

   * Rgb()
   * Rgb(float red, float green, float blue, float alpha = _[...]_)
   * bool operator<(const Rgb &rgb) const
   * Rgb operator~() const

Fields
......

   * float a
   * float b
   * float g
   * float r

Members detail
--------------

Rgb()
.....

No documentation available

Rgb(float red, float green, float blue, float alpha = 1.0)
..........................................................

No documentation available

float a
.......

No documentation available

float b
.......

No documentation available

float g
.......

No documentation available

bool operator<(const Rgb &rgb) const
....................................

No documentation available

Rgb operator~() const
.....................

No documentation available

float r
.......

No documentation available

Io::Rgb struct full member list
===============================

Functions
---------

   * Rgb()
   * Rgb(float red, float green, float blue, float alpha = _[...]_)
   * bool operator<(const Rgb &rgb) const
   * Rgb operator~() const

Fields
------

   * float a
   * float b
   * float g
   * float r

Light namespace reference
=========================

Description
-----------

Physical properties of light

Members
-------

Types
.....

   * class Ray
   * class SpectralLine

Light::Ray class reference
==========================

Declaration
-----------

     #include <Goptical/Light/Ray>

     namespace Goptical {
       namespace Light {
         class Ray;
       };
     };


   This class is a member of the Light namespace.

Inheritance
-----------

Description
-----------

This class is used to describe a ray of light.  It contains geometrical
and physical informations about a light ray.

Members
-------

See also the full member list (*note Light_Ray_class_full_member_list::)
section for this class.

Inherited members
.................

   * 34 members inherited from Math::VectorPair (*note
     Math_VectorPair_3_struct_reference::)<3>

Functions
.........

   * Ray()
   * Ray(const Math::VectorPair3 &ray, double intensity = _[...]_,
     double wavelen = _[...]_)
   * double get_intensity() const
   * double get_wavelen() const
   * void set_intensity(double intensity)
   * void set_wavelen(double wavelen)

Members detail
--------------

Ray()
.....

No documentation available

Ray(const Math::VectorPair3 &ray, double intensity = 1, double wavelen = 550)
.............................................................................

Create a ray of light with specified properties

double get_intensity() const
............................

Get light ray intensity

double get_wavelen() const
..........................

Set light ray wavelen

void set_intensity(double intensity)
....................................

Set light ray intensity

void set_wavelen(double wavelen)
................................

Get light ray wavelen

Light::Ray class full member list
=================================

Functions
---------

   * Ray()
   * Ray(const Math::VectorPair3 &ray, double intensity = _[...]_,
     double wavelen = _[...]_)
   * Math::Vector<N> & direction()
   * const Math::Vector<N> & direction() const
   * double get_intensity() const
   * double get_wavelen() const
   * Math::Vector<3> ln_ln_clst_pt(const Math::VectorPair<3> &line)
     const
   * double ln_ln_clst_pt_scale(const Math::VectorPair<3> &line) const
   * Math::Vector<N> ln_pt_clst_pt(const Math::Vector<N> &point) const
   * double ln_pt_clst_pt_scale(const Math::Vector<N> &point) const
   * Math::Vector<N> & normal()
   * const Math::Vector<N> & normal() const
   * Math::VectorPairBase<3> operator*(double factor)
   * const Math::VectorPairBase<3> & operator+=(const
     Math::VectorPairBase<3> &p)
   * const Math::Vector<N> & operator[](int n) const
   * Math::Vector<N> & operator[](int n)
   * Math::Vector<N> & origin()
   * const Math::Vector<N> & origin() const
   * Math::Vector<3> pl_ln_intersect(const Math::VectorPair<3> &line)
     const
   * double pl_ln_intersect_scale(const Math::VectorPair<3> &line) const
   * Math::Vector<N> seg_pt_clst_pt(const Math::Vector<N> &point) const
   * double seg_pt_clst_pt_scale(const Math::Vector<N> &point) const
   * void set_intensity(double intensity)
   * void set_wavelen(double wavelen)
   * double x0() const
   * double & x0()
   * double x1() const
   * double & x1()
   * double y0() const
   * double & y0()
   * double y1() const
   * double & y1()
   * double z0() const
   * double & z0()
   * double z1() const
   * double & z1()

Light::SpectralLine class reference
===================================

Declaration
-----------

     #include <Goptical/Light/SpectralLine>

     namespace Goptical {
       namespace Light {
         class SpectralLine;
       };
     };


   This class is a member of the Light namespace.

Description
-----------

This class can be used to describe a spectral line.  It contains
constants for wave length of standard rays

Members
-------

See also the full member list (*note
Light_SpectralLine_class_full_member_list::) section for this class.

Functions
.........

   * SpectralLine(double wavelen, double intensity = _[...]_)
   * Io::Rgb get_color() const
   * double get_intensity() const
   * double get_wavelen() const

Static function
...............

   * static Io::Rgb get_wavelen_color(double wl)

Constants
.........

   * static const double C
   * static const double C_
   * static const double D
   * static const double F
   * static const double F_
   * static const double blue
   * static const double d
   * static const double e
   * static const double g
   * static const double green
   * static const double h
   * static const double i
   * static const double r
   * static const double red
   * static const double s
   * static const double t

Members detail
--------------

SpectralLine(double wavelen, double intensity = 1.0)
....................................................

Create a spectral line with specified wavelen and intensity.

static const double C
.....................

red hydrogen line at 656.2725nm

static const double C_
......................

red cadmium line at 643.8469nm

static const double D
.....................

yellow sodium line at 589.2938nm

static const double F
.....................

blue hydrogen line at 486.1327nm

static const double F_
......................

blue cadmium line at 479.9914nm

static const double blue
........................

blue colored line at 440nm

static const double d
.....................

yellow helium line at 587.5618nm

static const double e
.....................

green mercury line at 546.074nm

static const double g
.....................

blue mercury line at 435.8343nm

Io::Rgb get_color() const
.........................

get rgb color associated spectral line, ignore intensity

double get_intensity() const
............................

get spectral line intensity

double get_wavelen() const
..........................

get spectral line wavelen

static Io::Rgb get_wavelen_color(double wl)
...........................................

get rgb color associated with wavelen

static const double green
.........................

green colored line at 510nm

static const double h
.....................

violet mercury line at 404.6561nm

static const double i
.....................

ultraviolet mercury line at 365.0146nm

static const double r
.....................

red helium line at 706.5188nm

static const double red
.......................

red colored line at 645nm

static const double s
.....................

infrared cesium line at 852.11nm

static const double t
.....................

infrared mercury line at 1013.98nm

Light::SpectralLine class full member list
==========================================

Functions
---------

   * SpectralLine(double wavelen, double intensity = _[...]_)
   * Io::Rgb get_color() const
   * double get_intensity() const
   * double get_wavelen() const

Static function
---------------

   * static Io::Rgb get_wavelen_color(double wl)

Constants
---------

   * static const double C
   * static const double C_
   * static const double D
   * static const double F
   * static const double F_
   * static const double blue
   * static const double d
   * static const double e
   * static const double g
   * static const double green
   * static const double h
   * static const double i
   * static const double r
   * static const double red
   * static const double s
   * static const double t

Material namespace reference
============================

Description
-----------

Material models for optical components

Members
-------

Types
.....

   * template class Abbe
   * template class Air
   * class Base
   * class Catalog
   * class Conrady
   * class DispersionTable
   * class Herzberger
   * class Metal
   * class Mil
   * class Mirror
   * class Schott
   * class Sellmeier
   * template class SellmeierMod
   * class Vacuum
   * enum AbbeFormula
   * typedef _ [...]  _ AbbeVd
   * typedef _ [...]  _ AbbeVe
   * typedef _ [...]  _ AirBirch94
   * enum AirFormula
   * typedef _ [...]  _ AirKohlrausch68
   * class Dielectric
   * typedef _ [...]  _ Handbook1
   * typedef _ [...]  _ Handbook2
   * class Proxy
   * typedef _ [...]  _ SellmeierMod2
   * enum SellmeierModFormula
   * class Solid

Constants
.........

   * const const_ref<Base> none
   * const AirBirch94 std_air

Variables
.........

   * AirBirch94 air
   * Mirror mirror
   * Vacuum vacuum

Members detail
--------------

enum AbbeFormula
................

Specify Abbe number type used by the Abbe (*note
Material_Abbe_class_reference::) class

Identifier             Description
--------------------------------------------------------------------------
AbbeVdFormula          Abbe number of Fraunhofer _d_ line
                       
AbbeVeFormula          Abbe number of Fraunhofer _e_ line
                       

typedef Abbe<AbbeVdFormula> AbbeVd
..................................

See Abbe (*note Material_Abbe_class_reference::) class.

typedef Abbe<AbbeVeFormula> AbbeVe
..................................

See Abbe (*note Material_Abbe_class_reference::) class.

typedef Air<AirBirch94Formula> AirBirch94
.........................................

See Air (*note Material_Air_class_reference::) class.

enum AirFormula
...............

Specify air refractive index model used by Air (*note
Material_Air_class_reference::) class.

Identifier             Description
--------------------------------------------------------------------------
AirBirch94Formula      Birch, Metrologia, 1994, 31, 315
                       
AirKohlrausch68Formula F. Kohlrausch, Praktische Physik, 1968, 1, 408
                       

typedef Air<AirKohlrausch68Formula> AirKohlrausch68
...................................................

See Air (*note Material_Air_class_reference::) class.

typedef SellmeierMod<Handbook1Formula> Handbook1
................................................

See SellmeierMod (*note Material_SellmeierMod_class_reference::) class.

typedef SellmeierMod<Handbook2Formula> Handbook2
................................................

See SellmeierMod (*note Material_SellmeierMod_class_reference::) class.

typedef SellmeierMod<SellmeierMod2Formula> SellmeierMod2
........................................................

See SellmeierMod (*note Material_SellmeierMod_class_reference::) class.

enum SellmeierModFormula
........................

Specify Sellmeier variation used by the SellmeierMod (*note
Material_SellmeierMod_class_reference::) class

Identifier             Description
--------------------------------------------------------------------------
SellmeierMod2Formula
Handbook1Formula
Handbook2Formula

AirBirch94 air
..............

A global instance of AirBirch94 (*note _519::) material.

Mirror mirror
.............

A global instance of Material::Mirror material.

const const_ref <Base> none
...........................

Material null pointer

const AirBirch94 std_air
........................

A global read only instance of AirBirch94 (*note _519::) material with
standard parameters.

Vacuum vacuum
.............

A global instance of Material::Vacuum material.

Material::Abbe class reference
==============================

Declaration
-----------

     #include <Goptical/Material/Abbe>

     namespace Goptical {
       namespace Material {
         template <enum AbbeFormula m> class Abbe;
       };
     };


   This class is a member of the Material namespace.

Inheritance
-----------

Description
-----------

This class models optical properties of glass materials using known
refractive index value, Abbe number and partial dispersion deviation
(dpgF).

   AbbeVd (*note _517::) and AbbeVe (*note _518::) template instances
are available for _d_ and _e_ line definitions of Abbe number.

   The following formula is used to determine refractive index at any
wavelen in visible spectrum:

   n_\lambda = n_d + \frac{\left( n_d-1\right)}{v_d}\times\left(
c_1+a\times c_0 + \frac{c_3+a\times c_2}{\lambda} + \frac{c_5+a\times
c_4}{{\lambda}^{2}} + \frac{c_7+a\times c_6}{{\lambda}^{3}} \right)

   with a = a_1\times v_d+a_0+\Delta P_{g,F} and \lambda the micrometer
wavelength.

   _a0_ and _a1_ values are given in Schott "_TIE-29: Refractive Index
and Dispersion_" technical information document.

   _c0_ to _c7_ values were determined using least square fitting on
indexes obtained using Sellmeier data from 118 glass materials from the
Schott catalog for 360 wavelengths between 390nm and 750nm.  Two
different coefficients sets are used for _nd/vd_ and _ne/ve_ pairs.

   Mean error is less than 0.00002 from Sellmeier indexes and largest
error found across fitted glasses and wavelengths is 0.0008.  When dpgF
is set to 0, mean error becomes 0.0001 and largest error is close to
0.006.

Members
-------

See also the full member list (*note
Material_Abbe_class_full_member_list::) section for this class.

Inherited members
.................

   * 36 members inherited from Dielectric (*note
     Material_Dielectric_class_reference::)

Functions
.........

   * Abbe(double n, double v, double dpgF = _[...]_)
   * virtual double get_measurement_index(double wavelen) const

Members detail
--------------

Abbe(double n, double v, double dpgF = 0.)
..........................................

Create an abbe glass model

virtual double get_measurement_index(double wavelen) const
..........................................................

This virtual function implements the 'get_measurement_index (*note
_617::)' pure function declared in the 'Dielectric (*note
Material_Dielectric_class_reference::)' base abstract class.

   Documentation inherited from base class:

   Get material relative refractive index in measurment medium at
specified wavelen in _nm._

Material::Abbe class full member list
=====================================

Functions
---------

   * Abbe(double n, double v, double dpgF = _[...]_)
   * void clear_internal_transmittance()
   * void disable_temperature_coeff()
   * double get_abbe_vd() const
   * double get_abbe_ve() const
   * virtual Io::Rgb get_color() const
   * double get_density() const
   * virtual double get_extinction_coef(double wavelen) const
   * virtual double get_internal_transmittance(double wavelen, double
     thickness) const
   * double get_internal_transmittance(double wavelen) const
   * virtual double get_measurement_index(double wavelen) const
   * virtual double get_normal_reflectance(const Base *from, double
     wavelen) const
   * virtual double get_normal_transmittance(const Base *from, double
     wavelen) const
   * double get_partial_dispersion(double wavelen1, double wavelen2)
     const
   * double get_poisson_ratio() const
   * double get_principal_dispersion() const
   * double get_refractive_index(double wavelen, const Base &env) const
   * virtual double get_refractive_index(double wavelen) const
   * virtual double get_temperature() const
   * double get_thermal_conductivity() const
   * double get_thermal_expansion() const
   * Data::DiscreteSet & get_transmittance_dataset()
   * double get_young_modulus() const
   * virtual bool is_opaque() const
   * virtual bool is_reflecting() const
   * void set_density(double density)
   * void set_internal_transmittance(double wavelen, double thickness,
     double transmittance)
   * void set_measurement_medium(const const_ref<Base> &medium)
   * void set_poisson_ratio(double poisson_ratio)
   * void set_temperature(double temp)
   * void set_temperature_dndt(double dndt)
   * void set_temperature_schott(double d0, double d1, double d2, double
     e0, double e1, double wl_tk)
   * void set_thermal_conductivity(double thermal_conductivity)
   * void set_thermal_expansion(double thermal_expansion)
   * void set_wavelen_range(double low, double high)
   * void set_young_modulus(double young_modulus)

Material::Air class reference
=============================

Declaration
-----------

     #include <Goptical/Material/Air>

     namespace Goptical {
       namespace Material {
         template <enum AirFormula M> class Air;
       };
     };


   This class is a member of the Material namespace.

Inheritance
-----------

Description
-----------

This class models optical properties of air.  Refractive index of air
depends on temperature and pressure.

   This class provides different formulas:

   * AirBirch94 (*note _519::) : described in "_Birch, Metrologia, 1994,
     31, 315_".

   * AirKohlrausch68 (*note _521::) : described in "_F. Kohlrausch,
     Praktische Physik, 1968, 1, 408_".

   Global variables air (*note _526::) and std_air (*note _529::) are
available with default parameters and Birch model.

Members
-------

See also the full member list (*note
Material_Air_class_full_member_list::) section for this class.

Inherited members
.................

   * 14 members inherited from Base (*note
     Material_Base_class_reference::)

Functions
.........

   * Air(double pressure = _[...]_)
   * virtual double get_extinction_coef(double wavelen) const
   * virtual double get_internal_transmittance(double wavelen, double
     thickness) const
   * double get_pressure() const
   * virtual double get_refractive_index(double wavelen) const
   * virtual bool is_opaque() const
   * virtual bool is_reflecting() const
   * void set_pressure(double pressure)

Constant
........

   * static const double std_pressure

Members detail
--------------

Air(double pressure = std_pressure)
...................................

Create a new air material model with 101325 Pa pressure.

virtual double get_extinction_coef(double wavelen) const
........................................................

This virtual function overrides the 'get_extinction_coef (*note _545::)'
virtual function defined in the 'Base (*note
Material_Base_class_reference::)' base abstract class.

   Documentation inherited from base class:

   Get extinction coefficient.  Subclasses _must_ provide this function
or the get_internal_transmittance() function.

virtual double get_internal_transmittance(double wavelen, double thickness) const
.................................................................................

This virtual function overrides the 'get_internal_transmittance (*note
_546::)' virtual function defined in the 'Base (*note
Material_Base_class_reference::)' base abstract class.

   Documentation inherited from base class:

   Get material internal transmittance for thickness in mm.  Subclasses
_must_ provide this function or the get_extinction_coef() function.

double get_pressure() const
...........................

Get relative air pressure in _Pa_.

   See also set_pressure (*note _540::) function and std_pressure (*note
_541::) variable.

virtual double get_refractive_index(double wavelen) const
.........................................................

This virtual function implements the 'get_refractive_index (*note
_550::)' pure function declared in the 'Base (*note
Material_Base_class_reference::)' base abstract class.

   Documentation inherited from base class:

   Get material absolute refractive index at specified wavelen in _nm._

virtual bool is_opaque() const
..............................

This virtual function implements the 'is_opaque (*note _553::)' pure
function declared in the 'Base (*note Material_Base_class_reference::)'
base abstract class.

   Documentation inherited from base class:

   Return true if material must be considered opaque for ray tracing

virtual bool is_reflecting() const
..................................

This virtual function implements the 'is_reflecting (*note _554::)' pure
function declared in the 'Base (*note Material_Base_class_reference::)'
base abstract class.

   Documentation inherited from base class:

   Return true if material may reflect most of the light and must be
considered as a mirror when ignoring ray intensity computation during
ray tracing.

void set_pressure(double pressure)
..................................

Set relative air pressure in _Pa_.

   See also get_pressure (*note _536::) function and std_pressure (*note
_541::) variable.

static const double std_pressure
................................

Standard air pressure is 101325 _Pa_

Material::Air class full member list
====================================

Functions
---------

   * Air(double pressure = _[...]_)
   * virtual Io::Rgb get_color() const
   * virtual double get_extinction_coef(double wavelen) const
   * double get_internal_transmittance(double wavelen) const
   * virtual double get_internal_transmittance(double wavelen, double
     thickness) const
   * virtual double get_normal_reflectance(const Base *from, double
     wavelen) const
   * virtual double get_normal_transmittance(const Base *from, double
     wavelen) const
   * double get_pressure() const
   * double get_refractive_index(double wavelen, const Base &env) const
   * virtual double get_refractive_index(double wavelen) const
   * virtual double get_temperature() const
   * virtual bool is_opaque() const
   * virtual bool is_reflecting() const
   * void set_pressure(double pressure)
   * void set_temperature(double temp)

Constant
--------

   * static const double std_pressure

Material::Base class reference
==============================

Declaration
-----------

     #include <Goptical/Material/Base>

     namespace Goptical {
       namespace Material {
         class Base;
       };
     };


   This class is a member of the Material namespace.

   This abstract class contains pure virtuals.

Inheritance
-----------

Description
-----------

This class is the base class for all material classes.  It desrcibes
physical properties of materials which interact with light.

Members
-------

See also the full member list (*note
Material_Base_class_full_member_list::) section for this class.

Functions
.........

   * Base()
   * virtual ~Base()
   * virtual Io::Rgb get_color() const
   * virtual double get_extinction_coef(double wavelen) const
   * virtual double get_internal_transmittance(double wavelen, double
     thickness) const
   * double get_internal_transmittance(double wavelen) const
   * virtual double get_normal_reflectance(const Base *from, double
     wavelen) const
   * virtual double get_normal_transmittance(const Base *from, double
     wavelen) const
   * virtual double get_refractive_index(double wavelen) const = 0;
   * double get_refractive_index(double wavelen, const Base &env) const
   * virtual double get_temperature() const
   * virtual bool is_opaque() const = 0;
   * virtual bool is_reflecting() const = 0;
   * void set_temperature(double temp)

Members detail
--------------

Base()
......

Material base constuctor.  Set material temperature to 20.

virtual ~Base()
...............

No documentation available

virtual Io::Rgb get_color() const
.................................

Get material color and alpha

virtual double get_extinction_coef(double wavelen) const
........................................................

Get extinction coefficient.  Subclasses _must_ provide this function or
the get_internal_transmittance() function.

virtual double get_internal_transmittance(double wavelen, double thickness) const
.................................................................................

Get material internal transmittance for thickness in mm.  Subclasses
_must_ provide this function or the get_extinction_coef() function.

double get_internal_transmittance(double wavelen) const
.......................................................

Get material internal transmittance for 1mm thickness.

virtual double get_normal_reflectance(const Base *from, double wavelen) const
.............................................................................

Get reflectance at normal incidence

virtual double get_normal_transmittance(const Base *from, double wavelen) const
...............................................................................

Get transmittance at normal incidence

virtual double get_refractive_index(double wavelen) const = 0;
..............................................................

Get material absolute refractive index at specified wavelen in _nm._

double get_refractive_index(double wavelen, const Base &env) const
..................................................................

Get material relative refractive index in given medium at specified
wavelen in _nm._

virtual double get_temperature() const
......................................

Get material temperature in celcius

virtual bool is_opaque() const = 0;
...................................

Return true if material must be considered opaque for ray tracing

virtual bool is_reflecting() const = 0;
.......................................

Return true if material may reflect most of the light and must be
considered as a mirror when ignoring ray intensity computation during
ray tracing.

void set_temperature(double temp)
.................................

Set material temperature in celcius

Material::Base class full member list
=====================================

Functions
---------

   * Base()
   * virtual ~Base()
   * virtual Io::Rgb get_color() const
   * virtual double get_extinction_coef(double wavelen) const
   * virtual double get_internal_transmittance(double wavelen, double
     thickness) const
   * double get_internal_transmittance(double wavelen) const
   * virtual double get_normal_reflectance(const Base *from, double
     wavelen) const
   * virtual double get_normal_transmittance(const Base *from, double
     wavelen) const
   * virtual double get_refractive_index(double wavelen) const = 0;
   * double get_refractive_index(double wavelen, const Base &env) const
   * virtual double get_temperature() const
   * virtual bool is_opaque() const = 0;
   * virtual bool is_reflecting() const = 0;
   * void set_temperature(double temp)

Material::Catalog class reference
=================================

Declaration
-----------

     #include <Goptical/Material/Catalog>

     namespace Goptical {
       namespace Material {
         class Catalog;
       };
     };


   This class is a member of the Material namespace.

Inheritance
-----------

Description
-----------

Hold a glass material catalog

Members
-------

See also the full member list (*note
Material_Catalog_class_full_member_list::) section for this class.

Functions
.........

   * Catalog(const std::string &name = _[...]_)
   * void add_material(const std::string &material_name, const
     const_ref<Base> &material)
   * void del_material(const std::string &material_name)
   * const Base & get_material(const std::string &material_name)
   * const std::string & get_name() const
   * void set_name(const std::string &name)

Members detail
--------------

Catalog(const std:: string &name = "")
......................................

Create a catalog with given name

void add_material(const std:: string &material_name, const const_ref <Base> &material)
......................................................................................

Add a material to catalog.  material object will be deleted on catalog
destruction if owner is set.

void del_material(const std:: string &material_name)
....................................................

Remove a material from catalog

const Base & get_material(const std:: string &material_name)
............................................................

Get material with given name

const std:: string & get_name() const
.....................................

Get catalog name

void set_name(const std:: string &name)
.......................................

Set catalog name

Material::Catalog class full member list
========================================

Functions
---------

   * Catalog(const std::string &name = _[...]_)
   * void add_material(const std::string &material_name, const
     const_ref<Base> &material)
   * void del_material(const std::string &material_name)
   * const Base & get_material(const std::string &material_name)
   * const std::string & get_name() const
   * void set_name(const std::string &name)

Material::Conrady class reference
=================================

Declaration
-----------

     #include <Goptical/Material/Conrady>

     namespace Goptical {
       namespace Material {
         class Conrady;
       };
     };


   This class is a member of the Material namespace.

Inheritance
-----------

Description
-----------

This class models optical properties of dielectric materials with
conrady refractive index dispersion formula.

   Refractive index formula is:

   n_\lambda = A + \frac{B}{\lambda} + \frac{C}{\lambda^{3.5}}

   with \lambda the micrometer wavelength.

Members
-------

See also the full member list (*note
Material_Conrady_class_full_member_list::) section for this class.

Inherited members
.................

   * 36 members inherited from Dielectric (*note
     Material_Dielectric_class_reference::)

Functions
.........

   * Conrady()
   * Conrady(double A, double B, double C)
   * virtual double get_measurement_index(double wavelen) const
   * void set_coefficients(double A, double B, double C)

Members detail
--------------

Conrady()
.........

Create an empty conrady model

Conrady(double A, double B, double C)
.....................................

Create an conrady model with given coefficients

virtual double get_measurement_index(double wavelen) const
..........................................................

This virtual function implements the 'get_measurement_index (*note
_617::)' pure function declared in the 'Dielectric (*note
Material_Dielectric_class_reference::)' base abstract class.

   Documentation inherited from base class:

   Get material relative refractive index in measurment medium at
specified wavelen in _nm._

void set_coefficients(double A, double B, double C)
...................................................

Change conrady constant term

Material::Conrady class full member list
========================================

Functions
---------

   * Conrady()
   * Conrady(double A, double B, double C)
   * void clear_internal_transmittance()
   * void disable_temperature_coeff()
   * double get_abbe_vd() const
   * double get_abbe_ve() const
   * virtual Io::Rgb get_color() const
   * double get_density() const
   * virtual double get_extinction_coef(double wavelen) const
   * virtual double get_internal_transmittance(double wavelen, double
     thickness) const
   * double get_internal_transmittance(double wavelen) const
   * virtual double get_measurement_index(double wavelen) const
   * virtual double get_normal_reflectance(const Base *from, double
     wavelen) const
   * virtual double get_normal_transmittance(const Base *from, double
     wavelen) const
   * double get_partial_dispersion(double wavelen1, double wavelen2)
     const
   * double get_poisson_ratio() const
   * double get_principal_dispersion() const
   * double get_refractive_index(double wavelen, const Base &env) const
   * virtual double get_refractive_index(double wavelen) const
   * virtual double get_temperature() const
   * double get_thermal_conductivity() const
   * double get_thermal_expansion() const
   * Data::DiscreteSet & get_transmittance_dataset()
   * double get_young_modulus() const
   * virtual bool is_opaque() const
   * virtual bool is_reflecting() const
   * void set_coefficients(double A, double B, double C)
   * void set_density(double density)
   * void set_internal_transmittance(double wavelen, double thickness,
     double transmittance)
   * void set_measurement_medium(const const_ref<Base> &medium)
   * void set_poisson_ratio(double poisson_ratio)
   * void set_temperature(double temp)
   * void set_temperature_dndt(double dndt)
   * void set_temperature_schott(double d0, double d1, double d2, double
     e0, double e1, double wl_tk)
   * void set_thermal_conductivity(double thermal_conductivity)
   * void set_thermal_expansion(double thermal_expansion)
   * void set_wavelen_range(double low, double high)
   * void set_young_modulus(double young_modulus)

Material::DispersionTable class reference
=========================================

Declaration
-----------

     #include <Goptical/Material/DispersionTable>

     namespace Goptical {
       namespace Material {
         class DispersionTable;
       };
     };


   This class is a member of the Material namespace.

Inheritance
-----------

Description
-----------

This class models refractive index of optical material using user
provided data table.

   Known refractive index values are stored and interpolated by a
Data::DiscreteSet (*note Data_DiscreteSet_class_reference::) object.
Default interpolation is Data::Cubic (*note _146::).

Members
-------

See also the full member list (*note
Material_DispersionTable_class_full_member_list::) section for this
class.

Inherited members
.................

   * 36 members inherited from Dielectric (*note
     Material_Dielectric_class_reference::)

Functions
.........

   * DispersionTable()
   * void clear_refractive_index_table()
   * virtual double get_measurement_index(double wavelen) const
   * Data::DiscreteSet & get_refractive_index_dataset()
   * void set_refractive_index(double wavelen, double index)

Members detail
--------------

DispersionTable()
.................

No documentation available

void clear_refractive_index_table()
...................................

Clear all refractive index data

virtual double get_measurement_index(double wavelen) const
..........................................................

This virtual function implements the 'get_measurement_index (*note
_617::)' pure function declared in the 'Dielectric (*note
Material_Dielectric_class_reference::)' base abstract class.

   Documentation inherited from base class:

   Get material relative refractive index in measurment medium at
specified wavelen in _nm._

Data::DiscreteSet & get_refractive_index_dataset()
..................................................

Get refractive index dataset object

void set_refractive_index(double wavelen, double index)
.......................................................

Add refractive index data

Material::DispersionTable class full member list
================================================

Functions
---------

   * DispersionTable()
   * void clear_internal_transmittance()
   * void clear_refractive_index_table()
   * void disable_temperature_coeff()
   * double get_abbe_vd() const
   * double get_abbe_ve() const
   * virtual Io::Rgb get_color() const
   * double get_density() const
   * virtual double get_extinction_coef(double wavelen) const
   * virtual double get_internal_transmittance(double wavelen, double
     thickness) const
   * double get_internal_transmittance(double wavelen) const
   * virtual double get_measurement_index(double wavelen) const
   * virtual double get_normal_reflectance(const Base *from, double
     wavelen) const
   * virtual double get_normal_transmittance(const Base *from, double
     wavelen) const
   * double get_partial_dispersion(double wavelen1, double wavelen2)
     const
   * double get_poisson_ratio() const
   * double get_principal_dispersion() const
   * double get_refractive_index(double wavelen, const Base &env) const
   * virtual double get_refractive_index(double wavelen) const
   * Data::DiscreteSet & get_refractive_index_dataset()
   * virtual double get_temperature() const
   * double get_thermal_conductivity() const
   * double get_thermal_expansion() const
   * Data::DiscreteSet & get_transmittance_dataset()
   * double get_young_modulus() const
   * virtual bool is_opaque() const
   * virtual bool is_reflecting() const
   * void set_density(double density)
   * void set_internal_transmittance(double wavelen, double thickness,
     double transmittance)
   * void set_measurement_medium(const const_ref<Base> &medium)
   * void set_poisson_ratio(double poisson_ratio)
   * void set_refractive_index(double wavelen, double index)
   * void set_temperature(double temp)
   * void set_temperature_dndt(double dndt)
   * void set_temperature_schott(double d0, double d1, double d2, double
     e0, double e1, double wl_tk)
   * void set_thermal_conductivity(double thermal_conductivity)
   * void set_thermal_expansion(double thermal_expansion)
   * void set_wavelen_range(double low, double high)
   * void set_young_modulus(double young_modulus)

Material::Herzberger class reference
====================================

Declaration
-----------

     #include <Goptical/Material/Herzberger>

     namespace Goptical {
       namespace Material {
         class Herzberger;
       };
     };


   This class is a member of the Material namespace.

Inheritance
-----------

Description
-----------

This class models optical properties of dielectric materials with
Herzberger refractive index dispersion formula:

   n_\lambda = A + B\times\lambda^2 + C\times\lambda^4 +
D\times\lambda^6 + \frac{E}{\lambda^2-0.028} +
\frac{F}{\left(\lambda^2-0.028\right)^2}

   with \lambda the micrometer wavelength.

Members
-------

See also the full member list (*note
Material_Herzberger_class_full_member_list::) section for this class.

Inherited members
.................

   * 36 members inherited from Dielectric (*note
     Material_Dielectric_class_reference::)

Functions
.........

   * Herzberger()
   * Herzberger(double A, double B, double C, double D, double E, double
     F)
   * virtual double get_measurement_index(double wavelen) const
   * void set_coefficients(double A, double B, double C, double D,
     double E, double F)

Members detail
--------------

Herzberger()
............

Create an empty herzberger model

Herzberger(double A, double B, double C, double D, double E, double F)
......................................................................

Create an herzberger model with given coefficients

virtual double get_measurement_index(double wavelen) const
..........................................................

This virtual function implements the 'get_measurement_index (*note
_617::)' pure function declared in the 'Dielectric (*note
Material_Dielectric_class_reference::)' base abstract class.

   Documentation inherited from base class:

   Get material relative refractive index in measurment medium at
specified wavelen in _nm._

void set_coefficients(double A, double B, double C, double D, double E, double F)
.................................................................................

Change herzberger constant term

Material::Herzberger class full member list
===========================================

Functions
---------

   * Herzberger()
   * Herzberger(double A, double B, double C, double D, double E, double
     F)
   * void clear_internal_transmittance()
   * void disable_temperature_coeff()
   * double get_abbe_vd() const
   * double get_abbe_ve() const
   * virtual Io::Rgb get_color() const
   * double get_density() const
   * virtual double get_extinction_coef(double wavelen) const
   * virtual double get_internal_transmittance(double wavelen, double
     thickness) const
   * double get_internal_transmittance(double wavelen) const
   * virtual double get_measurement_index(double wavelen) const
   * virtual double get_normal_reflectance(const Base *from, double
     wavelen) const
   * virtual double get_normal_transmittance(const Base *from, double
     wavelen) const
   * double get_partial_dispersion(double wavelen1, double wavelen2)
     const
   * double get_poisson_ratio() const
   * double get_principal_dispersion() const
   * double get_refractive_index(double wavelen, const Base &env) const
   * virtual double get_refractive_index(double wavelen) const
   * virtual double get_temperature() const
   * double get_thermal_conductivity() const
   * double get_thermal_expansion() const
   * Data::DiscreteSet & get_transmittance_dataset()
   * double get_young_modulus() const
   * virtual bool is_opaque() const
   * virtual bool is_reflecting() const
   * void set_coefficients(double A, double B, double C, double D,
     double E, double F)
   * void set_density(double density)
   * void set_internal_transmittance(double wavelen, double thickness,
     double transmittance)
   * void set_measurement_medium(const const_ref<Base> &medium)
   * void set_poisson_ratio(double poisson_ratio)
   * void set_temperature(double temp)
   * void set_temperature_dndt(double dndt)
   * void set_temperature_schott(double d0, double d1, double d2, double
     e0, double e1, double wl_tk)
   * void set_thermal_conductivity(double thermal_conductivity)
   * void set_thermal_expansion(double thermal_expansion)
   * void set_wavelen_range(double low, double high)
   * void set_young_modulus(double young_modulus)

Material::Metal class reference
===============================

Declaration
-----------

     #include <Goptical/Material/Metal>

     namespace Goptical {
       namespace Material {
         class Metal;
       };
     };


   This class is a member of the Material namespace.

Inheritance
-----------

Description
-----------

This class models optical properties of metal materials.  Extinction and
refractive index are stored as interpolated data sets.

Members
-------

See also the full member list (*note
Material_Metal_class_full_member_list::) section for this class.

Inherited members
.................

   * 23 members inherited from Solid (*note
     Material_Solid_class_reference::)

Functions
.........

   * Metal()
   * double get_absolute_refractive_index(double wavelen) const
   * virtual double get_extinction_coef(double wavelen) const
   * Data::DiscreteSet & get_extinction_coef_dataset()
   * virtual double get_refractive_index(double wavelen) const
   * Data::DiscreteSet & get_refractive_index_dataset()
   * virtual bool is_opaque() const
   * virtual bool is_reflecting() const

Members detail
--------------

Metal()
.......

No documentation available

double get_absolute_refractive_index(double wavelen) const
..........................................................

No documentation available

virtual double get_extinction_coef(double wavelen) const
........................................................

This virtual function overrides the 'get_extinction_coef (*note _545::)'
virtual function defined in the 'Base (*note
Material_Base_class_reference::)' base abstract class.

   Documentation inherited from base class:

   Get extinction coefficient.  Subclasses _must_ provide this function
or the get_internal_transmittance() function.

Data::DiscreteSet & get_extinction_coef_dataset()
.................................................

Get extinction dataset object

virtual double get_refractive_index(double wavelen) const
.........................................................

This virtual function implements the 'get_refractive_index (*note
_550::)' pure function declared in the 'Base (*note
Material_Base_class_reference::)' base abstract class.

   Documentation inherited from base class:

   Get material absolute refractive index at specified wavelen in _nm._

Data::DiscreteSet & get_refractive_index_dataset()
..................................................

Get refractive index dataset object

virtual bool is_opaque() const
..............................

This virtual function implements the 'is_opaque (*note _553::)' pure
function declared in the 'Base (*note Material_Base_class_reference::)'
base abstract class.

   Documentation inherited from base class:

   Return true if material must be considered opaque for ray tracing

virtual bool is_reflecting() const
..................................

This virtual function implements the 'is_reflecting (*note _554::)' pure
function declared in the 'Base (*note Material_Base_class_reference::)'
base abstract class.

   Documentation inherited from base class:

   Return true if material may reflect most of the light and must be
considered as a mirror when ignoring ray intensity computation during
ray tracing.

Material::Metal class full member list
======================================

Functions
---------

   * Metal()
   * double get_absolute_refractive_index(double wavelen) const
   * virtual Io::Rgb get_color() const
   * double get_density() const
   * virtual double get_extinction_coef(double wavelen) const
   * Data::DiscreteSet & get_extinction_coef_dataset()
   * virtual double get_internal_transmittance(double wavelen, double
     thickness) const
   * double get_internal_transmittance(double wavelen) const
   * virtual double get_normal_reflectance(const Base *from, double
     wavelen) const
   * virtual double get_normal_transmittance(const Base *from, double
     wavelen) const
   * double get_poisson_ratio() const
   * double get_refractive_index(double wavelen, const Base &env) const
   * virtual double get_refractive_index(double wavelen) const
   * Data::DiscreteSet & get_refractive_index_dataset()
   * virtual double get_temperature() const
   * double get_thermal_conductivity() const
   * double get_thermal_expansion() const
   * double get_young_modulus() const
   * virtual bool is_opaque() const
   * virtual bool is_reflecting() const
   * void set_density(double density)
   * void set_poisson_ratio(double poisson_ratio)
   * void set_temperature(double temp)
   * void set_thermal_conductivity(double thermal_conductivity)
   * void set_thermal_expansion(double thermal_expansion)
   * void set_young_modulus(double young_modulus)

Material::Mil class reference
=============================

Declaration
-----------

     #include <Goptical/Material/Mil>

     namespace Goptical {
       namespace Material {
         class Mil;
       };
     };


   This class is a member of the Material namespace.

Inheritance
-----------

Description
-----------

This class is able to extract _nd_ index and _vd_ Abbe number values
from glass code in order to model mil glass material.  Glass code format
is described in "_MIL-G-174B_" standard.

   See also Abbe (*note Material_Abbe_class_reference::) class.

Members
-------

See also the full member list (*note
Material_Mil_class_full_member_list::) section for this class.

Inherited members
.................

   * 36 members inherited from Abbe (*note
     Material_Abbe_class_reference::)<AbbeVdFormula>

Function
........

   * Mil(unsigned int code)

Members detail
--------------

Mil(unsigned int code)
......................

Create a glass model based on glass code with "_nnnnvvv_" format.

Material::Mil class full member list
====================================

Functions
---------

   * Mil(unsigned int code)
   * void clear_internal_transmittance()
   * void disable_temperature_coeff()
   * double get_abbe_vd() const
   * double get_abbe_ve() const
   * virtual Io::Rgb get_color() const
   * double get_density() const
   * virtual double get_extinction_coef(double wavelen) const
   * virtual double get_internal_transmittance(double wavelen, double
     thickness) const
   * double get_internal_transmittance(double wavelen) const
   * virtual double get_measurement_index(double wavelen) const
   * virtual double get_normal_reflectance(const Base *from, double
     wavelen) const
   * virtual double get_normal_transmittance(const Base *from, double
     wavelen) const
   * double get_partial_dispersion(double wavelen1, double wavelen2)
     const
   * double get_poisson_ratio() const
   * double get_principal_dispersion() const
   * double get_refractive_index(double wavelen, const Base &env) const
   * virtual double get_refractive_index(double wavelen) const
   * virtual double get_temperature() const
   * double get_thermal_conductivity() const
   * double get_thermal_expansion() const
   * Data::DiscreteSet & get_transmittance_dataset()
   * double get_young_modulus() const
   * virtual bool is_opaque() const
   * virtual bool is_reflecting() const
   * void set_density(double density)
   * void set_internal_transmittance(double wavelen, double thickness,
     double transmittance)
   * void set_measurement_medium(const const_ref<Base> &medium)
   * void set_poisson_ratio(double poisson_ratio)
   * void set_temperature(double temp)
   * void set_temperature_dndt(double dndt)
   * void set_temperature_schott(double d0, double d1, double d2, double
     e0, double e1, double wl_tk)
   * void set_thermal_conductivity(double thermal_conductivity)
   * void set_thermal_expansion(double thermal_expansion)
   * void set_wavelen_range(double low, double high)
   * void set_young_modulus(double young_modulus)

Material::Mirror class reference
================================

Declaration
-----------

     #include <Goptical/Material/Mirror>

     namespace Goptical {
       namespace Material {
         class Mirror;
       };
     };


   This class is a member of the Material namespace.

Inheritance
-----------

Description
-----------

This class models optical properties of a perfect reflecting material.

   A global mirror (*note _527::) variable is available.

Members
-------

See also the full member list (*note
Material_Mirror_class_full_member_list::) section for this class.

Inherited members
.................

   * 14 members inherited from Base (*note
     Material_Base_class_reference::)

Functions
.........

   * Mirror()
   * virtual double get_extinction_coef(double wavelen) const
   * virtual double get_internal_transmittance(double wavelen, double
     thickness) const
   * virtual double get_refractive_index(double wavelen) const
   * virtual bool is_opaque() const
   * virtual bool is_reflecting() const

Members detail
--------------

Mirror()
........

No documentation available

virtual double get_extinction_coef(double wavelen) const
........................................................

This virtual function overrides the 'get_extinction_coef (*note _545::)'
virtual function defined in the 'Base (*note
Material_Base_class_reference::)' base abstract class.

   Documentation inherited from base class:

   Get extinction coefficient.  Subclasses _must_ provide this function
or the get_internal_transmittance() function.

virtual double get_internal_transmittance(double wavelen, double thickness) const
.................................................................................

This virtual function overrides the 'get_internal_transmittance (*note
_546::)' virtual function defined in the 'Base (*note
Material_Base_class_reference::)' base abstract class.

   Documentation inherited from base class:

   Get material internal transmittance for thickness in mm.  Subclasses
_must_ provide this function or the get_extinction_coef() function.

virtual double get_refractive_index(double wavelen) const
.........................................................

This virtual function implements the 'get_refractive_index (*note
_550::)' pure function declared in the 'Base (*note
Material_Base_class_reference::)' base abstract class.

   Documentation inherited from base class:

   Get material absolute refractive index at specified wavelen in _nm._

virtual bool is_opaque() const
..............................

This virtual function implements the 'is_opaque (*note _553::)' pure
function declared in the 'Base (*note Material_Base_class_reference::)'
base abstract class.

   Documentation inherited from base class:

   Return true if material must be considered opaque for ray tracing

virtual bool is_reflecting() const
..................................

This virtual function implements the 'is_reflecting (*note _554::)' pure
function declared in the 'Base (*note Material_Base_class_reference::)'
base abstract class.

   Documentation inherited from base class:

   Return true if material may reflect most of the light and must be
considered as a mirror when ignoring ray intensity computation during
ray tracing.

Material::Mirror class full member list
=======================================

Functions
---------

   * Mirror()
   * virtual Io::Rgb get_color() const
   * virtual double get_extinction_coef(double wavelen) const
   * double get_internal_transmittance(double wavelen) const
   * virtual double get_internal_transmittance(double wavelen, double
     thickness) const
   * virtual double get_normal_reflectance(const Base *from, double
     wavelen) const
   * virtual double get_normal_transmittance(const Base *from, double
     wavelen) const
   * double get_refractive_index(double wavelen, const Base &env) const
   * virtual double get_refractive_index(double wavelen) const
   * virtual double get_temperature() const
   * virtual bool is_opaque() const
   * virtual bool is_reflecting() const
   * void set_temperature(double temp)

Material::Schott class reference
================================

Declaration
-----------

     #include <Goptical/Material/Schott>

     namespace Goptical {
       namespace Material {
         class Schott;
       };
     };


   This class is a member of the Material namespace.

Inheritance
-----------

Description
-----------

This class models optical properties of dielectric materials with Schott
refractive index dispersion formula:

   n_\lambda = \sqrt{ \sum\limits_{i} A_{i}\times\lambda^{2i}}

   with \lambda the micrometer wavelength.

Members
-------

See also the full member list (*note
Material_Schott_class_full_member_list::) section for this class.

Inherited members
.................

   * 36 members inherited from Dielectric (*note
     Material_Dielectric_class_reference::)

Functions
.........

   * Schott()
   * Schott(double A, double B, double C, double D, double E, double F)
   * void set_term(int term, double K)
   * void set_terms_range(int first, int last)

Members detail
--------------

Schott()
........

Create an empty schott model

Schott(double A, double B, double C, double D, double E, double F)
..................................................................

Create a schott model with [-8,2] exponents range:

   n_\lambda = \sqrt{ A + B\times\lambda^2 + \frac{C}{\lambda^2} +
\frac{D}{\lambda^4} + \frac{E}{\lambda^6} + \frac{F}{\lambda^8}}

void set_term(int term, double K)
.................................

Set term coefficient, 'term' must be a multiple of 2.

void set_terms_range(int first, int last)
.........................................

Set exponents range, must be multiples of 2

Material::Schott class full member list
=======================================

Functions
---------

   * Schott()
   * Schott(double A, double B, double C, double D, double E, double F)
   * void clear_internal_transmittance()
   * void disable_temperature_coeff()
   * double get_abbe_vd() const
   * double get_abbe_ve() const
   * virtual Io::Rgb get_color() const
   * double get_density() const
   * virtual double get_extinction_coef(double wavelen) const
   * virtual double get_internal_transmittance(double wavelen, double
     thickness) const
   * double get_internal_transmittance(double wavelen) const
   * virtual double get_normal_reflectance(const Base *from, double
     wavelen) const
   * virtual double get_normal_transmittance(const Base *from, double
     wavelen) const
   * double get_partial_dispersion(double wavelen1, double wavelen2)
     const
   * double get_poisson_ratio() const
   * double get_principal_dispersion() const
   * double get_refractive_index(double wavelen, const Base &env) const
   * virtual double get_refractive_index(double wavelen) const
   * virtual double get_temperature() const
   * double get_thermal_conductivity() const
   * double get_thermal_expansion() const
   * Data::DiscreteSet & get_transmittance_dataset()
   * double get_young_modulus() const
   * virtual bool is_opaque() const
   * virtual bool is_reflecting() const
   * void set_density(double density)
   * void set_internal_transmittance(double wavelen, double thickness,
     double transmittance)
   * void set_measurement_medium(const const_ref<Base> &medium)
   * void set_poisson_ratio(double poisson_ratio)
   * void set_temperature(double temp)
   * void set_temperature_dndt(double dndt)
   * void set_temperature_schott(double d0, double d1, double d2, double
     e0, double e1, double wl_tk)
   * void set_term(int term, double K)
   * void set_terms_range(int first, int last)
   * void set_thermal_conductivity(double thermal_conductivity)
   * void set_thermal_expansion(double thermal_expansion)
   * void set_wavelen_range(double low, double high)
   * void set_young_modulus(double young_modulus)

Material::Sellmeier class reference
===================================

Declaration
-----------

     #include <Goptical/Material/Sellmeier>

     namespace Goptical {
       namespace Material {
         class Sellmeier;
       };
     };


   This class is a member of the Material namespace.

Inheritance
-----------

Description
-----------

This class models optical properties of dielectric materials using
Sellmeier refractive index dispersion formula:

   n_\lambda = \sqrt{ A + \sum\limits_{i}^{} \frac{B_i \times
\lambda^2}{\lambda^2 - C_i}}

   with \lambda the micrometer wavelength.

   See also SellmeierMod (*note Material_SellmeierMod_class_reference::)
class.

Members
-------

See also the full member list (*note
Material_Sellmeier_class_full_member_list::) section for this class.

Inherited members
.................

   * 36 members inherited from Dielectric (*note
     Material_Dielectric_class_reference::)

Functions
.........

   * Sellmeier()
   * Sellmeier(double K1, double L1, double K2, double L2, double K3,
     double L3)
   * virtual double get_measurement_index(double wavelen) const
   * void set_contant_term(double A)
   * void set_term(unsigned int i, double B, double C)
   * void set_terms_count(unsigned int c)

Members detail
--------------

Sellmeier()
...........

Create an empty sellmeier model

Sellmeier(double K1, double L1, double K2, double L2, double K3, double L3)
...........................................................................

Create an 3rd order sellmeier model with given coefficients and 1.0
constant

virtual double get_measurement_index(double wavelen) const
..........................................................

This virtual function implements the 'get_measurement_index (*note
_617::)' pure function declared in the 'Dielectric (*note
Material_Dielectric_class_reference::)' base abstract class.

   Documentation inherited from base class:

   Get material relative refractive index in measurment medium at
specified wavelen in _nm._

void set_contant_term(double A)
...............................

Change sellmeier constant term

void set_term(unsigned int i, double B, double C)
.................................................

Set term coefficients

void set_terms_count(unsigned int c)
....................................

Set terms count

Material::Sellmeier class full member list
==========================================

Functions
---------

   * Sellmeier()
   * Sellmeier(double K1, double L1, double K2, double L2, double K3,
     double L3)
   * void clear_internal_transmittance()
   * void disable_temperature_coeff()
   * double get_abbe_vd() const
   * double get_abbe_ve() const
   * virtual Io::Rgb get_color() const
   * double get_density() const
   * virtual double get_extinction_coef(double wavelen) const
   * virtual double get_internal_transmittance(double wavelen, double
     thickness) const
   * double get_internal_transmittance(double wavelen) const
   * virtual double get_measurement_index(double wavelen) const
   * virtual double get_normal_reflectance(const Base *from, double
     wavelen) const
   * virtual double get_normal_transmittance(const Base *from, double
     wavelen) const
   * double get_partial_dispersion(double wavelen1, double wavelen2)
     const
   * double get_poisson_ratio() const
   * double get_principal_dispersion() const
   * double get_refractive_index(double wavelen, const Base &env) const
   * virtual double get_refractive_index(double wavelen) const
   * virtual double get_temperature() const
   * double get_thermal_conductivity() const
   * double get_thermal_expansion() const
   * Data::DiscreteSet & get_transmittance_dataset()
   * double get_young_modulus() const
   * virtual bool is_opaque() const
   * virtual bool is_reflecting() const
   * void set_contant_term(double A)
   * void set_density(double density)
   * void set_internal_transmittance(double wavelen, double thickness,
     double transmittance)
   * void set_measurement_medium(const const_ref<Base> &medium)
   * void set_poisson_ratio(double poisson_ratio)
   * void set_temperature(double temp)
   * void set_temperature_dndt(double dndt)
   * void set_temperature_schott(double d0, double d1, double d2, double
     e0, double e1, double wl_tk)
   * void set_term(unsigned int i, double B, double C)
   * void set_terms_count(unsigned int c)
   * void set_thermal_conductivity(double thermal_conductivity)
   * void set_thermal_expansion(double thermal_expansion)
   * void set_wavelen_range(double low, double high)
   * void set_young_modulus(double young_modulus)

Material::SellmeierMod class reference
======================================

Declaration
-----------

     #include <Goptical/Material/SellmeierMod>

     namespace Goptical {
       namespace Material {
         template <enum SellmeierModFormula m> class SellmeierMod;
       };
     };


   This class is a member of the Material namespace.

Inheritance
-----------

Description
-----------

This class models optical properties of dielectric materials with
various modified Sellmeier formulas:

   * SellmeierMod2 (*note _524::) : n_\lambda = \sqrt{A +
     \frac{B\times\lambda^2}{\lambda^2 - C^2} + \frac{D}{\lambda^2 -
     E^2}}

   * Handbook1 (*note _522::) : n_\lambda = \sqrt{A + B\times\lambda^2 +
     \frac{C}{\lambda^2-D}}

   * Handbook2 (*note _523::) : n_\lambda = \sqrt{A + B\times\lambda^2 +
     \frac{C\times\lambda^2}{\lambda^2-D}}

   with \lambda the micrometer wavelength.

   See also Sellmeier (*note Material_Sellmeier_class_reference::)
class.

Members
-------

See also the full member list (*note
Material_SellmeierMod_class_full_member_list::) section for this class.

Inherited members
.................

   * 36 members inherited from Dielectric (*note
     Material_Dielectric_class_reference::)

Functions
.........

   * SellmeierMod()
   * SellmeierMod(double A, double B, double C, double D, double E =
     _[...]_)
   * virtual double get_measurement_index(double wavelen) const
   * void set_coefficients(double A, double B, double C, double D,
     double E = _[...]_)

Members detail
--------------

SellmeierMod()
..............

Create an empty modified sellmeier model

SellmeierMod(double A, double B, double C, double D, double E = 0.0)
....................................................................

Create a modified sellmeier model with given coefficients

virtual double get_measurement_index(double wavelen) const
..........................................................

This virtual function implements the 'get_measurement_index (*note
_617::)' pure function declared in the 'Dielectric (*note
Material_Dielectric_class_reference::)' base abstract class.

   Documentation inherited from base class:

   Get material relative refractive index in measurment medium at
specified wavelen in _nm._

void set_coefficients(double A, double B, double C, double D, double E = 0.0)
.............................................................................

Change coefficients

Material::SellmeierMod class full member list
=============================================

Functions
---------

   * SellmeierMod()
   * SellmeierMod(double A, double B, double C, double D, double E =
     _[...]_)
   * void clear_internal_transmittance()
   * void disable_temperature_coeff()
   * double get_abbe_vd() const
   * double get_abbe_ve() const
   * virtual Io::Rgb get_color() const
   * double get_density() const
   * virtual double get_extinction_coef(double wavelen) const
   * virtual double get_internal_transmittance(double wavelen, double
     thickness) const
   * double get_internal_transmittance(double wavelen) const
   * virtual double get_measurement_index(double wavelen) const
   * virtual double get_normal_reflectance(const Base *from, double
     wavelen) const
   * virtual double get_normal_transmittance(const Base *from, double
     wavelen) const
   * double get_partial_dispersion(double wavelen1, double wavelen2)
     const
   * double get_poisson_ratio() const
   * double get_principal_dispersion() const
   * double get_refractive_index(double wavelen, const Base &env) const
   * virtual double get_refractive_index(double wavelen) const
   * virtual double get_temperature() const
   * double get_thermal_conductivity() const
   * double get_thermal_expansion() const
   * Data::DiscreteSet & get_transmittance_dataset()
   * double get_young_modulus() const
   * virtual bool is_opaque() const
   * virtual bool is_reflecting() const
   * void set_coefficients(double A, double B, double C, double D,
     double E = _[...]_)
   * void set_density(double density)
   * void set_internal_transmittance(double wavelen, double thickness,
     double transmittance)
   * void set_measurement_medium(const const_ref<Base> &medium)
   * void set_poisson_ratio(double poisson_ratio)
   * void set_temperature(double temp)
   * void set_temperature_dndt(double dndt)
   * void set_temperature_schott(double d0, double d1, double d2, double
     e0, double e1, double wl_tk)
   * void set_thermal_conductivity(double thermal_conductivity)
   * void set_thermal_expansion(double thermal_expansion)
   * void set_wavelen_range(double low, double high)
   * void set_young_modulus(double young_modulus)

Material::Vacuum class reference
================================

Declaration
-----------

     #include <Goptical/Material/Vacuum>

     namespace Goptical {
       namespace Material {
         class Vacuum;
       };
     };


   This class is a member of the Material namespace.

Inheritance
-----------

Description
-----------

This class models optical properties of vacuum.  A global variable
vacuum (*note _530::) is available.

Members
-------

See also the full member list (*note
Material_Vacuum_class_full_member_list::) section for this class.

Inherited members
.................

   * 14 members inherited from Base (*note
     Material_Base_class_reference::)

Functions
.........

   * Vacuum()
   * virtual double get_extinction_coef(double wavelen) const
   * virtual double get_internal_transmittance(double wavelen, double
     thickness) const
   * virtual double get_refractive_index(double wavelen) const
   * virtual bool is_opaque() const
   * virtual bool is_reflecting() const

Members detail
--------------

Vacuum()
........

No documentation available

virtual double get_extinction_coef(double wavelen) const
........................................................

This virtual function overrides the 'get_extinction_coef (*note _545::)'
virtual function defined in the 'Base (*note
Material_Base_class_reference::)' base abstract class.

   Documentation inherited from base class:

   Get extinction coefficient.  Subclasses _must_ provide this function
or the get_internal_transmittance() function.

virtual double get_internal_transmittance(double wavelen, double thickness) const
.................................................................................

This virtual function overrides the 'get_internal_transmittance (*note
_546::)' virtual function defined in the 'Base (*note
Material_Base_class_reference::)' base abstract class.

   Documentation inherited from base class:

   Get material internal transmittance for thickness in mm.  Subclasses
_must_ provide this function or the get_extinction_coef() function.

virtual double get_refractive_index(double wavelen) const
.........................................................

This virtual function implements the 'get_refractive_index (*note
_550::)' pure function declared in the 'Base (*note
Material_Base_class_reference::)' base abstract class.

   Documentation inherited from base class:

   Get material absolute refractive index at specified wavelen in _nm._

virtual bool is_opaque() const
..............................

This virtual function implements the 'is_opaque (*note _553::)' pure
function declared in the 'Base (*note Material_Base_class_reference::)'
base abstract class.

   Documentation inherited from base class:

   Return true if material must be considered opaque for ray tracing

virtual bool is_reflecting() const
..................................

This virtual function implements the 'is_reflecting (*note _554::)' pure
function declared in the 'Base (*note Material_Base_class_reference::)'
base abstract class.

   Documentation inherited from base class:

   Return true if material may reflect most of the light and must be
considered as a mirror when ignoring ray intensity computation during
ray tracing.

Material::Vacuum class full member list
=======================================

Functions
---------

   * Vacuum()
   * virtual Io::Rgb get_color() const
   * virtual double get_extinction_coef(double wavelen) const
   * double get_internal_transmittance(double wavelen) const
   * virtual double get_internal_transmittance(double wavelen, double
     thickness) const
   * virtual double get_normal_reflectance(const Base *from, double
     wavelen) const
   * virtual double get_normal_transmittance(const Base *from, double
     wavelen) const
   * double get_refractive_index(double wavelen, const Base &env) const
   * virtual double get_refractive_index(double wavelen) const
   * virtual double get_temperature() const
   * virtual bool is_opaque() const
   * virtual bool is_reflecting() const
   * void set_temperature(double temp)

Material::Dielectric class reference
====================================

Declaration
-----------

     #include <Goptical/Material/Dielectric>

     namespace Goptical {
       namespace Material {
         class Dielectric;
       };
     };


   This class is a member of the Material namespace.

   This abstract class contains pure virtuals.

Inheritance
-----------

Description
-----------

This class models optical properties of dielectric materials.
Transmittance values are stored in an Data::Set (*note
Data_Set_class_reference::) object with Data::Cubic (*note _146::)
interpolation enabled.

   Child class has to implement the get_measurement_index (*note _617::)
function which must return relative refractive index as measured in
medium material set by set_measurement_medium (*note _625::) function.
Default measurement medium is std_air (*note _529::).

   The relative refractive index together with the absolute refractive
index of measurement medium are used to compute absolute refractive
index of dielectric material at reference temperature.  This is the
value returned by the get_refractive_index (*note _620::) function when
no temperature model is in use.

   Temperature coeffiecients can be defined to take current material
temperature into account when computing absolute refractive index:

   * The set_temperature_dndt (*note _626::) function enables use of
     refractive index temperature deviation factor.

   * The set_temperature_schott (*note _627::) function enables Schott
     temperature model as described in Schott "_TIE-19: Temperature
     Coefficient of the Refractive Index_" technical information
     document.  It uses the following formula:

     n_t = \frac{{n}^{2}-1.0}{2\times n} \times \Delta t \times \left(
     \frac{\Delta t\times E_1+E_0}{{\lambda}^{2}-{\lambda_{tk}}^{2}} +
     D_2\times {\Delta t}^{2}+D_1\times \Delta t+D_0 \right)

     with \Delta t = t - t_{ref} and \lambda the micrometer wavelength.

Members
-------

See also the full member list (*note
Material_Dielectric_class_full_member_list::) section for this class.

Inherited members
.................

   * 23 members inherited from Solid (*note
     Material_Solid_class_reference::)

Functions
.........

   * Dielectric()
   * void clear_internal_transmittance()
   * void disable_temperature_coeff()
   * double get_abbe_vd() const
   * double get_abbe_ve() const
   * virtual double get_internal_transmittance(double wavelen, double
     thickness) const
   * double get_internal_transmittance(double wavelen) const
   * virtual double get_measurement_index(double wavelen) const = 0;
   * double get_partial_dispersion(double wavelen1, double wavelen2)
     const
   * double get_principal_dispersion() const
   * virtual double get_refractive_index(double wavelen) const
   * Data::DiscreteSet & get_transmittance_dataset()
   * virtual bool is_opaque() const
   * virtual bool is_reflecting() const
   * void set_internal_transmittance(double wavelen, double thickness,
     double transmittance)
   * void set_measurement_medium(const const_ref<Base> &medium)
   * void set_temperature_dndt(double dndt)
   * void set_temperature_schott(double d0, double d1, double d2, double
     e0, double e1, double wl_tk)
   * void set_wavelen_range(double low, double high)

Members detail
--------------

Dielectric()
............

No documentation available

void clear_internal_transmittance()
...................................

Clear all transmittance data.  Returned transmittance value is always
1.0 when the data set is empty.

   See also get_transmittance_dataset (*note _621::) function.

void disable_temperature_coeff()
................................

Disable use of temperature coefficients

double get_abbe_vd() const
..........................

Compute glass Abbe number from refractive index model.  Use d spectral
line.  Wavelen is in _nm_

double get_abbe_ve() const
..........................

Compute glass Abbe number from refractive index model.  Use d spectral
line.  Wavelen is in _nm_

virtual double get_internal_transmittance(double wavelen, double thickness) const
.................................................................................

This virtual function overrides the 'get_internal_transmittance (*note
_546::)' virtual function defined in the 'Base (*note
Material_Base_class_reference::)' base abstract class.

   Documentation inherited from base class:

   Get material internal transmittance for thickness in mm.  Subclasses
_must_ provide this function or the get_extinction_coef() function.

double get_internal_transmittance(double wavelen) const
.......................................................

This function shadows the 'get_internal_transmittance (*note _547::)'
function defined in the 'Base (*note Material_Base_class_reference::)'
base abstract class.

   Documentation inherited from base class:

   Get material internal transmittance for 1mm thickness.

virtual double get_measurement_index(double wavelen) const = 0;
...............................................................

Get material relative refractive index in measurment medium at specified
wavelen in _nm._

double get_partial_dispersion(double wavelen1, double wavelen2) const
.....................................................................

Compute glass partial dispersion between two wavelen in _nm_

double get_principal_dispersion() const
.......................................

Compute glass principal dispersion.

virtual double get_refractive_index(double wavelen) const
.........................................................

This virtual function implements the 'get_refractive_index (*note
_550::)' pure function declared in the 'Base (*note
Material_Base_class_reference::)' base abstract class.

   Documentation inherited from base class:

   Get material absolute refractive index at specified wavelen in _nm._

Data::DiscreteSet & get_transmittance_dataset()
...............................................

Get internal tranmittance dataset object.

   See also clear_internal_transmittance (*note _611::) function.

virtual bool is_opaque() const
..............................

This virtual function implements the 'is_opaque (*note _553::)' pure
function declared in the 'Base (*note Material_Base_class_reference::)'
base abstract class.

   Documentation inherited from base class:

   Return true if material must be considered opaque for ray tracing

virtual bool is_reflecting() const
..................................

This virtual function implements the 'is_reflecting (*note _554::)' pure
function declared in the 'Base (*note Material_Base_class_reference::)'
base abstract class.

   Documentation inherited from base class:

   Return true if material may reflect most of the light and must be
considered as a mirror when ignoring ray intensity computation during
ray tracing.

void set_internal_transmittance(double wavelen, double thickness, double transmittance)
.......................................................................................

Add transmittance data, wavelen in nm

void set_measurement_medium(const const_ref <Base> &medium)
...........................................................

Set glass measurement medium material.

void set_temperature_dndt(double dndt)
......................................

Set and enable dn/dt thermal coefficient.

void set_temperature_schott(double d0, double d1, double d2, double e0, double e1, double wl_tk)
................................................................................................

Set and enable Schott thermal coefficients.  wl_tk in _um._

void set_wavelen_range(double low, double high)
...............................................

Set wavelen validity range in _nm_

Material::Dielectric class full member list
===========================================

Functions
---------

   * Dielectric()
   * void clear_internal_transmittance()
   * void disable_temperature_coeff()
   * double get_abbe_vd() const
   * double get_abbe_ve() const
   * virtual Io::Rgb get_color() const
   * double get_density() const
   * virtual double get_extinction_coef(double wavelen) const
   * virtual double get_internal_transmittance(double wavelen, double
     thickness) const
   * double get_internal_transmittance(double wavelen) const
   * virtual double get_measurement_index(double wavelen) const = 0;
   * virtual double get_normal_reflectance(const Base *from, double
     wavelen) const
   * virtual double get_normal_transmittance(const Base *from, double
     wavelen) const
   * double get_partial_dispersion(double wavelen1, double wavelen2)
     const
   * double get_poisson_ratio() const
   * double get_principal_dispersion() const
   * double get_refractive_index(double wavelen, const Base &env) const
   * virtual double get_refractive_index(double wavelen) const
   * virtual double get_temperature() const
   * double get_thermal_conductivity() const
   * double get_thermal_expansion() const
   * Data::DiscreteSet & get_transmittance_dataset()
   * double get_young_modulus() const
   * virtual bool is_opaque() const
   * virtual bool is_reflecting() const
   * void set_density(double density)
   * void set_internal_transmittance(double wavelen, double thickness,
     double transmittance)
   * void set_measurement_medium(const const_ref<Base> &medium)
   * void set_poisson_ratio(double poisson_ratio)
   * void set_temperature(double temp)
   * void set_temperature_dndt(double dndt)
   * void set_temperature_schott(double d0, double d1, double d2, double
     e0, double e1, double wl_tk)
   * void set_thermal_conductivity(double thermal_conductivity)
   * void set_thermal_expansion(double thermal_expansion)
   * void set_wavelen_range(double low, double high)
   * void set_young_modulus(double young_modulus)

Material::Proxy class reference
===============================

Declaration
-----------

     #include <Goptical/Material/Proxy>

     namespace Goptical {
       namespace Material {
         class Proxy;
       };
     };


   This class is a member of the Material namespace.

Inheritance
-----------

Description
-----------

Optical material proxy class.

Members
-------

See also the full member list (*note
Material_Proxy_class_full_member_list::) section for this class.

Inherited members
.................

   * 14 members inherited from Base (*note
     Material_Base_class_reference::)

Functions
.........

   * Proxy(const const_ref<Base> &m)
   * virtual Io::Rgb get_color() const
   * virtual double get_extinction_coef(double wavelen) const
   * virtual double get_internal_transmittance(double wavelen, double
     thickness) const
   * const Base & get_material() const
   * virtual double get_normal_reflectance(const Base *from, double
     wavelen) const
   * virtual double get_normal_transmittance(const Base *from, double
     wavelen) const
   * virtual double get_refractive_index(double wavelen) const
   * virtual double get_temperature() const
   * virtual bool is_opaque() const
   * virtual bool is_reflecting() const
   * void set_material(const const_ref<Base> &m)

Members detail
--------------

Proxy(const const_ref <Base> &m)
................................

No documentation available

virtual Io::Rgb get_color() const
.................................

This virtual function overrides the 'get_color (*note _544::)' virtual
function defined in the 'Base (*note Material_Base_class_reference::)'
base abstract class.

   Documentation inherited from base class:

   Get material color and alpha

virtual double get_extinction_coef(double wavelen) const
........................................................

This virtual function overrides the 'get_extinction_coef (*note _545::)'
virtual function defined in the 'Base (*note
Material_Base_class_reference::)' base abstract class.

   Documentation inherited from base class:

   Get extinction coefficient.  Subclasses _must_ provide this function
or the get_internal_transmittance() function.

virtual double get_internal_transmittance(double wavelen, double thickness) const
.................................................................................

This virtual function overrides the 'get_internal_transmittance (*note
_546::)' virtual function defined in the 'Base (*note
Material_Base_class_reference::)' base abstract class.

   Documentation inherited from base class:

   Get material internal transmittance for thickness in mm.  Subclasses
_must_ provide this function or the get_extinction_coef() function.

const Base & get_material() const
.................................

No documentation available

virtual double get_normal_reflectance(const Base *from, double wavelen) const
.............................................................................

This virtual function overrides the 'get_normal_reflectance (*note
_548::)' virtual function defined in the 'Base (*note
Material_Base_class_reference::)' base abstract class.

   Documentation inherited from base class:

   Get reflectance at normal incidence

virtual double get_normal_transmittance(const Base *from, double wavelen) const
...............................................................................

This virtual function overrides the 'get_normal_transmittance (*note
_549::)' virtual function defined in the 'Base (*note
Material_Base_class_reference::)' base abstract class.

   Documentation inherited from base class:

   Get transmittance at normal incidence

virtual double get_refractive_index(double wavelen) const
.........................................................

This virtual function implements the 'get_refractive_index (*note
_550::)' pure function declared in the 'Base (*note
Material_Base_class_reference::)' base abstract class.

   Documentation inherited from base class:

   Get material absolute refractive index at specified wavelen in _nm._

virtual double get_temperature() const
......................................

This virtual function overrides the 'get_temperature (*note _552::)'
virtual function defined in the 'Base (*note
Material_Base_class_reference::)' base abstract class.

   Documentation inherited from base class:

   Get material temperature in celcius

virtual bool is_opaque() const
..............................

This virtual function implements the 'is_opaque (*note _553::)' pure
function declared in the 'Base (*note Material_Base_class_reference::)'
base abstract class.

   Documentation inherited from base class:

   Return true if material must be considered opaque for ray tracing

virtual bool is_reflecting() const
..................................

This virtual function implements the 'is_reflecting (*note _554::)' pure
function declared in the 'Base (*note Material_Base_class_reference::)'
base abstract class.

   Documentation inherited from base class:

   Return true if material may reflect most of the light and must be
considered as a mirror when ignoring ray intensity computation during
ray tracing.

void set_material(const const_ref <Base> &m)
............................................

No documentation available

Material::Proxy class full member list
======================================

Functions
---------

   * Proxy(const const_ref<Base> &m)
   * virtual Io::Rgb get_color() const
   * virtual double get_extinction_coef(double wavelen) const
   * double get_internal_transmittance(double wavelen) const
   * virtual double get_internal_transmittance(double wavelen, double
     thickness) const
   * const Base & get_material() const
   * virtual double get_normal_reflectance(const Base *from, double
     wavelen) const
   * virtual double get_normal_transmittance(const Base *from, double
     wavelen) const
   * double get_refractive_index(double wavelen, const Base &env) const
   * virtual double get_refractive_index(double wavelen) const
   * virtual double get_temperature() const
   * virtual bool is_opaque() const
   * virtual bool is_reflecting() const
   * void set_material(const const_ref<Base> &m)
   * void set_temperature(double temp)

Material::Solid class reference
===============================

Declaration
-----------

     #include <Goptical/Material/Solid>

     namespace Goptical {
       namespace Material {
         class Solid;
       };
     };


   This class is a member of the Material namespace.

Inheritance
-----------

Description
-----------

This class is the base class for all solid material models.

Members
-------

See also the full member list (*note
Material_Solid_class_full_member_list::) section for this class.

Inherited members
.................

   * 14 members inherited from Base (*note
     Material_Base_class_reference::)

Functions
.........

   * Solid()
   * double get_density() const
   * double get_poisson_ratio() const
   * double get_thermal_conductivity() const
   * double get_thermal_expansion() const
   * double get_young_modulus() const
   * void set_density(double density)
   * void set_poisson_ratio(double poisson_ratio)
   * void set_thermal_conductivity(double thermal_conductivity)
   * void set_thermal_expansion(double thermal_expansion)
   * void set_young_modulus(double young_modulus)

Members detail
--------------

Solid()
.......

No documentation available

double get_density() const
..........................

Get material density in g/cm^3.

   See also set_density (*note _647::) function.

double get_poisson_ratio() const
................................

Get material poisson ratio.

   See also set_poisson_ratio (*note _648::) function.

double get_thermal_conductivity() const
.......................................

Get Set material thermal conductivity in W/m.K.

   See also set_thermal_conductivity (*note _649::) function.

double get_thermal_expansion() const
....................................

Get material thermal expansion coefficient.

   See also set_thermal_expansion (*note _650::) function.

double get_young_modulus() const
................................

Get material young modulus.

   See also set_young_modulus (*note _651::) function.

void set_density(double density)
................................

Set material density in g/cm^3.

   See also get_density (*note _642::) function.

void set_poisson_ratio(double poisson_ratio)
............................................

Set material poisson ratio.

   See also get_poisson_ratio (*note _643::) function.

void set_thermal_conductivity(double thermal_conductivity)
..........................................................

Set Set material thermal conductivity in W/m.K.

   See also get_thermal_conductivity (*note _644::) function.

void set_thermal_expansion(double thermal_expansion)
....................................................

Set material thermal expansion coefficient.

   See also get_thermal_expansion (*note _645::) function.

void set_young_modulus(double young_modulus)
............................................

Set material young modulus.

   See also get_young_modulus (*note _646::) function.

Material::Solid class full member list
======================================

Functions
---------

   * Solid()
   * virtual Io::Rgb get_color() const
   * double get_density() const
   * virtual double get_extinction_coef(double wavelen) const
   * virtual double get_internal_transmittance(double wavelen, double
     thickness) const
   * double get_internal_transmittance(double wavelen) const
   * virtual double get_normal_reflectance(const Base *from, double
     wavelen) const
   * virtual double get_normal_transmittance(const Base *from, double
     wavelen) const
   * double get_poisson_ratio() const
   * virtual double get_refractive_index(double wavelen) const = 0;
   * double get_refractive_index(double wavelen, const Base &env) const
   * virtual double get_temperature() const
   * double get_thermal_conductivity() const
   * double get_thermal_expansion() const
   * double get_young_modulus() const
   * virtual bool is_opaque() const = 0;
   * virtual bool is_reflecting() const = 0;
   * void set_density(double density)
   * void set_poisson_ratio(double poisson_ratio)
   * void set_temperature(double temp)
   * void set_thermal_conductivity(double thermal_conductivity)
   * void set_thermal_expansion(double thermal_expansion)
   * void set_young_modulus(double young_modulus)

Math namespace reference
========================

Description
-----------

Mathematical tools and functions

Members
-------

Types
.....

   * typedef _ [...]  _ Vector2
   * typedef _ [...]  _ Vector3
   * typedef _ [...]  _ VectorPair3
   * template struct Matrix
   * typedef _ [...]  _ Matrix3x3
   * class Quaternion
   * template class Transform<3>
   * template class Transform<2>
   * typedef _ [...]  _ Transform2
   * typedef _ [...]  _ Transform3
   * template struct Triangle
   * template struct Triangle<3>
   * template struct Vector
   * template struct Vector<3, T>
   * template struct Vector<2, T>
   * template struct VectorPair
   * template struct VectorPair<2>
   * template struct VectorPair<3>
   * typedef _ [...]  _ VectorPair2
   * typedef _ [...]  _ range_t

Functions
.........

   * double degree2rad(double x)
   * void get_rotation_matrix(Matrix<2> &m, unsigned int axis, double
     rangle)
   * void get_rotation_matrix(Matrix<3> &m, unsigned int axis, double
     rangle)
   * double lp_floor(double x, double n)
   * double lp_mod(double x, double n)
   * template std::ostream & operator<<(std::ostream &o, const
     VectorBase<N, T> &v)
   * template std::ostream & operator<<(std::ostream &o, const
     VectorPairBase<N> &l)
   * template std::ostream & operator<<(std::ostream &o, const Matrix<N>
     &m)
   * std::ostream & operator<<(std::ostream &o, const Quaternion &q)
   * template std::ostream & operator<<(std::ostream &o, const
     TransformBase<N> &t)
   * template std::ostream & operator<<(std::ostream &o, const
     Triangle<N> &l)
   * double rad2degree(double x)
   * double square(double x)

Constants
.........

   * const Vector2 vector2_0
   * const Vector2 vector2_01
   * const Vector2 vector2_1
   * const Vector2 vector2_10
   * const VectorPair<2> vector2_pair_00
   * const VectorPair<2> vector2_pair_01
   * const Vector3 vector3_0
   * const Vector3 vector3_001
   * const Vector3 vector3_010
   * const Vector3 vector3_1
   * const Vector3 vector3_100
   * const VectorPair<3> vector3_pair_00
   * const VectorPair<3> vector3_pair_01

Members detail
--------------

typedef Vector<2, double> Vector2
.................................

See Vector (*note Math_Vector_2_T_struct_reference::)<2, T> struct.

typedef Vector<3, double> Vector3
.................................

See Vector (*note Math_Vector_3_T_struct_reference::)<3, T> struct.

typedef VectorPair<3> VectorPair3
.................................

See VectorPair (*note Math_VectorPair_3_struct_reference::)<3> struct.

typedef Matrix<3> Matrix3x3
...........................

No documentation available

typedef Transform<2> Transform2
...............................

See Transform (*note Math_Transform_2_class_reference::)<2> class.

typedef Transform<3> Transform3
...............................

See Transform (*note Math_Transform_3_class_reference::)<3> class.

typedef VectorPair<2> VectorPair2
.................................

See VectorPair (*note Math_VectorPair_2_struct_reference::)<2> struct.

double degree2rad(double x)
...........................

Convert from degrees to radians

void get_rotation_matrix(Matrix<2> &m, unsigned int axis, double rangle)
........................................................................

Setup a 2d rotation matrix with specified angle in radian.  axis
parameter must be 0.

void get_rotation_matrix(Matrix<3> &m, unsigned int axis, double rangle)
........................................................................

Setup a 3d rotation matrix with specified angle in radian.  axis
parameter can be 0, 1 or 2 for x, y and z axes.

double lp_floor(double x, double n)
...................................

No documentation available

double lp_mod(double x, double n)
.................................

No documentation available

template <int N, typename T> std:: ostream & operator<<(std:: ostream &o, const VectorBase<N, T> &v)
....................................................................................................

No documentation available

template <int N> std:: ostream & operator<<(std:: ostream &o, const VectorPairBase<N> &l)
.........................................................................................

No documentation available

template <int N> std:: ostream & operator<<(std:: ostream &o, const Matrix<N> &m)
.................................................................................

No documentation available

std:: ostream & operator<<(std:: ostream &o, const Quaternion &q)
.................................................................

No documentation available

template <int N> std:: ostream & operator<<(std:: ostream &o, const TransformBase<N> &t)
........................................................................................

No documentation available

template <int N> std:: ostream & operator<<(std:: ostream &o, const Triangle<N> &l)
...................................................................................

No documentation available

double rad2degree(double x)
...........................

Convert from radians to degrees

typedef std:: pair <double, double> range_t
...........................................

No documentation available

double square(double x)
.......................

Compute square

const Vector2 vector2_0 = Vector2(0.0,0.0)
..........................................

Commonly used vector constant

const Vector2 vector2_01
........................

Commonly used vector constant

const Vector2 vector2_1
.......................

Commonly used vector constant

const Vector2 vector2_10
........................

Commonly used vector constant

const VectorPair<2> vector2_pair_00
...................................

No documentation available

const VectorPair<2> vector2_pair_01
...................................

No documentation available

const Vector3 vector3_0
.......................

Commonly used vector constant

const Vector3 vector3_001
.........................

Commonly used vector constant

const Vector3 vector3_010
.........................

Commonly used vector constant

const Vector3 vector3_1
.......................

Commonly used vector constant

const Vector3 vector3_100
.........................

Commonly used vector constant

const VectorPair<3> vector3_pair_00
...................................

No documentation available

const VectorPair<3> vector3_pair_01
...................................

No documentation available

Math::Matrix struct reference
=============================

Declaration
-----------

     #include <Goptical/Math/Matrix>

     namespace Goptical {
       namespace Math {
         template <int N> struct Matrix;
       };
     };


   This struct is a member of the Math namespace.

Description
-----------

NxN square matrix class.

Members
-------

See also the full member list (*note
Math_Matrix_struct_full_member_list::) section for this struct.

Functions
.........

   * void adjugate(Matrix &result) const
   * Matrix adjugate() const
   * double determinant() const
   * void inverse(Matrix &result) const
   * Matrix inverse() const
   * Matrix operator*(double scale) const
   * Matrix operator*(const Matrix &m) const
   * Vector<N> operator*(const Vector<N> &v) const
   * Matrix operator+(const Matrix &m) const
   * Matrix operator-(const Matrix &m) const
   * Matrix operator/(double scale) const
   * Matrix & set(double value = _[...]_)
   * Matrix & set_col(int col, double value)
   * Matrix & set_col(int col, const Vector<N> &v)
   * Matrix & set_diag(double value = _[...]_)
   * Matrix & set_diag(const Vector<N> &v)
   * Matrix & set_id()
   * Matrix & set_row(int row, double value)
   * Matrix & set_row(int row, const Vector<N> &v)
   * void transpose(Matrix &result) const
   * Matrix transpose() const
   * double value(int x, int y) const
   * double & value(int x, int y)

Members detail
--------------

void adjugate(Matrix &result) const
...................................

replace matrix by the adjugate matrix

Matrix adjugate() const
.......................

Get the adjugate matrix

double determinant() const
..........................

compute matrix determinant

void inverse(Matrix &result) const
..................................

replace matrix by the inverse matrix

Matrix inverse() const
......................

Get the inverse matrix

Matrix operator*(double scale) const
....................................

Scale matrix

Matrix operator*(const Matrix &m) const
.......................................

Multiply matrix

Vector<N> operator*(const Vector<N> &v) const
.............................................

Multiply matrix with vector.  See Vector class for vector/matrix
multiplication.

Matrix operator+(const Matrix &m) const
.......................................

Add matrix

Matrix operator-(const Matrix &m) const
.......................................

Subtract matrix

Matrix operator/(double scale) const
....................................

Scale matrix

Matrix & set(double value = 0)
..............................

Set whole matrix to specified value.

Matrix & set_col(int col, double value)
.......................................

Set whole matrix column to specified value.

Matrix & set_col(int col, const Vector<N> &v)
.............................................

Set matrix column to specified vector.

Matrix & set_diag(double value = 1)
...................................

Set matrix diagonal to specified value.

Matrix & set_diag(const Vector<N> &v)
.....................................

Set matrix diagonal to specified value.

Matrix & set_id()
.................

Setup an identity matrix.

Matrix & set_row(int row, double value)
.......................................

Set whole matrix row to specified value.

Matrix & set_row(int row, const Vector<N> &v)
.............................................

Set matrix row to specified vector.

void transpose(Matrix &result) const
....................................

replace matrix by the transposed matrix

Matrix transpose() const
........................

Get the transposed matrix

double value(int x, int y) const
................................

Get value at x row and y column

double & value(int x, int y)
............................

Get modifiable reference to value at x row and y column

Math::Matrix struct full member list
====================================

Functions
---------

   * void adjugate(Matrix &result) const
   * Matrix adjugate() const
   * double determinant() const
   * void inverse(Matrix &result) const
   * Matrix inverse() const
   * Matrix operator*(double scale) const
   * Matrix operator*(const Matrix &m) const
   * Vector<N> operator*(const Vector<N> &v) const
   * Matrix operator+(const Matrix &m) const
   * Matrix operator-(const Matrix &m) const
   * Matrix operator/(double scale) const
   * Matrix & set(double value = _[...]_)
   * Matrix & set_col(int col, double value)
   * Matrix & set_col(int col, const Vector<N> &v)
   * Matrix & set_diag(double value = _[...]_)
   * Matrix & set_diag(const Vector<N> &v)
   * Matrix & set_id()
   * Matrix & set_row(int row, double value)
   * Matrix & set_row(int row, const Vector<N> &v)
   * void transpose(Matrix &result) const
   * Matrix transpose() const
   * double value(int x, int y) const
   * double & value(int x, int y)

Math::Quaternion class reference
================================

Declaration
-----------

     #include <Goptical/Math/Quaternion>

     namespace Goptical {
       namespace Math {
         class Quaternion;
       };
     };


   This class is a member of the Math namespace.

Description
-----------

This class describe a quaternion object.  Useful for 3d rotations.

Members
-------

See also the full member list (*note
Math_Quaternion_class_full_member_list::) section for this class.

Functions
.........

   * Quaternion()
   * Quaternion(double x, double y, double z, double w)
   * Quaternion(const Vector3 &a, const Vector3 &b)
   * double norm() const
   * const Quaternion & normalize()
   * Quaternion operator*(const Quaternion &q) const
   * double w() const
   * double & w()
   * double x() const
   * double & x()
   * double y() const
   * double & y()
   * double z() const
   * double & z()

Static functions
................

   * static Quaternion angle(const Vector3 &v, double angle)
   * static Quaternion angle_rad(const Vector3 &v, double angle)

Members detail
--------------

Quaternion()
............

No documentation available

Quaternion(double x, double y, double z, double w)
..................................................

Create a Quaternion from its real values

Quaternion(const Vector3 &a, const Vector3 &b)
..............................................

Create a Quaternion as rotation between two unit vectors

static Quaternion angle(const Vector3 &v, double angle)
.......................................................

Create a Quaternion with given rotation angle along a 3d vector

static Quaternion angle_rad(const Vector3 &v, double angle)
...........................................................

Create a Quaternion with given rotation angle in radian along a 3d
vector

double norm() const
...................

Adjust vector length

const Quaternion & normalize()
..............................

Normalize vector length

Quaternion operator*(const Quaternion &q) const
...............................................

Multiply with an other quaternion

double w() const
................

Get quaterion w value

double & w()
............

Get reference to quaterion w value

double x() const
................

Get quaterion x value

double & x()
............

Get reference to quaterion x value

double y() const
................

Get quaterion y value

double & y()
............

Get reference to quaterion y value

double z() const
................

Get quaterion z value

double & z()
............

Get reference to quaterion z value

Math::Quaternion class full member list
=======================================

Functions
---------

   * Quaternion()
   * Quaternion(double x, double y, double z, double w)
   * Quaternion(const Vector3 &a, const Vector3 &b)
   * double norm() const
   * const Quaternion & normalize()
   * Quaternion operator*(const Quaternion &q) const
   * double w() const
   * double & w()
   * double x() const
   * double & x()
   * double y() const
   * double & y()
   * double z() const
   * double & z()

Static functions
----------------

   * static Quaternion angle(const Vector3 &v, double angle)
   * static Quaternion angle_rad(const Vector3 &v, double angle)

Math::Transform<3> class reference
==================================

Declaration
-----------

     #include <Goptical/Math/Transform>

     namespace Goptical {
       namespace Math {
         template <> class Transform<3>;
       };
     };


   This class is a member of the Math namespace.

   This class is a specialization of Transform.

Description
-----------

This class describes linear and affine transformations in 3d space.  It
contains a 3x3 transformation matrix and a 3d translation vector.  It
can be used for translation and rotation in 3d.

   See also Transform3 (*note _657::) typedef.

Members
-------

See also the full member list (*note
Math_Transform_3_class_full_member_list::) section for this class.

Functions
.........

   * Transform()
   * Transform(const TransformBase<3> &t)
   * Transform(const Quaternion &q, const Vector3 &v)
   * TransformBase<3> & affine_rotation(unsigned int axis, double
     dangle)
   * Transform<3> & affine_rotation(const Vector3 &rangles)
   * TransformBase<3> & affine_rotation_rad(unsigned int axis, double
     rangle)
   * Transform<3> & affine_rotation_rad(const Vector3 &rangles)
   * TransformBase<3> & affine_scaling(const Vector<N> &v)
   * TransformBase<3> & affine_scaling(double s)
   * TransformBase<3> & apply_translation(const Vector<N> &v)
   * void compose(const TransformBase<N> &t)
   * const Matrix<N> & get_linear() const
   * Matrix<N> & get_linear()
   * const Vector<N> & get_translation() const
   * Vector<N> & get_translation()
   * TransformBase<3> inverse() const
   * void linear_reset()
   * TransformBase<3> & linear_rotation(unsigned int axis, double
     dangle)
   * Transform<3> & linear_rotation(const Vector3 &dangles)
   * TransformBase<3> & linear_rotation_rad(unsigned int axis, double
     rangle)
   * Transform<3> & linear_rotation_rad(const Vector3 &rangles)
   * TransformBase<3> & linear_scaling(const Vector<N> &v)
   * TransformBase<3> & linear_scaling(double s)
   * void reset()
   * void set_direction(const Vector3 &d)
   * void set_rotation(const Quaternion &q)
   * void set_translation(const Vector<N> &v)
   * Vector<N> transform(const Vector<N> &v) const
   * VectorPair<N> transform_line(const VectorPair<N> &v) const
   * Vector<N> transform_linear(const Vector<N> &v) const
   * VectorPair<N> transform_pair(const VectorPair<N> &p) const
   * Vector<N> transform_translate(const Vector<N> &v) const
   * void translation_reset()

Members detail
--------------

Transform()
...........

No documentation available

Transform(const TransformBase<3> &t)
....................................

No documentation available

Transform(const Quaternion &q, const Vector3 &v)
................................................

Create a transform from rotation quaternion and translation vector

Transform<3> & affine_rotation(const Vector3 &rangles)
......................................................

apply rotation to current transform (degree)

Transform<3> & affine_rotation_rad(const Vector3 &rangles)
..........................................................

apply rotation to current transform (radian)

Transform<3> & linear_rotation(const Vector3 &dangles)
......................................................

apply rotation to current transform (degree) (does not transform
translation vector)

Transform<3> & linear_rotation_rad(const Vector3 &rangles)
..........................................................

apply rotation to current transform (radian) (does not transform
translation vector)

void set_direction(const Vector3 &d)
....................................

set rotation from given direction vector

void set_rotation(const Quaternion &q)
......................................

set rotation from given quaternion

Math::Transform<3> class full member list
=========================================

Functions
---------

   * Transform()
   * Transform(const TransformBase<3> &t)
   * Transform(const Quaternion &q, const Vector3 &v)
   * TransformBase<3> & affine_rotation(unsigned int axis, double
     dangle)
   * Transform<3> & affine_rotation(const Vector3 &rangles)
   * TransformBase<3> & affine_rotation_rad(unsigned int axis, double
     rangle)
   * Transform<3> & affine_rotation_rad(const Vector3 &rangles)
   * TransformBase<3> & affine_scaling(const Vector<N> &v)
   * TransformBase<3> & affine_scaling(double s)
   * TransformBase<3> & apply_translation(const Vector<N> &v)
   * void compose(const TransformBase<N> &t)
   * const Matrix<N> & get_linear() const
   * Matrix<N> & get_linear()
   * const Vector<N> & get_translation() const
   * Vector<N> & get_translation()
   * TransformBase<3> inverse() const
   * void linear_reset()
   * TransformBase<3> & linear_rotation(unsigned int axis, double
     dangle)
   * Transform<3> & linear_rotation(const Vector3 &dangles)
   * TransformBase<3> & linear_rotation_rad(unsigned int axis, double
     rangle)
   * Transform<3> & linear_rotation_rad(const Vector3 &rangles)
   * TransformBase<3> & linear_scaling(const Vector<N> &v)
   * TransformBase<3> & linear_scaling(double s)
   * void reset()
   * void set_direction(const Vector3 &d)
   * void set_rotation(const Quaternion &q)
   * void set_translation(const Vector<N> &v)
   * Vector<N> transform(const Vector<N> &v) const
   * VectorPair<N> transform_line(const VectorPair<N> &v) const
   * Vector<N> transform_linear(const Vector<N> &v) const
   * VectorPair<N> transform_pair(const VectorPair<N> &p) const
   * Vector<N> transform_translate(const Vector<N> &v) const
   * void translation_reset()

Math::Transform<2> class reference
==================================

Declaration
-----------

     #include <Goptical/Math/Transform>

     namespace Goptical {
       namespace Math {
         template <> class Transform<2>;
       };
     };


   This class is a member of the Math namespace.

   This class is a specialization of Transform.

Description
-----------

This class describes linear and affine transformations in 2d space.  It
contains a 2x2 transformation matrix and a 2d translation vector.  It
can be used for translation and rotation in 2d.

   See also Transform2 (*note _656::) typedef.

Members
-------

See also the full member list (*note
Math_Transform_2_class_full_member_list::) section for this class.

Functions
.........

   * Transform()
   * Transform(const TransformBase<2> &t)
   * TransformBase<2> & affine_rotation(unsigned int axis, double
     dangle)
   * TransformBase<2> & affine_rotation_rad(unsigned int axis, double
     rangle)
   * TransformBase<2> & affine_scaling(const Vector<N> &v)
   * TransformBase<2> & affine_scaling(double s)
   * TransformBase<2> & apply_translation(const Vector<N> &v)
   * void compose(const TransformBase<N> &t)
   * const Matrix<N> & get_linear() const
   * Matrix<N> & get_linear()
   * const Vector<N> & get_translation() const
   * Vector<N> & get_translation()
   * TransformBase<2> inverse() const
   * void linear_reset()
   * TransformBase<2> & linear_rotation(unsigned int axis, double
     dangle)
   * TransformBase<2> & linear_rotation_rad(unsigned int axis, double
     rangle)
   * TransformBase<2> & linear_scaling(const Vector<N> &v)
   * TransformBase<2> & linear_scaling(double s)
   * void reset()
   * void set_translation(const Vector<N> &v)
   * Vector<N> transform(const Vector<N> &v) const
   * VectorPair<N> transform_line(const VectorPair<N> &v) const
   * Vector<N> transform_linear(const Vector<N> &v) const
   * VectorPair<N> transform_pair(const VectorPair<N> &p) const
   * Vector<N> transform_translate(const Vector<N> &v) const
   * void translation_reset()

Members detail
--------------

Transform()
...........

No documentation available

Transform(const TransformBase<2> &t)
....................................

No documentation available

Math::Transform<2> class full member list
=========================================

Functions
---------

   * Transform()
   * Transform(const TransformBase<2> &t)
   * TransformBase<2> & affine_rotation(unsigned int axis, double
     dangle)
   * TransformBase<2> & affine_rotation_rad(unsigned int axis, double
     rangle)
   * TransformBase<2> & affine_scaling(const Vector<N> &v)
   * TransformBase<2> & affine_scaling(double s)
   * TransformBase<2> & apply_translation(const Vector<N> &v)
   * void compose(const TransformBase<N> &t)
   * const Matrix<N> & get_linear() const
   * Matrix<N> & get_linear()
   * const Vector<N> & get_translation() const
   * Vector<N> & get_translation()
   * TransformBase<2> inverse() const
   * void linear_reset()
   * TransformBase<2> & linear_rotation(unsigned int axis, double
     dangle)
   * TransformBase<2> & linear_rotation_rad(unsigned int axis, double
     rangle)
   * TransformBase<2> & linear_scaling(const Vector<N> &v)
   * TransformBase<2> & linear_scaling(double s)
   * void reset()
   * void set_translation(const Vector<N> &v)
   * Vector<N> transform(const Vector<N> &v) const
   * VectorPair<N> transform_line(const VectorPair<N> &v) const
   * Vector<N> transform_linear(const Vector<N> &v) const
   * VectorPair<N> transform_pair(const VectorPair<N> &p) const
   * Vector<N> transform_translate(const Vector<N> &v) const
   * void translation_reset()

Math::TransformBase<2> internal class members
=============================================

TransformBase()
---------------

No documentation available

TransformBase<2> & affine_rotation(unsigned int axis, double dangle)
--------------------------------------------------------------------

apply rotation to current transform (degree)

TransformBase<2> & affine_rotation_rad(unsigned int axis, double rangle)
------------------------------------------------------------------------

apply rotation to current transform (radian)

TransformBase<2> & affine_scaling(const Vector<N> &v)
-----------------------------------------------------

apply scaling to current transform

TransformBase<2> & affine_scaling(double s)
-------------------------------------------

apply scaling to current transform

TransformBase<2> & apply_translation(const Vector<N> &v)
--------------------------------------------------------

apply translation to current transform

void compose(const TransformBase<N> &t)
---------------------------------------

compose with t.  new transform is equivalent to applying t then this
transform

const Matrix<N> & get_linear() const
------------------------------------

get linear transform matrix

Matrix<N> & get_linear()
------------------------

get linear transform matrix

const Vector<N> & get_translation() const
-----------------------------------------

get translation vector

Vector<N> & get_translation()
-----------------------------

get translation vector

TransformBase<2> inverse() const
--------------------------------

get inverse transformation

void linear_reset()
-------------------

reset linear transform to identity

TransformBase<2> & linear_rotation(unsigned int axis, double dangle)
--------------------------------------------------------------------

apply rotation to current transform (degree) (does not transform
translation vector)

TransformBase<2> & linear_rotation_rad(unsigned int axis, double rangle)
------------------------------------------------------------------------

apply rotation to current transform (radian) (does not transform
translation vector)

TransformBase<2> & linear_scaling(const Vector<N> &v)
-----------------------------------------------------

apply linear scaling to current transform (does not transform
translation vector)

TransformBase<2> & linear_scaling(double s)
-------------------------------------------

apply scaling to current transform (does not transform translation
vector)

void reset()
------------

reset linear transform to identity and translation to zero

void set_translation(const Vector<N> &v)
----------------------------------------

set current translation

Vector<N> transform(const Vector<N> &v) const
---------------------------------------------

apply affine transform (translation and linear) to vector

VectorPair<N> transform_line(const VectorPair<N> &v) const
----------------------------------------------------------

apply affine transform to line origin and linear to direction

Vector<N> transform_linear(const Vector<N> &v) const
----------------------------------------------------

apply linear transform to vector

VectorPair<N> transform_pair(const VectorPair<N> &p) const
----------------------------------------------------------

apply affine transform to both vectors in pair

Vector<N> transform_translate(const Vector<N> &v) const
-------------------------------------------------------

apply translation to vector

void translation_reset()
------------------------

reset translation to zero

virtual ~TransformBase()
------------------------

No documentation available

Math::TransformBase<3> internal class members
=============================================

TransformBase()
---------------

No documentation available

TransformBase<3> & affine_rotation(unsigned int axis, double dangle)
--------------------------------------------------------------------

apply rotation to current transform (degree)

TransformBase<3> & affine_rotation_rad(unsigned int axis, double rangle)
------------------------------------------------------------------------

apply rotation to current transform (radian)

TransformBase<3> & affine_scaling(const Vector<N> &v)
-----------------------------------------------------

apply scaling to current transform

TransformBase<3> & affine_scaling(double s)
-------------------------------------------

apply scaling to current transform

TransformBase<3> & apply_translation(const Vector<N> &v)
--------------------------------------------------------

apply translation to current transform

void compose(const TransformBase<N> &t)
---------------------------------------

compose with t.  new transform is equivalent to applying t then this
transform

const Matrix<N> & get_linear() const
------------------------------------

get linear transform matrix

Matrix<N> & get_linear()
------------------------

get linear transform matrix

const Vector<N> & get_translation() const
-----------------------------------------

get translation vector

Vector<N> & get_translation()
-----------------------------

get translation vector

TransformBase<3> inverse() const
--------------------------------

get inverse transformation

void linear_reset()
-------------------

reset linear transform to identity

TransformBase<3> & linear_rotation(unsigned int axis, double dangle)
--------------------------------------------------------------------

apply rotation to current transform (degree) (does not transform
translation vector)

TransformBase<3> & linear_rotation_rad(unsigned int axis, double rangle)
------------------------------------------------------------------------

apply rotation to current transform (radian) (does not transform
translation vector)

TransformBase<3> & linear_scaling(const Vector<N> &v)
-----------------------------------------------------

apply linear scaling to current transform (does not transform
translation vector)

TransformBase<3> & linear_scaling(double s)
-------------------------------------------

apply scaling to current transform (does not transform translation
vector)

void reset()
------------

reset linear transform to identity and translation to zero

void set_translation(const Vector<N> &v)
----------------------------------------

set current translation

Vector<N> transform(const Vector<N> &v) const
---------------------------------------------

apply affine transform (translation and linear) to vector

VectorPair<N> transform_line(const VectorPair<N> &v) const
----------------------------------------------------------

apply affine transform to line origin and linear to direction

Vector<N> transform_linear(const Vector<N> &v) const
----------------------------------------------------

apply linear transform to vector

VectorPair<N> transform_pair(const VectorPair<N> &p) const
----------------------------------------------------------

apply affine transform to both vectors in pair

Vector<N> transform_translate(const Vector<N> &v) const
-------------------------------------------------------

apply translation to vector

void translation_reset()
------------------------

reset translation to zero

virtual ~TransformBase()
------------------------

No documentation available

Math::Triangle struct reference
===============================

Declaration
-----------

     #include <Goptical/Math/Triangle>

     namespace Goptical {
       namespace Math {
         template <int N> struct Triangle;
       };
     };


   This struct is a member of the Math namespace.

Description
-----------

This class is the general purpose N dimensions triangles class.

Class specializations
---------------------

Name                   Description
--------------------------------------------------------------------------
Triangle<3>            3d triangle class

Members
-------

See also the full member list (*note
Math_Triangle_struct_full_member_list::) section for this struct.

Type
....

   * typedef _ [...]  _ put_delegate_t

Functions
.........

   * Triangle()
   * Triangle(const Vector<N> &a, const Vector<N> &b, const Vector<N>
     &c)
   * Vector<N> get_centroid() const
   * const Vector<N> & operator[](int n) const
   * Vector<N> & operator[](int n)

Members detail
--------------

Triangle()
..........

No documentation available

Triangle(const Vector<N> &a, const Vector<N> &b, const Vector<N> &c)
....................................................................

Create a triangle from 3 points

typedef delegate <void(const Math::Triangle<N>&)> put_delegate_t
................................................................

No documentation available

Math::Triangle struct full member list
======================================

Type
----

   * typedef _ [...]  _ put_delegate_t

Functions
---------

   * Triangle()
   * Triangle(const Vector<N> &a, const Vector<N> &b, const Vector<N>
     &c)
   * Vector<N> get_centroid() const
   * const Vector<N> & operator[](int n) const
   * Vector<N> & operator[](int n)

Math::Triangle<3> struct reference
==================================

Declaration
-----------

     #include <Goptical/Math/Triangle>

     namespace Goptical {
       namespace Math {
         template <> struct Triangle<3>;
       };
     };


   This struct is a member of the Math namespace.

   This struct is a specialization of Triangle (*note
Math_Triangle_struct_reference::).

Description
-----------

This class is the 3d triangles class.

Members
-------

See also the full member list (*note
Math_Triangle_3_struct_full_member_list::) section for this struct.

Type
....

   * typedef _ [...]  _ put_delegate_t

Functions
.........

   * Triangle()
   * Triangle(const Vector3 &a, const Vector3 &b, const Vector3 &c)
   * Vector<N> get_centroid() const
   * Vector3 normal() const
   * const Vector<N> & operator[](int n) const
   * Vector<N> & operator[](int n)

Members detail
--------------

Triangle()
..........

No documentation available

Triangle(const Vector3 &a, const Vector3 &b, const Vector3 &c)
..............................................................

Create a triangle from 3 points

Vector3 normal() const
......................

Get triangle normal

typedef delegate <void(const Math::Triangle<3>&)> put_delegate_t
................................................................

No documentation available

Math::Triangle<3> struct full member list
=========================================

Type
----

   * typedef _ [...]  _ put_delegate_t

Functions
---------

   * Triangle()
   * Triangle(const Vector3 &a, const Vector3 &b, const Vector3 &c)
   * Vector<N> get_centroid() const
   * Vector3 normal() const
   * const Vector<N> & operator[](int n) const
   * Vector<N> & operator[](int n)

Math::Triangle<2> internal struct members
=========================================

Triangle()
----------

No documentation available

Triangle(const Vector<N> &a, const Vector<N> &b, const Vector<N> &c)
--------------------------------------------------------------------

Create a triangle from 3 points

typedef delegate <void(const Math::Triangle<N>&)> put_delegate_t
----------------------------------------------------------------

No documentation available

Math::TriangleBase<N> internal struct members
=============================================

TriangleBase()
--------------

No documentation available

TriangleBase(const Vector<N> &a, const Vector<N> &b, const Vector<N> &c)
------------------------------------------------------------------------

Create a triangle from 3 points

Vector<N> get_centroid() const
------------------------------

Get triangle centroid

const Vector<N> & operator[](int n) const
-----------------------------------------

Get point n of the triangle

Vector<N> & operator[](int n)
-----------------------------

Get reference to point n of the triangle

Math::TriangleBase<3> internal struct members
=============================================

TriangleBase()
--------------

No documentation available

TriangleBase(const Vector<N> &a, const Vector<N> &b, const Vector<N> &c)
------------------------------------------------------------------------

Create a triangle from 3 points

Vector<N> get_centroid() const
------------------------------

Get triangle centroid

const Vector<N> & operator[](int n) const
-----------------------------------------

Get point n of the triangle

Vector<N> & operator[](int n)
-----------------------------

Get reference to point n of the triangle

Math::Vector struct reference
=============================

Declaration
-----------

     #include <Goptical/Math/Vector>

     namespace Goptical {
       namespace Math {
         template <int N, typename T = double> struct Vector;
       };
     };


   This struct is a member of the Math namespace.

Description
-----------

This class is the general purpose N dimensions vector class.

Class specializations
---------------------

Name                   Description
--------------------------------------------------------------------------
Vector<3, T>           3d vector class
Vector<2, T>           2d vector class

Members
-------

See also the full member list (*note
Math_Vector_struct_full_member_list::) section for this struct.

Functions
.........

   * Vector()
   * Vector(const VectorBase<N, T> &v)
   * Vector(T v)
   * bool close_to(const VectorBase<N, T> &m, T error = _[...]_)
   * T len() const
   * VectorBase<N, T> magnitude(T newlen) const
   * VectorBase<N, T> mul(const VectorBase<N, T> &v) const
   * VectorBase<N, T> & neg()
   * const VectorBase<N, T> & normalize()
   * VectorBase<N, T> normalized() const
   * T operator*(const VectorBase<N, T> &v) const
   * VectorBase<N, T> operator*(T scale) const
   * VectorBase<N, T> operator*(const Matrix<N> &m)
   * const VectorBase<N, T> & operator*=(T scale)
   * VectorBase<N, T> operator+(const VectorBase<N, T> &v) const
   * const VectorBase<N, T> & operator+=(const VectorBase<N, T> &v)
   * VectorBase<N, T> operator-(const VectorBase<N, T> &v) const
   * VectorBase<N, T> operator-() const
   * const VectorBase<N, T> & operator-=(const VectorBase<N, T> &v)
   * VectorBase<N, T> operator/(T scale) const
   * VectorBase<N, T> operator/(const VectorBase<N, T> &v) const
   * const VectorBase<N, T> & operator/=(T scale)
   * bool operator==(const VectorBase<N, T> &m) const
   * T operator[](int n) const
   * T & operator[](int n)
   * template VectorBase<M, T> select(unsigned int bitmask, const
     VectorBase<M, T> &v) const
   * void set(T value)

Members detail
--------------

Vector()
........

No documentation available

Vector(const VectorBase<N, T> &v)
.................................

No documentation available

Vector(T v)
...........

Create a 2d vector with same value for all components

Math::Vector struct full member list
====================================

Functions
---------

   * Vector()
   * Vector(const VectorBase<N, T> &v)
   * Vector(T v)
   * bool close_to(const VectorBase<N, T> &m, T error = _[...]_)
   * T len() const
   * VectorBase<N, T> magnitude(T newlen) const
   * VectorBase<N, T> mul(const VectorBase<N, T> &v) const
   * VectorBase<N, T> & neg()
   * const VectorBase<N, T> & normalize()
   * VectorBase<N, T> normalized() const
   * T operator*(const VectorBase<N, T> &v) const
   * VectorBase<N, T> operator*(T scale) const
   * VectorBase<N, T> operator*(const Matrix<N> &m)
   * const VectorBase<N, T> & operator*=(T scale)
   * VectorBase<N, T> operator+(const VectorBase<N, T> &v) const
   * const VectorBase<N, T> & operator+=(const VectorBase<N, T> &v)
   * VectorBase<N, T> operator-(const VectorBase<N, T> &v) const
   * VectorBase<N, T> operator-() const
   * const VectorBase<N, T> & operator-=(const VectorBase<N, T> &v)
   * VectorBase<N, T> operator/(T scale) const
   * VectorBase<N, T> operator/(const VectorBase<N, T> &v) const
   * const VectorBase<N, T> & operator/=(T scale)
   * bool operator==(const VectorBase<N, T> &m) const
   * T operator[](int n) const
   * T & operator[](int n)
   * template VectorBase<M, T> select(unsigned int bitmask, const
     VectorBase<M, T> &v) const
   * void set(T value)

Math::Vector<3,T> struct reference
==================================

Declaration
-----------

     #include <Goptical/Math/Vector>

     namespace Goptical {
       namespace Math {
         template <typename T> struct Vector<3, T>;
       };
     };


   This struct is a member of the Math namespace.

   This template struct is a specialization of Vector (*note
Math_Vector_struct_reference::).

Description
-----------

This class implements 3d vectors.

   The Math (*note Math_namespace_reference::) namespace contains some
commonly used constant vector objects.

Members
-------

See also the full member list (*note
Math_Vector_3_T_struct_full_member_list::) section for this struct.

Types
.....

   * typedef _ [...]  _ base
   * typedef _ [...]  _ put_delegate_t

Functions
.........

   * Vector()
   * Vector(const VectorBase<3, T> &v)
   * template Vector(const VectorBase<M, T> &v, T p)
   * Vector(T v)
   * Vector(T x, T y, T z)
   * bool close_to(const VectorBase<3, T> &m, T error = _[...]_)
   * Vector cross_product(const Vector<3, T> &v) const
   * T len() const
   * VectorBase<3, T> magnitude(T newlen) const
   * VectorBase<3, T> mul(const VectorBase<3, T> &v) const
   * VectorBase<3, T> & neg()
   * const VectorBase<3, T> & normalize()
   * VectorBase<3, T> normalized() const
   * T operator*(const VectorBase<3, T> &v) const
   * VectorBase<3, T> operator*(T scale) const
   * VectorBase<3, T> operator*(const Matrix<N> &m)
   * const VectorBase<3, T> & operator*=(T scale)
   * VectorBase<3, T> operator+(const VectorBase<3, T> &v) const
   * const VectorBase<3, T> & operator+=(const VectorBase<3, T> &v)
   * VectorBase<3, T> operator-(const VectorBase<3, T> &v) const
   * VectorBase<3, T> operator-() const
   * const VectorBase<3, T> & operator-=(const VectorBase<3, T> &v)
   * VectorBase<3, T> operator/(T scale) const
   * VectorBase<3, T> operator/(const VectorBase<3, T> &v) const
   * const VectorBase<3, T> & operator/=(T scale)
   * bool operator==(const VectorBase<3, T> &m) const
   * T operator[](int n) const
   * T & operator[](int n)
   * Vector<2, T> project_xy() const
   * Vector<2, T> project_zy() const
   * template VectorBase<M, T> select(unsigned int bitmask, const
     VectorBase<M, T> &v) const
   * void set(T value)
   * T & x()
   * T x() const
   * T & y()
   * T y() const
   * T & z()
   * T z() const

Members detail
--------------

Vector()
........

No documentation available

Vector(const VectorBase<3, T> &v)
.................................

Copy constructor

template <int M> Vector(const VectorBase<M, T> &v, T p)
.......................................................

Create a 3d vector from 2d vector and given z value.

Vector(T v)
...........

Create a 2d vector with same value for all components

Vector(T x, T y, T z)
.....................

Create a 3d vector from x, y and z values

typedef VectorBase<3, T> base
.............................

No documentation available

Vector cross_product(const Vector<3, T> &v) const
.................................................

Compute vectors cross product

Vector<2, T> project_xy() const
...............................

Get a 2d vector formed x and y values.

Vector<2, T> project_zy() const
...............................

Get a 2d vector formed z and y values.

typedef delegate <void(const Vector<3,T>&)> put_delegate_t
..........................................................

No documentation available

T & x()
.......

Get reference to vector x value

T x() const
...........

Get vector x value

T & y()
.......

Get reference to vector y value

T y() const
...........

Get vector y value

T & z()
.......

Get reference to vector z value

T z() const
...........

Get vector z value

Math::Vector<3,T> struct full member list
=========================================

Types
-----

   * typedef _ [...]  _ base
   * typedef _ [...]  _ put_delegate_t

Functions
---------

   * Vector()
   * Vector(const VectorBase<3, T> &v)
   * template Vector(const VectorBase<M, T> &v, T p)
   * Vector(T v)
   * Vector(T x, T y, T z)
   * bool close_to(const VectorBase<3, T> &m, T error = _[...]_)
   * Vector cross_product(const Vector<3, T> &v) const
   * T len() const
   * VectorBase<3, T> magnitude(T newlen) const
   * VectorBase<3, T> mul(const VectorBase<3, T> &v) const
   * VectorBase<3, T> & neg()
   * const VectorBase<3, T> & normalize()
   * VectorBase<3, T> normalized() const
   * T operator*(const VectorBase<3, T> &v) const
   * VectorBase<3, T> operator*(T scale) const
   * VectorBase<3, T> operator*(const Matrix<N> &m)
   * const VectorBase<3, T> & operator*=(T scale)
   * VectorBase<3, T> operator+(const VectorBase<3, T> &v) const
   * const VectorBase<3, T> & operator+=(const VectorBase<3, T> &v)
   * VectorBase<3, T> operator-(const VectorBase<3, T> &v) const
   * VectorBase<3, T> operator-() const
   * const VectorBase<3, T> & operator-=(const VectorBase<3, T> &v)
   * VectorBase<3, T> operator/(T scale) const
   * VectorBase<3, T> operator/(const VectorBase<3, T> &v) const
   * const VectorBase<3, T> & operator/=(T scale)
   * bool operator==(const VectorBase<3, T> &m) const
   * T operator[](int n) const
   * T & operator[](int n)
   * Vector<2, T> project_xy() const
   * Vector<2, T> project_zy() const
   * template VectorBase<M, T> select(unsigned int bitmask, const
     VectorBase<M, T> &v) const
   * void set(T value)
   * T & x()
   * T x() const
   * T & y()
   * T y() const
   * T & z()
   * T z() const

Math::Vector<2,T> struct reference
==================================

Declaration
-----------

     #include <Goptical/Math/Vector>

     namespace Goptical {
       namespace Math {
         template <typename T> struct Vector<2, T>;
       };
     };


   This struct is a member of the Math namespace.

   This template struct is a specialization of Vector (*note
Math_Vector_struct_reference::).

Description
-----------

This class implements 2d vectors.

   The Math (*note Math_namespace_reference::) namespace contains some
commonly used constant vector objects.

Members
-------

See also the full member list (*note
Math_Vector_2_T_struct_full_member_list::) section for this struct.

Types
.....

   * typedef _ [...]  _ base
   * typedef _ [...]  _ put_delegate_t

Functions
.........

   * Vector()
   * Vector(const VectorBase<2, T> &v)
   * template Vector(const VectorBase<M, T> &v, T p)
   * Vector(T v)
   * Vector(T x, T y)
   * template Vector(const VectorBase<N, T> &v, unsigned int c0,
     unsigned int c1)
   * bool close_to(const VectorBase<2, T> &m, T error = _[...]_)
   * T cross_product(const Vector<2, T> &v) const
   * T len() const
   * VectorBase<2, T> magnitude(T newlen) const
   * VectorBase<2, T> mul(const VectorBase<2, T> &v) const
   * VectorBase<2, T> & neg()
   * const VectorBase<2, T> & normalize()
   * VectorBase<2, T> normalized() const
   * T operator*(const VectorBase<2, T> &v) const
   * VectorBase<2, T> operator*(T scale) const
   * VectorBase<2, T> operator*(const Matrix<N> &m)
   * const VectorBase<2, T> & operator*=(T scale)
   * VectorBase<2, T> operator+(const VectorBase<2, T> &v) const
   * const VectorBase<2, T> & operator+=(const VectorBase<2, T> &v)
   * VectorBase<2, T> operator-(const VectorBase<2, T> &v) const
   * VectorBase<2, T> operator-() const
   * const VectorBase<2, T> & operator-=(const VectorBase<2, T> &v)
   * VectorBase<2, T> operator/(T scale) const
   * VectorBase<2, T> operator/(const VectorBase<2, T> &v) const
   * const VectorBase<2, T> & operator/=(T scale)
   * bool operator==(const VectorBase<2, T> &m) const
   * T operator[](int n) const
   * T & operator[](int n)
   * template VectorBase<M, T> select(unsigned int bitmask, const
     VectorBase<M, T> &v) const
   * void set(T value)
   * T & x()
   * T x() const
   * T & y()
   * T y() const

Members detail
--------------

Vector()
........

No documentation available

Vector(const VectorBase<2, T> &v)
.................................

No documentation available

template <int M> Vector(const VectorBase<M, T> &v, T p)
.......................................................

No documentation available

Vector(T v)
...........

Create a 2d vector with same value for all components

Vector(T x, T y)
................

Create a 2d vector from x and y z values

template <int N> Vector(const VectorBase<N, T> &v, unsigned int c0, unsigned int c1)
....................................................................................

Create a 2d vector and initialize from specified components of an other
vector

typedef VectorBase<2, T> base
.............................

No documentation available

T cross_product(const Vector<2, T> &v) const
............................................

No documentation available

typedef delegate <void(const Math::Vector2&)> put_delegate_t
............................................................

No documentation available

T & x()
.......

Get reference to vector x value

T x() const
...........

Get vector x value

T & y()
.......

Get reference to vector y value

T y() const
...........

Get vector y value

Math::Vector<2,T> struct full member list
=========================================

Types
-----

   * typedef _ [...]  _ base
   * typedef _ [...]  _ put_delegate_t

Functions
---------

   * Vector()
   * Vector(const VectorBase<2, T> &v)
   * template Vector(const VectorBase<M, T> &v, T p)
   * Vector(T v)
   * Vector(T x, T y)
   * template Vector(const VectorBase<N, T> &v, unsigned int c0,
     unsigned int c1)
   * bool close_to(const VectorBase<2, T> &m, T error = _[...]_)
   * T cross_product(const Vector<2, T> &v) const
   * T len() const
   * VectorBase<2, T> magnitude(T newlen) const
   * VectorBase<2, T> mul(const VectorBase<2, T> &v) const
   * VectorBase<2, T> & neg()
   * const VectorBase<2, T> & normalize()
   * VectorBase<2, T> normalized() const
   * T operator*(const VectorBase<2, T> &v) const
   * VectorBase<2, T> operator*(T scale) const
   * VectorBase<2, T> operator*(const Matrix<N> &m)
   * const VectorBase<2, T> & operator*=(T scale)
   * VectorBase<2, T> operator+(const VectorBase<2, T> &v) const
   * const VectorBase<2, T> & operator+=(const VectorBase<2, T> &v)
   * VectorBase<2, T> operator-(const VectorBase<2, T> &v) const
   * VectorBase<2, T> operator-() const
   * const VectorBase<2, T> & operator-=(const VectorBase<2, T> &v)
   * VectorBase<2, T> operator/(T scale) const
   * VectorBase<2, T> operator/(const VectorBase<2, T> &v) const
   * const VectorBase<2, T> & operator/=(T scale)
   * bool operator==(const VectorBase<2, T> &m) const
   * T operator[](int n) const
   * T & operator[](int n)
   * template VectorBase<M, T> select(unsigned int bitmask, const
     VectorBase<M, T> &v) const
   * void set(T value)
   * T & x()
   * T x() const
   * T & y()
   * T y() const

Math::VectorBase<N,Math::Vector::T> internal struct members
===========================================================

bool close_to(const VectorBase<N, T> &m, T error = 1 e-8)
---------------------------------------------------------

compare two almost equal vectors

T len() const
-------------

Compute vector length

VectorBase<N, T> magnitude(T newlen) const
------------------------------------------

Adjust vector length

VectorBase<N, T> mul(const VectorBase<N, T> &v) const
-----------------------------------------------------

Vector values multiply

VectorBase<N, T> & neg()
------------------------

Negate vector

const VectorBase<N, T> & normalize()
------------------------------------

Normalize vector length

   See also normalized (*note _1036::) function.

VectorBase<N, T> normalized() const
-----------------------------------

Get normalized vector

   See also normalize (*note _1035::) function.

T operator*(const VectorBase<N, T> &v) const
--------------------------------------------

Vector dot product

VectorBase<N, T> operator*(T scale) const
-----------------------------------------

Scale vector

VectorBase<N, T> operator*(const Matrix<N> &m)
----------------------------------------------

Multiply vector with matrix.  See Vector class for matrix/vector
multiplication.

const VectorBase<N, T> & operator*=(T scale)
--------------------------------------------

Multiply by a vector

VectorBase<N, T> operator+(const VectorBase<N, T> &v) const
-----------------------------------------------------------

Add two vectors

const VectorBase<N, T> & operator+=(const VectorBase<N, T> &v)
--------------------------------------------------------------

Add a vector

VectorBase<N, T> operator-(const VectorBase<N, T> &v) const
-----------------------------------------------------------

Subtract two vectors

VectorBase<N, T> operator-() const
----------------------------------

Get negated vector

const VectorBase<N, T> & operator-=(const VectorBase<N, T> &v)
--------------------------------------------------------------

Sutract a vector

VectorBase<N, T> operator/(T scale) const
-----------------------------------------

Scale vector

VectorBase<N, T> operator/(const VectorBase<N, T> &v) const
-----------------------------------------------------------

Vector division

const VectorBase<N, T> & operator/=(T scale)
--------------------------------------------

Divide by a vector

bool operator==(const VectorBase<N, T> &m) const
------------------------------------------------

compare two vectors for equality

T operator[](int n) const
-------------------------

Get value at specified index

T & operator[](int n)
---------------------

Get reference to value at specified index

template <int M> VectorBase<M, T> select(unsigned int bitmask, const VectorBase<M, T> &v) const
-----------------------------------------------------------------------------------------------

Select components from two vectors.  Components which have their
corresponding bit set in the mask are extracted from this vector and
other components are taken from passed vector.

void set(T value)
-----------------

Set the whole vector to the specified value

Math::VectorBase<2,Math::Vector<2,T>::T> internal struct members
================================================================

bool close_to(const VectorBase<2, T> &m, T error = 1 e-8)
---------------------------------------------------------

compare two almost equal vectors

T len() const
-------------

Compute vector length

VectorBase<2, T> magnitude(T newlen) const
------------------------------------------

Adjust vector length

VectorBase<2, T> mul(const VectorBase<2, T> &v) const
-----------------------------------------------------

Vector values multiply

VectorBase<2, T> & neg()
------------------------

Negate vector

const VectorBase<2, T> & normalize()
------------------------------------

Normalize vector length

   See also normalized (*note _1036::) function.

VectorBase<2, T> normalized() const
-----------------------------------

Get normalized vector

   See also normalize (*note _1035::) function.

T operator*(const VectorBase<2, T> &v) const
--------------------------------------------

Vector dot product

VectorBase<2, T> operator*(T scale) const
-----------------------------------------

Scale vector

VectorBase<2, T> operator*(const Matrix<N> &m)
----------------------------------------------

Multiply vector with matrix.  See Vector class for matrix/vector
multiplication.

const VectorBase<2, T> & operator*=(T scale)
--------------------------------------------

Multiply by a vector

VectorBase<2, T> operator+(const VectorBase<2, T> &v) const
-----------------------------------------------------------

Add two vectors

const VectorBase<2, T> & operator+=(const VectorBase<2, T> &v)
--------------------------------------------------------------

Add a vector

VectorBase<2, T> operator-(const VectorBase<2, T> &v) const
-----------------------------------------------------------

Subtract two vectors

VectorBase<2, T> operator-() const
----------------------------------

Get negated vector

const VectorBase<2, T> & operator-=(const VectorBase<2, T> &v)
--------------------------------------------------------------

Sutract a vector

VectorBase<2, T> operator/(T scale) const
-----------------------------------------

Scale vector

VectorBase<2, T> operator/(const VectorBase<2, T> &v) const
-----------------------------------------------------------

Vector division

const VectorBase<2, T> & operator/=(T scale)
--------------------------------------------

Divide by a vector

bool operator==(const VectorBase<2, T> &m) const
------------------------------------------------

compare two vectors for equality

T operator[](int n) const
-------------------------

Get value at specified index

T & operator[](int n)
---------------------

Get reference to value at specified index

template <int M> VectorBase<M, T> select(unsigned int bitmask, const VectorBase<M, T> &v) const
-----------------------------------------------------------------------------------------------

Select components from two vectors.  Components which have their
corresponding bit set in the mask are extracted from this vector and
other components are taken from passed vector.

void set(T value)
-----------------

Set the whole vector to the specified value

Math::VectorBase<3,Math::Vector<3,T>::T> internal struct members
================================================================

bool close_to(const VectorBase<3, T> &m, T error = 1 e-8)
---------------------------------------------------------

compare two almost equal vectors

T len() const
-------------

Compute vector length

VectorBase<3, T> magnitude(T newlen) const
------------------------------------------

Adjust vector length

VectorBase<3, T> mul(const VectorBase<3, T> &v) const
-----------------------------------------------------

Vector values multiply

VectorBase<3, T> & neg()
------------------------

Negate vector

const VectorBase<3, T> & normalize()
------------------------------------

Normalize vector length

   See also normalized (*note _1036::) function.

VectorBase<3, T> normalized() const
-----------------------------------

Get normalized vector

   See also normalize (*note _1035::) function.

T operator*(const VectorBase<3, T> &v) const
--------------------------------------------

Vector dot product

VectorBase<3, T> operator*(T scale) const
-----------------------------------------

Scale vector

VectorBase<3, T> operator*(const Matrix<N> &m)
----------------------------------------------

Multiply vector with matrix.  See Vector class for matrix/vector
multiplication.

const VectorBase<3, T> & operator*=(T scale)
--------------------------------------------

Multiply by a vector

VectorBase<3, T> operator+(const VectorBase<3, T> &v) const
-----------------------------------------------------------

Add two vectors

const VectorBase<3, T> & operator+=(const VectorBase<3, T> &v)
--------------------------------------------------------------

Add a vector

VectorBase<3, T> operator-(const VectorBase<3, T> &v) const
-----------------------------------------------------------

Subtract two vectors

VectorBase<3, T> operator-() const
----------------------------------

Get negated vector

const VectorBase<3, T> & operator-=(const VectorBase<3, T> &v)
--------------------------------------------------------------

Sutract a vector

VectorBase<3, T> operator/(T scale) const
-----------------------------------------

Scale vector

VectorBase<3, T> operator/(const VectorBase<3, T> &v) const
-----------------------------------------------------------

Vector division

const VectorBase<3, T> & operator/=(T scale)
--------------------------------------------

Divide by a vector

bool operator==(const VectorBase<3, T> &m) const
------------------------------------------------

compare two vectors for equality

T operator[](int n) const
-------------------------

Get value at specified index

T & operator[](int n)
---------------------

Get reference to value at specified index

template <int M> VectorBase<M, T> select(unsigned int bitmask, const VectorBase<M, T> &v) const
-----------------------------------------------------------------------------------------------

Select components from two vectors.  Components which have their
corresponding bit set in the mask are extracted from this vector and
other components are taken from passed vector.

void set(T value)
-----------------

Set the whole vector to the specified value

Math::VectorPair struct reference
=================================

Declaration
-----------

     #include <Goptical/Math/VectorPair>

     namespace Goptical {
       namespace Math {
         template <int N> struct VectorPair;
       };
     };


   This struct is a member of the Math namespace.

Description
-----------

This class hold two N dimensions vectors.

Class specializations
---------------------

Name                   Description
--------------------------------------------------------------------------
VectorPair<2>          Vector pair class
VectorPair<3>          Vector pair class

Members
-------

See also the full member list (*note
Math_VectorPair_struct_full_member_list::) section for this struct.

Functions
.........

   * VectorPair()
   * VectorPair(const VectorPairBase<N> &vp)
   * VectorPair(const Vector<N> &a, const Vector<N> &b)
   * Vector<N> & direction()
   * const Vector<N> & direction() const
   * Vector<N> ln_pt_clst_pt(const Vector<N> &point) const
   * double ln_pt_clst_pt_scale(const Vector<N> &point) const
   * Vector<N> & normal()
   * const Vector<N> & normal() const
   * VectorPairBase<N> operator*(double factor)
   * const VectorPairBase<N> & operator+=(const VectorPairBase<N> &p)
   * const Vector<N> & operator[](int n) const
   * Vector<N> & operator[](int n)
   * Vector<N> & origin()
   * const Vector<N> & origin() const
   * Vector<N> seg_pt_clst_pt(const Vector<N> &point) const
   * double seg_pt_clst_pt_scale(const Vector<N> &point) const

Members detail
--------------

VectorPair()
............

No documentation available

VectorPair(const VectorPairBase<N> &vp)
.......................................

No documentation available

VectorPair(const Vector<N> &a, const Vector<N> &b)
..................................................

No documentation available

Math::VectorPair struct full member list
========================================

Functions
---------

   * VectorPair()
   * VectorPair(const VectorPairBase<N> &vp)
   * VectorPair(const Vector<N> &a, const Vector<N> &b)
   * Vector<N> & direction()
   * const Vector<N> & direction() const
   * Vector<N> ln_pt_clst_pt(const Vector<N> &point) const
   * double ln_pt_clst_pt_scale(const Vector<N> &point) const
   * Vector<N> & normal()
   * const Vector<N> & normal() const
   * VectorPairBase<N> operator*(double factor)
   * const VectorPairBase<N> & operator+=(const VectorPairBase<N> &p)
   * const Vector<N> & operator[](int n) const
   * Vector<N> & operator[](int n)
   * Vector<N> & origin()
   * const Vector<N> & origin() const
   * Vector<N> seg_pt_clst_pt(const Vector<N> &point) const
   * double seg_pt_clst_pt_scale(const Vector<N> &point) const

Math::VectorPair<2> struct reference
====================================

Declaration
-----------

     #include <Goptical/Math/VectorPair>

     namespace Goptical {
       namespace Math {
         template <> struct VectorPair<2>;
       };
     };


   This struct is a member of the Math namespace.

   This struct is a specialization of VectorPair (*note
Math_VectorPair_struct_reference::).

Description
-----------

This class hold two 2d vectors.

   See also VectorPair2 (*note _658::) typedef.

Members
-------

See also the full member list (*note
Math_VectorPair_2_struct_full_member_list::) section for this struct.

Functions
.........

   * VectorPair()
   * VectorPair(const VectorPairBase<2> &vp)
   * VectorPair(const Vector<2> &a, const Vector<2> &b)
   * VectorPair(double ax, double ay, double bx, double by)
   * template VectorPair(const VectorPairBase<N> &v, unsigned int c0,
     unsigned int c1)
   * Vector<N> & direction()
   * const Vector<N> & direction() const
   * Vector<2> ln_intersect_ln(const VectorPair<2> &line) const
   * double ln_intersect_ln_scale(const VectorPair<2> &line) const
   * Vector<N> ln_pt_clst_pt(const Vector<N> &point) const
   * double ln_pt_clst_pt_scale(const Vector<N> &point) const
   * Vector<N> & normal()
   * const Vector<N> & normal() const
   * VectorPairBase<2> operator*(double factor)
   * const VectorPairBase<2> & operator+=(const VectorPairBase<2> &p)
   * const Vector<N> & operator[](int n) const
   * Vector<N> & operator[](int n)
   * Vector<N> & origin()
   * const Vector<N> & origin() const
   * template Vector<2> seg_intersect_seg(const VectorPair<2> &segment)
     const
   * Vector<N> seg_pt_clst_pt(const Vector<N> &point) const
   * double seg_pt_clst_pt_scale(const Vector<N> &point) const
   * double x0() const
   * double & x0()
   * double x1() const
   * double & x1()
   * double y0() const
   * double & y0()
   * double y1() const
   * double & y1()

Members detail
--------------

VectorPair()
............

No documentation available

VectorPair(const VectorPairBase<2> &vp)
.......................................

No documentation available

VectorPair(const Vector<2> &a, const Vector<2> &b)
..................................................

No documentation available

VectorPair(double ax, double ay, double bx, double by)
......................................................

No documentation available

template <int N> VectorPair(const VectorPairBase<N> &v, unsigned int c0, unsigned int c1)
.........................................................................................

Create a 2d vector pair and initialize vectors from specified components
of vectors from an other pair.

Vector<2> ln_intersect_ln(const VectorPair<2> &line) const
..........................................................

Consider the VectorPair (*note Math_VectorPair_struct_reference::) as a
line with origin and direction vectors and find the intersection point
with an other line.

   The return value is position of the intersection point.  this
function throws if lines are almost parallel.

   See also ln_intersect_ln_scale (*note _921::) function.

double ln_intersect_ln_scale(const VectorPair<2> &line) const
.............................................................

Consider the VectorPair (*note Math_VectorPair_struct_reference::) as a
line with origin and direction vectors and find the intersection point
with an other line.

   The return value is scale factor of the direction vector from line
origin.  this function throws if lines are almost parallel.

   See also ln_intersect_ln (*note _920::) function.

template <bool infinite_1st, bool infinite_2nd> Vector<2> seg_intersect_seg(const VectorPair<2> &segment) const
...............................................................................................................

Consider the VectorPair (*note Math_VectorPair_struct_reference::) as a
segment with two point vectors and find the intersection point with an
other segment.

   The return value is position of the intersection point.

   The 'infinite_1st' and 'infinite_2nd' template parameters can be used
to disable point-in-segment tests for each segments.  this template
function throws if lines are almost parallel or if intersection point
lies outside segment and associated test is enabled.

double x0() const
.................

Get vector pair component

double & x0()
.............

Get vector pair component

double x1() const
.................

Get vector pair component

double & x1()
.............

Get vector pair component

double y0() const
.................

Get vector pair component

double & y0()
.............

Get vector pair component

double y1() const
.................

Get vector pair component

double & y1()
.............

Get vector pair component

Math::VectorPair<2> struct full member list
===========================================

Functions
---------

   * VectorPair()
   * VectorPair(const VectorPairBase<2> &vp)
   * VectorPair(const Vector<2> &a, const Vector<2> &b)
   * VectorPair(double ax, double ay, double bx, double by)
   * template VectorPair(const VectorPairBase<N> &v, unsigned int c0,
     unsigned int c1)
   * Vector<N> & direction()
   * const Vector<N> & direction() const
   * Vector<2> ln_intersect_ln(const VectorPair<2> &line) const
   * double ln_intersect_ln_scale(const VectorPair<2> &line) const
   * Vector<N> ln_pt_clst_pt(const Vector<N> &point) const
   * double ln_pt_clst_pt_scale(const Vector<N> &point) const
   * Vector<N> & normal()
   * const Vector<N> & normal() const
   * VectorPairBase<2> operator*(double factor)
   * const VectorPairBase<2> & operator+=(const VectorPairBase<2> &p)
   * const Vector<N> & operator[](int n) const
   * Vector<N> & operator[](int n)
   * Vector<N> & origin()
   * const Vector<N> & origin() const
   * template Vector<2> seg_intersect_seg(const VectorPair<2> &segment)
     const
   * Vector<N> seg_pt_clst_pt(const Vector<N> &point) const
   * double seg_pt_clst_pt_scale(const Vector<N> &point) const
   * double x0() const
   * double & x0()
   * double x1() const
   * double & x1()
   * double y0() const
   * double & y0()
   * double y1() const
   * double & y1()

Math::VectorPair<3> struct reference
====================================

Declaration
-----------

     #include <Goptical/Math/VectorPair>

     namespace Goptical {
       namespace Math {
         template <> struct VectorPair<3>;
       };
     };


   This struct is a member of the Math namespace.

   This struct is a specialization of VectorPair (*note
Math_VectorPair_struct_reference::).

Inheritance
-----------

Description
-----------

This class hold two 3d vectors.

   See also VectorPair3 (*note _654::) typedef.

Members
-------

See also the full member list (*note
Math_VectorPair_3_struct_full_member_list::) section for this struct.

Functions
.........

   * VectorPair()
   * VectorPair(const VectorPairBase<3> &vp)
   * VectorPair(const Vector<3> &a, const Vector<3> &b = _[...]_)
   * VectorPair(double ax, double ay, double az, double bx = _[...]_,
     double by = _[...]_, double bz = _[...]_)
   * Vector<N> & direction()
   * const Vector<N> & direction() const
   * Vector<3> ln_ln_clst_pt(const VectorPair<3> &line) const
   * double ln_ln_clst_pt_scale(const VectorPair<3> &line) const
   * Vector<N> ln_pt_clst_pt(const Vector<N> &point) const
   * double ln_pt_clst_pt_scale(const Vector<N> &point) const
   * Vector<N> & normal()
   * const Vector<N> & normal() const
   * VectorPairBase<3> operator*(double factor)
   * const VectorPairBase<3> & operator+=(const VectorPairBase<3> &p)
   * const Vector<N> & operator[](int n) const
   * Vector<N> & operator[](int n)
   * Vector<N> & origin()
   * const Vector<N> & origin() const
   * Vector<3> pl_ln_intersect(const VectorPair<3> &line) const
   * double pl_ln_intersect_scale(const VectorPair<3> &line) const
   * Vector<N> seg_pt_clst_pt(const Vector<N> &point) const
   * double seg_pt_clst_pt_scale(const Vector<N> &point) const
   * double x0() const
   * double & x0()
   * double x1() const
   * double & x1()
   * double y0() const
   * double & y0()
   * double y1() const
   * double & y1()
   * double z0() const
   * double & z0()
   * double z1() const
   * double & z1()

Members detail
--------------

VectorPair()
............

No documentation available

VectorPair(const VectorPairBase<3> &vp)
.......................................

No documentation available

VectorPair(const Vector<3> &a, const Vector<3> &b = vector3_001)
................................................................

No documentation available

VectorPair(double ax, double ay, double az, double bx = 0.0, double by = 0.0, double bz = 1.0)
..............................................................................................

No documentation available

Vector<3> ln_ln_clst_pt(const VectorPair<3> &line) const
........................................................

Consider the VectorPair (*note Math_VectorPair_struct_reference::) as a
line with origin and direction vectors and find the closest point on
this line to an other line.

   The return value is position of the closest point on the line.  this
function throws if lines are almost parallel.

   See also ln_ln_clst_pt_scale (*note _936::) function.

double ln_ln_clst_pt_scale(const VectorPair<3> &line) const
...........................................................

Consider the VectorPair (*note Math_VectorPair_struct_reference::) as a
line with origin and direction vectors and find the closest point on
this line to an other line.

   The return value is scale factor of the direction vector from origin.
this function throws if lines are almost parallel.

   See also ln_ln_clst_pt (*note _935::) function.

Vector<3> pl_ln_intersect(const VectorPair<3> &line) const
..........................................................

Consider the VectorPair (*note Math_VectorPair_struct_reference::) as a
plane and find intersection point with a line.  Plane is defined by
origin and normal vectors and line is defined by origin and direction
vectors.

   The return value is position of the intersection point on the line.

   See also pl_ln_intersect_scale (*note _938::) function.

double pl_ln_intersect_scale(const VectorPair<3> &line) const
.............................................................

Consider the VectorPair (*note Math_VectorPair_struct_reference::) as a
plane and find intersection point with a line.  Plane is defined by
origin and normal vectors and line is defined by origin and direction
vectors.

   The return value is scale factor of the line direction vector from
line origin.

   See also pl_ln_intersect (*note _937::) function.

double x0() const
.................

Get vector pair component

double & x0()
.............

Get vector pair component

double x1() const
.................

Get vector pair component

double & x1()
.............

Get vector pair component

double y0() const
.................

Get vector pair component

double & y0()
.............

Get vector pair component

double y1() const
.................

Get vector pair component

double & y1()
.............

Get vector pair component

double z0() const
.................

Get vector pair component

double & z0()
.............

Get vector pair component

double z1() const
.................

Get vector pair component

double & z1()
.............

Get vector pair component

Math::VectorPair<3> struct full member list
===========================================

Functions
---------

   * VectorPair()
   * VectorPair(const VectorPairBase<3> &vp)
   * VectorPair(const Vector<3> &a, const Vector<3> &b = _[...]_)
   * VectorPair(double ax, double ay, double az, double bx = _[...]_,
     double by = _[...]_, double bz = _[...]_)
   * Vector<N> & direction()
   * const Vector<N> & direction() const
   * Vector<3> ln_ln_clst_pt(const VectorPair<3> &line) const
   * double ln_ln_clst_pt_scale(const VectorPair<3> &line) const
   * Vector<N> ln_pt_clst_pt(const Vector<N> &point) const
   * double ln_pt_clst_pt_scale(const Vector<N> &point) const
   * Vector<N> & normal()
   * const Vector<N> & normal() const
   * VectorPairBase<3> operator*(double factor)
   * const VectorPairBase<3> & operator+=(const VectorPairBase<3> &p)
   * const Vector<N> & operator[](int n) const
   * Vector<N> & operator[](int n)
   * Vector<N> & origin()
   * const Vector<N> & origin() const
   * Vector<3> pl_ln_intersect(const VectorPair<3> &line) const
   * double pl_ln_intersect_scale(const VectorPair<3> &line) const
   * Vector<N> seg_pt_clst_pt(const Vector<N> &point) const
   * double seg_pt_clst_pt_scale(const Vector<N> &point) const
   * double x0() const
   * double & x0()
   * double x1() const
   * double & x1()
   * double y0() const
   * double & y0()
   * double y1() const
   * double & y1()
   * double z0() const
   * double & z0()
   * double z1() const
   * double & z1()

Math::VectorPairBase<N> internal struct members
===============================================

VectorPairBase()
----------------

No documentation available

VectorPairBase(const Vector<N> &a, const Vector<N> &b)
------------------------------------------------------

No documentation available

Vector<N> & direction()
-----------------------

Get reference to second vector

const Vector<N> & direction() const
-----------------------------------

Get reference to second vector

Vector<N> ln_pt_clst_pt(const Vector<N> &point) const
-----------------------------------------------------

Consider the VectorPair (*note Math_VectorPair_struct_reference::) as a
line with origin and direction vectors and find the closest point on
this line to a point.

   The return value is position of the closest point on the line.

   See also ln_pt_clst_pt_scale (*note _1059::) function.

double ln_pt_clst_pt_scale(const Vector<N> &point) const
--------------------------------------------------------

Consider the VectorPair (*note Math_VectorPair_struct_reference::) as a
line with origin and direction vectors and find the closest point on
this line to an other line.

   The return value is scale factor of the direction vector from origin.

   See also ln_pt_clst_pt (*note _1058::) function.

Vector<N> & normal()
--------------------

Get reference to second vector

const Vector<N> & normal() const
--------------------------------

Get reference to second vector

VectorPairBase<N> operator*(double factor)
------------------------------------------

No documentation available

const VectorPairBase<N> & operator+=(const VectorPairBase<N> &p)
----------------------------------------------------------------

No documentation available

const Vector<N> & operator[](int n) const
-----------------------------------------

Get a reference to a vector stored in the pair

Vector<N> & operator[](int n)
-----------------------------

Get a reference to a vector stored in the pair

Vector<N> & origin()
--------------------

Get reference to first vector

const Vector<N> & origin() const
--------------------------------

Get reference to first vector

Vector<N> seg_pt_clst_pt(const Vector<N> &point) const
------------------------------------------------------

Consider the VectorPair (*note Math_VectorPair_struct_reference::) as a
segment with two point vectors and find the closest point on this
segment to a point in space.

   The return value is position of the closest point on segment.

   See also seg_pt_clst_pt_scale (*note _1069::) function.

double seg_pt_clst_pt_scale(const Vector<N> &point) const
---------------------------------------------------------

Consider the VectorPair (*note Math_VectorPair_struct_reference::) as a
segment with two point vectors and find the closest point on this
segment to a point in space.

   The return value is position on segment, value is in [0, 1] range if
on segment.

   See also seg_pt_clst_pt (*note _1068::) function.

Math::VectorPairBase<2> internal struct members
===============================================

VectorPairBase()
----------------

No documentation available

VectorPairBase(const Vector<N> &a, const Vector<N> &b)
------------------------------------------------------

No documentation available

Vector<N> & direction()
-----------------------

Get reference to second vector

const Vector<N> & direction() const
-----------------------------------

Get reference to second vector

Vector<N> ln_pt_clst_pt(const Vector<N> &point) const
-----------------------------------------------------

Consider the VectorPair (*note Math_VectorPair_struct_reference::) as a
line with origin and direction vectors and find the closest point on
this line to a point.

   The return value is position of the closest point on the line.

   See also ln_pt_clst_pt_scale (*note _1059::) function.

double ln_pt_clst_pt_scale(const Vector<N> &point) const
--------------------------------------------------------

Consider the VectorPair (*note Math_VectorPair_struct_reference::) as a
line with origin and direction vectors and find the closest point on
this line to an other line.

   The return value is scale factor of the direction vector from origin.

   See also ln_pt_clst_pt (*note _1058::) function.

Vector<N> & normal()
--------------------

Get reference to second vector

const Vector<N> & normal() const
--------------------------------

Get reference to second vector

VectorPairBase<2> operator*(double factor)
------------------------------------------

No documentation available

const VectorPairBase<2> & operator+=(const VectorPairBase<2> &p)
----------------------------------------------------------------

No documentation available

const Vector<N> & operator[](int n) const
-----------------------------------------

Get a reference to a vector stored in the pair

Vector<N> & operator[](int n)
-----------------------------

Get a reference to a vector stored in the pair

Vector<N> & origin()
--------------------

Get reference to first vector

const Vector<N> & origin() const
--------------------------------

Get reference to first vector

Vector<N> seg_pt_clst_pt(const Vector<N> &point) const
------------------------------------------------------

Consider the VectorPair (*note Math_VectorPair_struct_reference::) as a
segment with two point vectors and find the closest point on this
segment to a point in space.

   The return value is position of the closest point on segment.

   See also seg_pt_clst_pt_scale (*note _1069::) function.

double seg_pt_clst_pt_scale(const Vector<N> &point) const
---------------------------------------------------------

Consider the VectorPair (*note Math_VectorPair_struct_reference::) as a
segment with two point vectors and find the closest point on this
segment to a point in space.

   The return value is position on segment, value is in [0, 1] range if
on segment.

   See also seg_pt_clst_pt (*note _1068::) function.

Math::VectorPairBase<3> internal struct members
===============================================

VectorPairBase()
----------------

No documentation available

VectorPairBase(const Vector<N> &a, const Vector<N> &b)
------------------------------------------------------

No documentation available

Vector<N> & direction()
-----------------------

Get reference to second vector

const Vector<N> & direction() const
-----------------------------------

Get reference to second vector

Vector<N> ln_pt_clst_pt(const Vector<N> &point) const
-----------------------------------------------------

Consider the VectorPair (*note Math_VectorPair_struct_reference::) as a
line with origin and direction vectors and find the closest point on
this line to a point.

   The return value is position of the closest point on the line.

   See also ln_pt_clst_pt_scale (*note _1059::) function.

double ln_pt_clst_pt_scale(const Vector<N> &point) const
--------------------------------------------------------

Consider the VectorPair (*note Math_VectorPair_struct_reference::) as a
line with origin and direction vectors and find the closest point on
this line to an other line.

   The return value is scale factor of the direction vector from origin.

   See also ln_pt_clst_pt (*note _1058::) function.

Vector<N> & normal()
--------------------

Get reference to second vector

const Vector<N> & normal() const
--------------------------------

Get reference to second vector

VectorPairBase<3> operator*(double factor)
------------------------------------------

No documentation available

const VectorPairBase<3> & operator+=(const VectorPairBase<3> &p)
----------------------------------------------------------------

No documentation available

const Vector<N> & operator[](int n) const
-----------------------------------------

Get a reference to a vector stored in the pair

Vector<N> & operator[](int n)
-----------------------------

Get a reference to a vector stored in the pair

Vector<N> & origin()
--------------------

Get reference to first vector

const Vector<N> & origin() const
--------------------------------

Get reference to first vector

Vector<N> seg_pt_clst_pt(const Vector<N> &point) const
------------------------------------------------------

Consider the VectorPair (*note Math_VectorPair_struct_reference::) as a
segment with two point vectors and find the closest point on this
segment to a point in space.

   The return value is position of the closest point on segment.

   See also seg_pt_clst_pt_scale (*note _1069::) function.

double seg_pt_clst_pt_scale(const Vector<N> &point) const
---------------------------------------------------------

Consider the VectorPair (*note Math_VectorPair_struct_reference::) as a
segment with two point vectors and find the closest point on this
segment to a point in space.

   The return value is position on segment, value is in [0, 1] range if
on segment.

   See also seg_pt_clst_pt (*note _1068::) function.

Math::TransformBase internal class members
==========================================

TransformBase()
---------------

No documentation available

virtual ~TransformBase()
------------------------

No documentation available

TransformBase & affine_rotation(unsigned int axis, double dangle)
-----------------------------------------------------------------

apply rotation to current transform (degree)

TransformBase & affine_rotation_rad(unsigned int axis, double rangle)
---------------------------------------------------------------------

apply rotation to current transform (radian)

TransformBase & affine_scaling(const Vector<N> &v)
--------------------------------------------------

apply scaling to current transform

TransformBase & affine_scaling(double s)
----------------------------------------

apply scaling to current transform

TransformBase & apply_translation(const Vector<N> &v)
-----------------------------------------------------

apply translation to current transform

void compose(const TransformBase<N> &t)
---------------------------------------

compose with t.  new transform is equivalent to applying t then this
transform

const Matrix<N> & get_linear() const
------------------------------------

get linear transform matrix

Matrix<N> & get_linear()
------------------------

get linear transform matrix

const Vector<N> & get_translation() const
-----------------------------------------

get translation vector

Vector<N> & get_translation()
-----------------------------

get translation vector

TransformBase inverse() const
-----------------------------

get inverse transformation

void linear_reset()
-------------------

reset linear transform to identity

TransformBase & linear_rotation(unsigned int axis, double dangle)
-----------------------------------------------------------------

apply rotation to current transform (degree) (does not transform
translation vector)

TransformBase & linear_rotation_rad(unsigned int axis, double rangle)
---------------------------------------------------------------------

apply rotation to current transform (radian) (does not transform
translation vector)

TransformBase & linear_scaling(const Vector<N> &v)
--------------------------------------------------

apply linear scaling to current transform (does not transform
translation vector)

TransformBase & linear_scaling(double s)
----------------------------------------

apply scaling to current transform (does not transform translation
vector)

void reset()
------------

reset linear transform to identity and translation to zero

void set_translation(const Vector<N> &v)
----------------------------------------

set current translation

Vector<N> transform(const Vector<N> &v) const
---------------------------------------------

apply affine transform (translation and linear) to vector

VectorPair<N> transform_line(const VectorPair<N> &v) const
----------------------------------------------------------

apply affine transform to line origin and linear to direction

Vector<N> transform_linear(const Vector<N> &v) const
----------------------------------------------------

apply linear transform to vector

VectorPair<N> transform_pair(const VectorPair<N> &p) const
----------------------------------------------------------

apply affine transform to both vectors in pair

Vector<N> transform_translate(const Vector<N> &v) const
-------------------------------------------------------

apply translation to vector

void translation_reset()
------------------------

reset translation to zero

Math::TriangleBase internal struct members
==========================================

TriangleBase()
--------------

No documentation available

TriangleBase(const Vector<N> &a, const Vector<N> &b, const Vector<N> &c)
------------------------------------------------------------------------

Create a triangle from 3 points

Vector<N> get_centroid() const
------------------------------

Get triangle centroid

const Vector<N> & operator[](int n) const
-----------------------------------------

Get point n of the triangle

Vector<N> & operator[](int n)
-----------------------------

Get reference to point n of the triangle

Math::VectorBase internal struct members
========================================

bool close_to(const VectorBase &m, T error = 1 e-8)
---------------------------------------------------

compare two almost equal vectors

T len() const
-------------

Compute vector length

VectorBase magnitude(T newlen) const
------------------------------------

Adjust vector length

VectorBase mul(const VectorBase &v) const
-----------------------------------------

Vector values multiply

VectorBase & neg()
------------------

Negate vector

const VectorBase & normalize()
------------------------------

Normalize vector length

   See also normalized (*note _1036::) function.

VectorBase normalized() const
-----------------------------

Get normalized vector

   See also normalize (*note _1035::) function.

T operator*(const VectorBase &v) const
--------------------------------------

Vector dot product

VectorBase operator*(T scale) const
-----------------------------------

Scale vector

VectorBase operator*(const Matrix<N> &m)
----------------------------------------

Multiply vector with matrix.  See Vector class for matrix/vector
multiplication.

const VectorBase & operator*=(T scale)
--------------------------------------

Multiply by a vector

VectorBase operator+(const VectorBase &v) const
-----------------------------------------------

Add two vectors

const VectorBase & operator+=(const VectorBase &v)
--------------------------------------------------

Add a vector

VectorBase operator-(const VectorBase &v) const
-----------------------------------------------

Subtract two vectors

VectorBase operator-() const
----------------------------

Get negated vector

const VectorBase & operator-=(const VectorBase &v)
--------------------------------------------------

Sutract a vector

VectorBase operator/(T scale) const
-----------------------------------

Scale vector

VectorBase operator/(const VectorBase &v) const
-----------------------------------------------

Vector division

const VectorBase & operator/=(T scale)
--------------------------------------

Divide by a vector

bool operator==(const VectorBase &m) const
------------------------------------------

compare two vectors for equality

T operator[](int n) const
-------------------------

Get value at specified index

T & operator[](int n)
---------------------

Get reference to value at specified index

template <int M> VectorBase<M, T> select(unsigned int bitmask, const VectorBase<M, T> &v) const
-----------------------------------------------------------------------------------------------

Select components from two vectors.  Components which have their
corresponding bit set in the mask are extracted from this vector and
other components are taken from passed vector.

void set(T value)
-----------------

Set the whole vector to the specified value

Math::VectorPairBase internal struct members
============================================

VectorPairBase()
----------------

No documentation available

VectorPairBase(const Vector<N> &a, const Vector<N> &b)
------------------------------------------------------

No documentation available

Vector<N> & direction()
-----------------------

Get reference to second vector

const Vector<N> & direction() const
-----------------------------------

Get reference to second vector

Vector<N> ln_pt_clst_pt(const Vector<N> &point) const
-----------------------------------------------------

Consider the VectorPair (*note Math_VectorPair_struct_reference::) as a
line with origin and direction vectors and find the closest point on
this line to a point.

   The return value is position of the closest point on the line.

   See also ln_pt_clst_pt_scale (*note _1059::) function.

double ln_pt_clst_pt_scale(const Vector<N> &point) const
--------------------------------------------------------

Consider the VectorPair (*note Math_VectorPair_struct_reference::) as a
line with origin and direction vectors and find the closest point on
this line to an other line.

   The return value is scale factor of the direction vector from origin.

   See also ln_pt_clst_pt (*note _1058::) function.

Vector<N> & normal()
--------------------

Get reference to second vector

const Vector<N> & normal() const
--------------------------------

Get reference to second vector

VectorPairBase operator*(double factor)
---------------------------------------

No documentation available

const VectorPairBase & operator+=(const VectorPairBase &p)
----------------------------------------------------------

No documentation available

const Vector<N> & operator[](int n) const
-----------------------------------------

Get a reference to a vector stored in the pair

Vector<N> & operator[](int n)
-----------------------------

Get a reference to a vector stored in the pair

Vector<N> & origin()
--------------------

Get reference to first vector

const Vector<N> & origin() const
--------------------------------

Get reference to first vector

Vector<N> seg_pt_clst_pt(const Vector<N> &point) const
------------------------------------------------------

Consider the VectorPair (*note Math_VectorPair_struct_reference::) as a
segment with two point vectors and find the closest point on this
segment to a point in space.

   The return value is position of the closest point on segment.

   See also seg_pt_clst_pt_scale (*note _1069::) function.

double seg_pt_clst_pt_scale(const Vector<N> &point) const
---------------------------------------------------------

Consider the VectorPair (*note Math_VectorPair_struct_reference::) as a
segment with two point vectors and find the closest point on this
segment to a point in space.

   The return value is position on segment, value is in [0, 1] range if
on segment.

   See also seg_pt_clst_pt (*note _1068::) function.

Shape namespace reference
=========================

Description
-----------

2d shapes used for surface contours

Members
-------

Types
.....

   * class Base
   * class Composer
   * class Disk
   * class Ellipse
   * class EllipticalRing
   * class Infinite
   * class Polygon
   * class Rectangle
   * class RegularPolygon
   * class Ring

Variable
........

   * Infinite infinite

Members detail
--------------

Infinite infinite
.................

No documentation available

Shape::Base class reference
===========================

Declaration
-----------

     #include <Goptical/Shape/Base>

     namespace Goptical {
       namespace Shape {
         class Base;
       };
     };


   This class is a member of the Shape namespace.

   This abstract class contains pure virtuals.

Inheritance
-----------

Description
-----------

This class defines an interface for all 2d shape implementations.  It is
mainly used to describe 2d contours of optical surfaces and provides
distribution pattern for ray tracing.

Members
-------

See also the full member list (*note
Shape_Base_class_full_member_list::) section for this class.

Functions
.........

   * Base()
   * virtual ~Base()
   * virtual Math::VectorPair2 get_bounding_box() const = 0;
   * virtual void get_contour(unsigned int contour, const
     Math::Vector2::put_delegate_t &f, double resolution) const = 0;
   * virtual unsigned int get_contour_count() const = 0;
   * virtual double get_hole_radius(const Math::Vector2 &dir) const
   * virtual double get_outter_radius(const Math::Vector2 &dir) const =
     0;
   * virtual void get_pattern(const Math::Vector2::put_delegate_t &f,
     const Trace::Distribution &d, bool unobstructed = _[...]_)  const
   * virtual void get_triangles(const Math::Triangle<2>::put_delegate_t
     &f, double resolution) const = 0;
   * virtual bool inside(const Math::Vector2 &point) const = 0;
   * virtual double max_radius() const = 0;
   * virtual double min_radius() const = 0;

Members detail
--------------

Base()
......

No documentation available

virtual ~Base()
...............

No documentation available

virtual Math::VectorPair2 get_bounding_box() const = 0;
.......................................................

Get shape bounding box

virtual void get_contour(unsigned int contour, const Math::Vector2::put_delegate_t &f, double resolution) const = 0;
....................................................................................................................

Get contour polygone points for specified contour id.  First contour is
always outter edge.

   See also get_contour_count (*note _1075::) function.

virtual unsigned int get_contour_count() const = 0;
...................................................

Get number of contours polygones.  This function returns value is
greater than 1 if shape has hole(s).

   See also get_contour (*note _1074::) function.

virtual double get_hole_radius(const Math::Vector2 &dir) const
..............................................................

Get distance between origin and nearest shape outter edge in specified
direction

virtual double get_outter_radius(const Math::Vector2 &dir) const = 0;
.....................................................................

Get distance between origin and farthest shape edge in specified
direction

virtual void get_pattern(const Math::Vector2::put_delegate_t &f, const Trace::Distribution &d, bool unobstructed = false) const
...............................................................................................................................

Get points distributed on shape area with given pattern

virtual void get_triangles(const Math::Triangle<2>::put_delegate_t &f, double resolution) const = 0;
....................................................................................................

Get shape teselation triangles

virtual bool inside(const Math::Vector2 &point) const = 0;
..........................................................

Check if the (x,y) 2d point is inside 2d shape area

virtual double max_radius() const = 0;
......................................

Get distance between origin and farthest shape edge

virtual double min_radius() const = 0;
......................................

Get distance between origin and nearest shape outter edge

Shape::Base class full member list
==================================

Functions
---------

   * Base()
   * virtual ~Base()
   * virtual Math::VectorPair2 get_bounding_box() const = 0;
   * virtual void get_contour(unsigned int contour, const
     Math::Vector2::put_delegate_t &f, double resolution) const = 0;
   * virtual unsigned int get_contour_count() const = 0;
   * virtual double get_hole_radius(const Math::Vector2 &dir) const
   * virtual double get_outter_radius(const Math::Vector2 &dir) const =
     0;
   * virtual void get_pattern(const Math::Vector2::put_delegate_t &f,
     const Trace::Distribution &d, bool unobstructed = _[...]_)  const
   * virtual void get_triangles(const Math::Triangle<2>::put_delegate_t
     &f, double resolution) const = 0;
   * virtual bool inside(const Math::Vector2 &point) const = 0;
   * virtual double max_radius() const = 0;
   * virtual double min_radius() const = 0;

Shape::Composer class reference
===============================

Declaration
-----------

This class is flagged as experimental.

     #include <Goptical/Shape/Composer>

     namespace Goptical {
       namespace Shape {
         class Composer;
       };
     };


   This class is a member of the Shape namespace.

Inheritance
-----------

Description
-----------

This class allows definition of a shape by composition of other shape
models.  Coordinate transforms and boolean operations can be performed
on shapes.

   This class is still experimental, 2d contour and 3d tessellation code
doesn't give propser results.

Members
-------

See also the full member list (*note
Shape_Composer_class_full_member_list::) section for this class.

Inherited members
.................

   * 12 members inherited from Base (*note Shape_Base_class_reference::)

Type
....

   * class Attributes

Functions
.........

   * Composer()
   * Attributes & add_shape(const const_ref<Base> &shape)
   * virtual Math::VectorPair2 get_bounding_box() const
   * virtual void get_contour(unsigned int contour, const
     Math::Vector2::put_delegate_t &f, double resolution) const
   * virtual unsigned int get_contour_count() const
   * virtual double get_hole_radius(const Math::Vector2 &dir) const
   * virtual double get_outter_radius(const Math::Vector2 &dir) const
   * virtual void get_pattern(const Math::Vector2::put_delegate_t &f,
     const Trace::Distribution &d, bool unobstructed) const
   * virtual void get_triangles(const Math::Triangle<2>::put_delegate_t
     &f, double resolution) const
   * virtual bool inside(const Math::Vector2 &point) const
   * virtual double max_radius() const
   * virtual double min_radius() const
   * void use_global_distribution(bool use_global)

Members detail
--------------

Composer()
..........

This constructor is flagged as experimental.

Attributes & add_shape(const const_ref <Base> &shape)
.....................................................

This function is flagged as experimental.

   Add a new shape to shape composer.

   This function returns a reference to an Attributes (*note
Shape_Composer_Attributes_class_reference::) object which may be
modified to set shape transform and boolean operations.

   The composed shape is the union between all shapes added with this
function.

virtual Math::VectorPair2 get_bounding_box() const
..................................................

This virtual function is flagged as experimental.

   This virtual function implements the 'get_bounding_box (*note
_1073::)' pure function declared in the 'Base (*note
Shape_Base_class_reference::)' base abstract class.

   Documentation inherited from base class:

   Get shape bounding box

virtual void get_contour(unsigned int contour, const Math::Vector2::put_delegate_t &f, double resolution) const
...............................................................................................................

This virtual function is flagged as experimental.

   This virtual function implements the 'get_contour (*note _1074::)'
pure function declared in the 'Base (*note
Shape_Base_class_reference::)' base abstract class.

   Documentation inherited from base class:

   Get contour polygone points for specified contour id.  First contour
is always outter edge.

   See also get_contour_count (*note _1075::) function.

virtual unsigned int get_contour_count() const
..............................................

This virtual function is flagged as experimental.

   This virtual function implements the 'get_contour_count (*note
_1075::)' pure function declared in the 'Base (*note
Shape_Base_class_reference::)' base abstract class.

   Documentation inherited from base class:

   Get number of contours polygones.  This function returns value is
greater than 1 if shape has hole(s).

   See also get_contour (*note _1074::) function.

virtual double get_hole_radius(const Math::Vector2 &dir) const
..............................................................

This virtual function is flagged as experimental.

   This virtual function overrides the 'get_hole_radius (*note _1076::)'
virtual function defined in the 'Base (*note
Shape_Base_class_reference::)' base abstract class.

   Documentation inherited from base class:

   Get distance between origin and nearest shape outter edge in
specified direction

virtual double get_outter_radius(const Math::Vector2 &dir) const
................................................................

This virtual function is flagged as experimental.

   This virtual function implements the 'get_outter_radius (*note
_1077::)' pure function declared in the 'Base (*note
Shape_Base_class_reference::)' base abstract class.

   Documentation inherited from base class:

   Get distance between origin and farthest shape edge in specified
direction

virtual void get_pattern(const Math::Vector2::put_delegate_t &f, const Trace::Distribution &d, bool unobstructed) const
.......................................................................................................................

This virtual function is flagged as experimental.

   This virtual function overrides the 'get_pattern (*note _1078::)'
virtual function defined in the 'Base (*note
Shape_Base_class_reference::)' base abstract class.

   Documentation inherited from base class:

   Get points distributed on shape area with given pattern

virtual void get_triangles(const Math::Triangle<2>::put_delegate_t &f, double resolution) const
...............................................................................................

This virtual function is flagged as experimental.

   This virtual function implements the 'get_triangles (*note _1079::)'
pure function declared in the 'Base (*note
Shape_Base_class_reference::)' base abstract class.

   Documentation inherited from base class:

   Get shape teselation triangles

virtual bool inside(const Math::Vector2 &point) const
.....................................................

This virtual function is flagged as experimental.

   This virtual function implements the 'inside (*note _1080::)' pure
function declared in the 'Base (*note Shape_Base_class_reference::)'
base abstract class.

   Documentation inherited from base class:

   Check if the (x,y) 2d point is inside 2d shape area

virtual double max_radius() const
.................................

This virtual function is flagged as experimental.

   This virtual function implements the 'max_radius (*note _1081::)'
pure function declared in the 'Base (*note
Shape_Base_class_reference::)' base abstract class.

   Documentation inherited from base class:

   Get distance between origin and farthest shape edge

virtual double min_radius() const
.................................

This virtual function is flagged as experimental.

   This virtual function implements the 'min_radius (*note _1082::)'
pure function declared in the 'Base (*note
Shape_Base_class_reference::)' base abstract class.

   Documentation inherited from base class:

   Get distance between origin and nearest shape outter edge

void use_global_distribution(bool use_global)
.............................................

This function is flagged as experimental.

   Set ray distribution behavior.  Default is to perform individual ray
distribution on each composer shape.

   Global mode distributes rays over a circle with maximum shape radius,
it may be used to ensure ray density is the same on each shape.
Unobstructed ray tracing require global distribution too.

Shape::Composer class full member list
======================================

Type
----

   * class Attributes

Functions
---------

   * Composer()
   * Attributes & add_shape(const const_ref<Base> &shape)
   * virtual Math::VectorPair2 get_bounding_box() const
   * virtual void get_contour(unsigned int contour, const
     Math::Vector2::put_delegate_t &f, double resolution) const
   * virtual unsigned int get_contour_count() const
   * virtual double get_hole_radius(const Math::Vector2 &dir) const
   * virtual double get_outter_radius(const Math::Vector2 &dir) const
   * virtual void get_pattern(const Math::Vector2::put_delegate_t &f,
     const Trace::Distribution &d, bool unobstructed) const
   * virtual void get_triangles(const Math::Triangle<2>::put_delegate_t
     &f, double resolution) const
   * virtual bool inside(const Math::Vector2 &point) const
   * virtual double max_radius() const
   * virtual double min_radius() const
   * void use_global_distribution(bool use_global)

Shape::Composer::Attributes class reference
===========================================

Declaration
-----------

This class is flagged as experimental.

     #include <Goptical/Shape/Composer>

     namespace Goptical {
       namespace Shape {
         class Composer {
           class Attributes;
         };
       };
     };


   This class is a member of the Composer class.

Description
-----------

This class contains child shape transform and boolean operations for the
Composer (*note Shape_Composer_class_reference::) shape class.

Members
-------

See also the full member list (*note
Shape_Composer_Attributes_class_full_member_list::) section for this
class.

Functions
.........

   * Attributes & exclude(const const_ref<Base> &shape)
   * Attributes & include(const const_ref<Base> &shape)
   * Attributes & rotate(double dangle)
   * Attributes & scale(const Math::Vector2 &factor)
   * Attributes & translate(const Math::Vector2 &offset)

Members detail
--------------

Attributes & exclude(const const_ref <Base> &shape)
...................................................

This function is flagged as experimental.

   Peform boolean 'and not' with the given shape

Attributes & include(const const_ref <Base> &shape)
...................................................

This function is flagged as experimental.

   Peform boolean 'and' with the given shape

Attributes & rotate(double dangle)
..................................

This function is flagged as experimental.

   Apply rotation affine transform.  Angle is in degree.

Attributes & scale(const Math::Vector2 &factor)
...............................................

This function is flagged as experimental.

   Apply scaling affine transform using scale factors (xscale, yscale)

Attributes & translate(const Math::Vector2 &offset)
...................................................

This function is flagged as experimental.

   Apply translation transform

Shape::Composer::Attributes class full member list
==================================================

Functions
---------

   * Attributes & exclude(const const_ref<Base> &shape)
   * Attributes & include(const const_ref<Base> &shape)
   * Attributes & rotate(double dangle)
   * Attributes & scale(const Math::Vector2 &factor)
   * Attributes & translate(const Math::Vector2 &offset)

Shape::Disk class reference
===========================

Declaration
-----------

     #include <Goptical/Shape/Disk>

     namespace Goptical {
       namespace Shape {
         class Disk;
       };
     };


   This class is a member of the Shape namespace.

Inheritance
-----------

Description
-----------

This is the most common lens shape.

Members
-------

See also the full member list (*note
Shape_Disk_class_full_member_list::) section for this class.

Inherited members
.................

   * 12 members inherited from Base (*note Shape_Base_class_reference::)

Functions
.........

   * Disk(double radius)
   * virtual void get_contour(unsigned int contour, const
     Math::Vector2::put_delegate_t &f, double resolution) const
   * virtual unsigned int get_contour_count() const
   * virtual void get_pattern(const Math::Vector2::put_delegate_t &v,
     const Trace::Distribution &d, bool unobstructed) const
   * double get_radius(void ) const
   * virtual void get_triangles(const Math::Triangle<2>::put_delegate_t
     &f, double resolution) const
   * void set_radius(double r)

Members detail
--------------

Disk(double radius)
...................

Create a new disk with given radius

Shape::Disk class full member list
==================================

Functions
---------

   * Disk(double radius)
   * virtual void get_contour(unsigned int contour, const
     Math::Vector2::put_delegate_t &f, double resolution) const
   * virtual unsigned int get_contour_count() const
   * virtual double get_hole_radius(const Math::Vector2 &dir) const
   * virtual void get_pattern(const Math::Vector2::put_delegate_t &v,
     const Trace::Distribution &d, bool unobstructed) const
   * double get_radius(void ) const
   * virtual void get_triangles(const Math::Triangle<2>::put_delegate_t
     &f, double resolution) const
   * void set_radius(double r)

Shape::Ellipse class reference
==============================

Declaration
-----------

     #include <Goptical/Shape/Ellipse>

     namespace Goptical {
       namespace Shape {
         class Ellipse;
       };
     };


   This class is a member of the Shape namespace.

Inheritance
-----------

Description
-----------

Ellipse shape

Members
-------

See also the full member list (*note
Shape_Ellipse_class_full_member_list::) section for this class.

Inherited members
.................

   * 12 members inherited from Base (*note Shape_Base_class_reference::)

Functions
.........

   * Ellipse(double x_radius, double y_radius)
   * virtual Math::VectorPair2 get_bounding_box() const
   * virtual void get_contour(unsigned int contour, const
     Math::Vector2::put_delegate_t &f, double resolution) const
   * virtual unsigned int get_contour_count() const
   * virtual double get_outter_radius(const Math::Vector2 &dir) const
   * virtual void get_pattern(const Math::Vector2::put_delegate_t &v,
     const Trace::Distribution &d, bool unobstructed) const
   * virtual void get_triangles(const Math::Triangle<2>::put_delegate_t
     &f, double resolution) const
   * double get_x_radius(void ) const
   * double get_y_radius(void ) const
   * virtual bool inside(const Math::Vector2 &point) const
   * virtual double max_radius() const
   * virtual double min_radius() const
   * void set_radius(double xr, double yr)

Members detail
--------------

Ellipse(double x_radius, double y_radius)
.........................................

Create a new ellipse with given radius

Shape::Ellipse class full member list
=====================================

Functions
---------

   * Ellipse(double x_radius, double y_radius)
   * virtual Math::VectorPair2 get_bounding_box() const
   * virtual void get_contour(unsigned int contour, const
     Math::Vector2::put_delegate_t &f, double resolution) const
   * virtual unsigned int get_contour_count() const
   * virtual double get_hole_radius(const Math::Vector2 &dir) const
   * virtual double get_outter_radius(const Math::Vector2 &dir) const
   * virtual void get_pattern(const Math::Vector2::put_delegate_t &v,
     const Trace::Distribution &d, bool unobstructed) const
   * virtual void get_triangles(const Math::Triangle<2>::put_delegate_t
     &f, double resolution) const
   * double get_x_radius(void ) const
   * double get_y_radius(void ) const
   * virtual bool inside(const Math::Vector2 &point) const
   * virtual double max_radius() const
   * virtual double min_radius() const
   * void set_radius(double xr, double yr)

Shape::EllipticalRing class reference
=====================================

Declaration
-----------

     #include <Goptical/Shape/EllipticalRing>

     namespace Goptical {
       namespace Shape {
         class EllipticalRing;
       };
     };


   This class is a member of the Shape namespace.

Inheritance
-----------

Description
-----------

This is an ellipse shape with a hole in center.

Members
-------

See also the full member list (*note
Shape_EllipticalRing_class_full_member_list::) section for this class.

Inherited members
.................

   * 12 members inherited from Base (*note Shape_Base_class_reference::)

Functions
.........

   * EllipticalRing(double x_radius, double y_radius, double
     x_hole_radius)
   * virtual Math::VectorPair2 get_bounding_box() const
   * virtual void get_contour(unsigned int contour, const
     Math::Vector2::put_delegate_t &f, double resolution) const
   * virtual unsigned int get_contour_count() const
   * virtual double get_hole_radius(const Math::Vector2 &dir) const
   * virtual double get_outter_radius(const Math::Vector2 &dir) const
   * virtual void get_pattern(const Math::Vector2::put_delegate_t &v,
     const Trace::Distribution &d, bool unobstructed) const
   * virtual void get_triangles(const Math::Triangle<2>::put_delegate_t
     &f, double resolution) const
   * double get_x_hole_radius(void ) const
   * double get_x_radius(void ) const
   * double get_y_hole_radius(void ) const
   * double get_y_radius(void ) const
   * virtual bool inside(const Math::Vector2 &point) const
   * virtual double max_radius() const
   * virtual double min_radius() const
   * void set_radius(double x_radius, double y_radius, double
     x_hole_radius)

Members detail
--------------

EllipticalRing(double x_radius, double y_radius, double x_hole_radius)
......................................................................

Create a new elliptical ring with given external ring radius along the x
and y axes and hole radius along the x axis.

Shape::EllipticalRing class full member list
============================================

Functions
---------

   * EllipticalRing(double x_radius, double y_radius, double
     x_hole_radius)
   * virtual Math::VectorPair2 get_bounding_box() const
   * virtual void get_contour(unsigned int contour, const
     Math::Vector2::put_delegate_t &f, double resolution) const
   * virtual unsigned int get_contour_count() const
   * virtual double get_hole_radius(const Math::Vector2 &dir) const
   * virtual double get_outter_radius(const Math::Vector2 &dir) const
   * virtual void get_pattern(const Math::Vector2::put_delegate_t &v,
     const Trace::Distribution &d, bool unobstructed) const
   * virtual void get_triangles(const Math::Triangle<2>::put_delegate_t
     &f, double resolution) const
   * double get_x_hole_radius(void ) const
   * double get_x_radius(void ) const
   * double get_y_hole_radius(void ) const
   * double get_y_radius(void ) const
   * virtual bool inside(const Math::Vector2 &point) const
   * virtual double max_radius() const
   * virtual double min_radius() const
   * void set_radius(double x_radius, double y_radius, double
     x_hole_radius)

Shape::Infinite class reference
===============================

Declaration
-----------

     #include <Goptical/Shape/Infinite>

     namespace Goptical {
       namespace Shape {
         class Infinite;
       };
     };


   This class is a member of the Shape namespace.

Inheritance
-----------

Description
-----------

This class implements an infinite shape with no edge.  Any 2d points is
located inside the shape.  It is useful to describe unbounded image
plane for instance.

   The global variable infinite (*note _1070::) provides an instance of
this class.

Members
-------

See also the full member list (*note
Shape_Infinite_class_full_member_list::) section for this class.

Inherited members
.................

   * 12 members inherited from Base (*note Shape_Base_class_reference::)

Functions
.........

   * Infinite()
   * virtual Math::VectorPair2 get_bounding_box() const
   * virtual void get_contour(unsigned int contour, const
     Math::Vector2::put_delegate_t &f, double resolution) const
   * virtual unsigned int get_contour_count() const
   * virtual double get_outter_radius(const Math::Vector2 &dir) const
   * virtual void get_pattern(const Math::Vector2::put_delegate_t &v,
     const Trace::Distribution &d, bool unobstructed) const
   * virtual void get_triangles(const Math::Triangle<2>::put_delegate_t
     &f, double resolution) const
   * virtual bool inside(const Math::Vector2 &point) const
   * virtual double max_radius() const
   * virtual double min_radius() const

Members detail
--------------

Infinite()
..........

Create an infinite shape

virtual Math::VectorPair2 get_bounding_box() const
..................................................

This virtual function implements the 'get_bounding_box (*note _1073::)'
pure function declared in the 'Base (*note
Shape_Base_class_reference::)' base abstract class.

   Documentation inherited from base class:

   Get shape bounding box

virtual void get_contour(unsigned int contour, const Math::Vector2::put_delegate_t &f, double resolution) const
...............................................................................................................

This virtual function implements the 'get_contour (*note _1074::)' pure
function declared in the 'Base (*note Shape_Base_class_reference::)'
base abstract class.

   Documentation inherited from base class:

   Get contour polygone points for specified contour id.  First contour
is always outter edge.

   See also get_contour_count (*note _1075::) function.

virtual unsigned int get_contour_count() const
..............................................

This virtual function implements the 'get_contour_count (*note _1075::)'
pure function declared in the 'Base (*note
Shape_Base_class_reference::)' base abstract class.

   Documentation inherited from base class:

   Get number of contours polygones.  This function returns value is
greater than 1 if shape has hole(s).

   See also get_contour (*note _1074::) function.

virtual double get_outter_radius(const Math::Vector2 &dir) const
................................................................

This virtual function implements the 'get_outter_radius (*note _1077::)'
pure function declared in the 'Base (*note
Shape_Base_class_reference::)' base abstract class.

   Documentation inherited from base class:

   Get distance between origin and farthest shape edge in specified
direction

virtual void get_pattern(const Math::Vector2::put_delegate_t &v, const Trace::Distribution &d, bool unobstructed) const
.......................................................................................................................

This virtual function overrides the 'get_pattern (*note _1078::)'
virtual function defined in the 'Base (*note
Shape_Base_class_reference::)' base abstract class.

   Documentation inherited from base class:

   Get points distributed on shape area with given pattern

virtual void get_triangles(const Math::Triangle<2>::put_delegate_t &f, double resolution) const
...............................................................................................

This virtual function implements the 'get_triangles (*note _1079::)'
pure function declared in the 'Base (*note
Shape_Base_class_reference::)' base abstract class.

   Documentation inherited from base class:

   Get shape teselation triangles

virtual bool inside(const Math::Vector2 &point) const
.....................................................

This virtual function implements the 'inside (*note _1080::)' pure
function declared in the 'Base (*note Shape_Base_class_reference::)'
base abstract class.

   Documentation inherited from base class:

   Check if the (x,y) 2d point is inside 2d shape area

virtual double max_radius() const
.................................

This virtual function implements the 'max_radius (*note _1081::)' pure
function declared in the 'Base (*note Shape_Base_class_reference::)'
base abstract class.

   Documentation inherited from base class:

   Get distance between origin and farthest shape edge

virtual double min_radius() const
.................................

This virtual function implements the 'min_radius (*note _1082::)' pure
function declared in the 'Base (*note Shape_Base_class_reference::)'
base abstract class.

   Documentation inherited from base class:

   Get distance between origin and nearest shape outter edge

Shape::Infinite class full member list
======================================

Functions
---------

   * Infinite()
   * virtual Math::VectorPair2 get_bounding_box() const
   * virtual void get_contour(unsigned int contour, const
     Math::Vector2::put_delegate_t &f, double resolution) const
   * virtual unsigned int get_contour_count() const
   * virtual double get_hole_radius(const Math::Vector2 &dir) const
   * virtual double get_outter_radius(const Math::Vector2 &dir) const
   * virtual void get_pattern(const Math::Vector2::put_delegate_t &v,
     const Trace::Distribution &d, bool unobstructed) const
   * virtual void get_triangles(const Math::Triangle<2>::put_delegate_t
     &f, double resolution) const
   * virtual bool inside(const Math::Vector2 &point) const
   * virtual double max_radius() const
   * virtual double min_radius() const

Shape::Polygon class reference
==============================

Declaration
-----------

     #include <Goptical/Shape/Polygon>

     namespace Goptical {
       namespace Shape {
         class Polygon;
       };
     };


   This class is a member of the Shape namespace.

Inheritance
-----------

Description
-----------

This class implements the polygon shape.

   Triangle tessellation required for proper 3d display only works with
convex polygons yet.

   See also RegularPolygon (*note
Shape_RegularPolygon_class_reference::) class.

Members
-------

See also the full member list (*note
Shape_Polygon_class_full_member_list::) section for this class.

Inherited members
.................

   * 12 members inherited from Base (*note Shape_Base_class_reference::)

Functions
.........

   * Polygon()
   * unsigned int add_vertex(const Math::Vector2 &v)
   * void delete_vertex(unsigned int id)
   * const Math::Vector2 & get_vertex(unsigned int id)
   * unsigned int get_vertices_count() const
   * void insert_vertex(const Math::Vector2 &v, unsigned int id)

Members detail
--------------

Polygon()
.........

Create a polygon with given radius and edge count

unsigned int add_vertex(const Math::Vector2 &v)
...............................................

No documentation available

void delete_vertex(unsigned int id)
...................................

No documentation available

const Math::Vector2 & get_vertex(unsigned int id)
.................................................

No documentation available

unsigned int get_vertices_count() const
.......................................

No documentation available

void insert_vertex(const Math::Vector2 &v, unsigned int id)
...........................................................

No documentation available

Shape::Polygon class full member list
=====================================

Functions
---------

   * Polygon()
   * unsigned int add_vertex(const Math::Vector2 &v)
   * void delete_vertex(unsigned int id)
   * virtual double get_hole_radius(const Math::Vector2 &dir) const
   * virtual void get_pattern(const Math::Vector2::put_delegate_t &f,
     const Trace::Distribution &d, bool unobstructed = _[...]_)  const
   * const Math::Vector2 & get_vertex(unsigned int id)
   * unsigned int get_vertices_count() const
   * void insert_vertex(const Math::Vector2 &v, unsigned int id)

Shape::Rectangle class reference
================================

Declaration
-----------

     #include <Goptical/Shape/Rectangle>

     namespace Goptical {
       namespace Shape {
         class Rectangle;
       };
     };


   This class is a member of the Shape namespace.

Inheritance
-----------

Description
-----------

Rectangle and square shape

Members
-------

See also the full member list (*note
Shape_Rectangle_class_full_member_list::) section for this class.

Inherited members
.................

   * 12 members inherited from Base (*note Shape_Base_class_reference::)

Functions
.........

   * Rectangle(double width, double height)
   * Rectangle(double sqsize)
   * virtual Math::VectorPair2 get_bounding_box() const
   * virtual void get_contour(unsigned int contour, const
     Math::Vector2::put_delegate_t &f, double resolution) const
   * virtual unsigned int get_contour_count() const
   * virtual double get_outter_radius(const Math::Vector2 &dir) const
   * virtual void get_pattern(const Math::Vector2::put_delegate_t &v,
     const Trace::Distribution &d, bool unobstructed) const
   * virtual void get_triangles(const Math::Triangle<2>::put_delegate_t
     &f, double resolution) const
   * virtual bool inside(const Math::Vector2 &point) const
   * virtual double max_radius() const
   * virtual double min_radius() const

Members detail
--------------

Rectangle(double width, double height)
......................................

Create a rectangle with given width and height

Rectangle(double sqsize)
........................

Create a square with given side length

virtual Math::VectorPair2 get_bounding_box() const
..................................................

This virtual function implements the 'get_bounding_box (*note _1073::)'
pure function declared in the 'Base (*note
Shape_Base_class_reference::)' base abstract class.

   Documentation inherited from base class:

   Get shape bounding box

virtual void get_contour(unsigned int contour, const Math::Vector2::put_delegate_t &f, double resolution) const
...............................................................................................................

This virtual function implements the 'get_contour (*note _1074::)' pure
function declared in the 'Base (*note Shape_Base_class_reference::)'
base abstract class.

   Documentation inherited from base class:

   Get contour polygone points for specified contour id.  First contour
is always outter edge.

   See also get_contour_count (*note _1075::) function.

virtual unsigned int get_contour_count() const
..............................................

This virtual function implements the 'get_contour_count (*note _1075::)'
pure function declared in the 'Base (*note
Shape_Base_class_reference::)' base abstract class.

   Documentation inherited from base class:

   Get number of contours polygones.  This function returns value is
greater than 1 if shape has hole(s).

   See also get_contour (*note _1074::) function.

virtual double get_outter_radius(const Math::Vector2 &dir) const
................................................................

This virtual function implements the 'get_outter_radius (*note _1077::)'
pure function declared in the 'Base (*note
Shape_Base_class_reference::)' base abstract class.

   Documentation inherited from base class:

   Get distance between origin and farthest shape edge in specified
direction

virtual void get_pattern(const Math::Vector2::put_delegate_t &v, const Trace::Distribution &d, bool unobstructed) const
.......................................................................................................................

This virtual function overrides the 'get_pattern (*note _1078::)'
virtual function defined in the 'Base (*note
Shape_Base_class_reference::)' base abstract class.

   Documentation inherited from base class:

   Get points distributed on shape area with given pattern

virtual void get_triangles(const Math::Triangle<2>::put_delegate_t &f, double resolution) const
...............................................................................................

This virtual function implements the 'get_triangles (*note _1079::)'
pure function declared in the 'Base (*note
Shape_Base_class_reference::)' base abstract class.

   Documentation inherited from base class:

   Get shape teselation triangles

virtual bool inside(const Math::Vector2 &point) const
.....................................................

This virtual function implements the 'inside (*note _1080::)' pure
function declared in the 'Base (*note Shape_Base_class_reference::)'
base abstract class.

   Documentation inherited from base class:

   Check if the (x,y) 2d point is inside 2d shape area

virtual double max_radius() const
.................................

This virtual function implements the 'max_radius (*note _1081::)' pure
function declared in the 'Base (*note Shape_Base_class_reference::)'
base abstract class.

   Documentation inherited from base class:

   Get distance between origin and farthest shape edge

virtual double min_radius() const
.................................

This virtual function implements the 'min_radius (*note _1082::)' pure
function declared in the 'Base (*note Shape_Base_class_reference::)'
base abstract class.

   Documentation inherited from base class:

   Get distance between origin and nearest shape outter edge

Shape::Rectangle class full member list
=======================================

Functions
---------

   * Rectangle(double width, double height)
   * Rectangle(double sqsize)
   * virtual Math::VectorPair2 get_bounding_box() const
   * virtual void get_contour(unsigned int contour, const
     Math::Vector2::put_delegate_t &f, double resolution) const
   * virtual unsigned int get_contour_count() const
   * virtual double get_hole_radius(const Math::Vector2 &dir) const
   * virtual double get_outter_radius(const Math::Vector2 &dir) const
   * virtual void get_pattern(const Math::Vector2::put_delegate_t &v,
     const Trace::Distribution &d, bool unobstructed) const
   * virtual void get_triangles(const Math::Triangle<2>::put_delegate_t
     &f, double resolution) const
   * virtual bool inside(const Math::Vector2 &point) const
   * virtual double max_radius() const
   * virtual double min_radius() const

Shape::RegularPolygon class reference
=====================================

Declaration
-----------

     #include <Goptical/Shape/RegularPolygon>

     namespace Goptical {
       namespace Shape {
         class RegularPolygon;
       };
     };


   This class is a member of the Shape namespace.

Inheritance
-----------

Description
-----------

See Polygon (*note Shape_Polygon_class_reference::) class.

Members
-------

See also the full member list (*note
Shape_RegularPolygon_class_full_member_list::) section for this class.

Inherited members
.................

   * 12 members inherited from Base (*note Shape_Base_class_reference::)

Functions
.........

   * RegularPolygon(double radius, unsigned int edge_cnt, double
     degree_angle = _[...]_)
   * virtual Math::VectorPair2 get_bounding_box() const
   * virtual void get_contour(unsigned int contour, const
     Math::Vector2::put_delegate_t &f, double resolution) const
   * virtual unsigned int get_contour_count() const
   * virtual double get_outter_radius(const Math::Vector2 &dir) const
   * virtual void get_triangles(const Math::Triangle<2>::put_delegate_t
     &f, double resolution) const
   * virtual bool inside(const Math::Vector2 &point) const
   * virtual double max_radius() const
   * virtual double min_radius() const

Members detail
--------------

RegularPolygon(double radius, unsigned int edge_cnt, double degree_angle = 0.)
..............................................................................

Create a regular_polygon with given radius and edge count.

virtual Math::VectorPair2 get_bounding_box() const
..................................................

This virtual function implements the 'get_bounding_box (*note _1073::)'
pure function declared in the 'Base (*note
Shape_Base_class_reference::)' base abstract class.

   Documentation inherited from base class:

   Get shape bounding box

virtual void get_contour(unsigned int contour, const Math::Vector2::put_delegate_t &f, double resolution) const
...............................................................................................................

This virtual function implements the 'get_contour (*note _1074::)' pure
function declared in the 'Base (*note Shape_Base_class_reference::)'
base abstract class.

   Documentation inherited from base class:

   Get contour polygone points for specified contour id.  First contour
is always outter edge.

   See also get_contour_count (*note _1075::) function.

virtual unsigned int get_contour_count() const
..............................................

This virtual function implements the 'get_contour_count (*note _1075::)'
pure function declared in the 'Base (*note
Shape_Base_class_reference::)' base abstract class.

   Documentation inherited from base class:

   Get number of contours polygones.  This function returns value is
greater than 1 if shape has hole(s).

   See also get_contour (*note _1074::) function.

virtual double get_outter_radius(const Math::Vector2 &dir) const
................................................................

This virtual function implements the 'get_outter_radius (*note _1077::)'
pure function declared in the 'Base (*note
Shape_Base_class_reference::)' base abstract class.

   Documentation inherited from base class:

   Get distance between origin and farthest shape edge in specified
direction

virtual void get_triangles(const Math::Triangle<2>::put_delegate_t &f, double resolution) const
...............................................................................................

This virtual function implements the 'get_triangles (*note _1079::)'
pure function declared in the 'Base (*note
Shape_Base_class_reference::)' base abstract class.

   Documentation inherited from base class:

   Get shape teselation triangles

virtual bool inside(const Math::Vector2 &point) const
.....................................................

This virtual function implements the 'inside (*note _1080::)' pure
function declared in the 'Base (*note Shape_Base_class_reference::)'
base abstract class.

   Documentation inherited from base class:

   Check if the (x,y) 2d point is inside 2d shape area

virtual double max_radius() const
.................................

This virtual function implements the 'max_radius (*note _1081::)' pure
function declared in the 'Base (*note Shape_Base_class_reference::)'
base abstract class.

   Documentation inherited from base class:

   Get distance between origin and farthest shape edge

virtual double min_radius() const
.................................

This virtual function implements the 'min_radius (*note _1082::)' pure
function declared in the 'Base (*note Shape_Base_class_reference::)'
base abstract class.

   Documentation inherited from base class:

   Get distance between origin and nearest shape outter edge

Shape::RegularPolygon class full member list
============================================

Functions
---------

   * RegularPolygon(double radius, unsigned int edge_cnt, double
     degree_angle = _[...]_)
   * virtual Math::VectorPair2 get_bounding_box() const
   * virtual void get_contour(unsigned int contour, const
     Math::Vector2::put_delegate_t &f, double resolution) const
   * virtual unsigned int get_contour_count() const
   * virtual double get_hole_radius(const Math::Vector2 &dir) const
   * virtual double get_outter_radius(const Math::Vector2 &dir) const
   * virtual void get_pattern(const Math::Vector2::put_delegate_t &f,
     const Trace::Distribution &d, bool unobstructed = _[...]_)  const
   * virtual void get_triangles(const Math::Triangle<2>::put_delegate_t
     &f, double resolution) const
   * virtual bool inside(const Math::Vector2 &point) const
   * virtual double max_radius() const
   * virtual double min_radius() const

Shape::Ring class reference
===========================

Declaration
-----------

     #include <Goptical/Shape/Ring>

     namespace Goptical {
       namespace Shape {
         class Ring;
       };
     };


   This class is a member of the Shape namespace.

Inheritance
-----------

Description
-----------

This is a disk shape with a hole in center.

Members
-------

See also the full member list (*note
Shape_Ring_class_full_member_list::) section for this class.

Inherited members
.................

   * 12 members inherited from Base (*note Shape_Base_class_reference::)

Functions
.........

   * Ring(double radius, double hole_radius)
   * virtual Math::VectorPair2 get_bounding_box() const
   * virtual void get_contour(unsigned int contour, const
     Math::Vector2::put_delegate_t &f, double resolution) const
   * virtual unsigned int get_contour_count() const
   * double get_hole_radius() const
   * virtual double get_hole_radius(const Math::Vector2 &dir) const
   * virtual double get_outter_radius(const Math::Vector2 &dir) const
   * virtual void get_pattern(const Math::Vector2::put_delegate_t &v,
     const Trace::Distribution &d, bool unobstructed) const
   * double get_radius() const
   * virtual void get_triangles(const Math::Triangle<2>::put_delegate_t
     &f, double resolution) const
   * virtual bool inside(const Math::Vector2 &point) const
   * virtual double max_radius() const
   * virtual double min_radius() const
   * void set_radius(double radius, double hole_radius)

Members detail
--------------

Ring(double radius, double hole_radius)
.......................................

Create a new ring with given external radius and hole radius.

Shape::Ring class full member list
==================================

Functions
---------

   * Ring(double radius, double hole_radius)
   * virtual Math::VectorPair2 get_bounding_box() const
   * virtual void get_contour(unsigned int contour, const
     Math::Vector2::put_delegate_t &f, double resolution) const
   * virtual unsigned int get_contour_count() const
   * double get_hole_radius() const
   * virtual double get_hole_radius(const Math::Vector2 &dir) const
   * virtual double get_outter_radius(const Math::Vector2 &dir) const
   * virtual void get_pattern(const Math::Vector2::put_delegate_t &v,
     const Trace::Distribution &d, bool unobstructed) const
   * double get_radius() const
   * virtual void get_triangles(const Math::Triangle<2>::put_delegate_t
     &f, double resolution) const
   * virtual bool inside(const Math::Vector2 &point) const
   * virtual double max_radius() const
   * virtual double min_radius() const
   * void set_radius(double radius, double hole_radius)

Shape::Round<Shape::DiskBase,false> internal class members
==========================================================

virtual void get_contour(unsigned int contour, const Math::Vector2::put_delegate_t &f, double resolution) const
---------------------------------------------------------------------------------------------------------------

This virtual function implements the 'get_contour (*note _1074::)' pure
function declared in the 'Base (*note Shape_Base_class_reference::)'
base abstract class.

   Documentation inherited from base class:

   Get contour polygone points for specified contour id.  First contour
is always outter edge.

   See also get_contour_count (*note _1075::) function.

virtual unsigned int get_contour_count() const
----------------------------------------------

This virtual function implements the 'get_contour_count (*note _1075::)'
pure function declared in the 'Base (*note
Shape_Base_class_reference::)' base abstract class.

   Documentation inherited from base class:

   Get number of contours polygones.  This function returns value is
greater than 1 if shape has hole(s).

   See also get_contour (*note _1074::) function.

virtual void get_pattern(const Math::Vector2::put_delegate_t &v, const Trace::Distribution &d, bool unobstructed) const
-----------------------------------------------------------------------------------------------------------------------

This virtual function overrides the 'get_pattern (*note _1078::)'
virtual function defined in the 'Base (*note
Shape_Base_class_reference::)' base abstract class.

   Documentation inherited from base class:

   Get points distributed on shape area with given pattern

virtual void get_triangles(const Math::Triangle<2>::put_delegate_t &f, double resolution) const
-----------------------------------------------------------------------------------------------

This virtual function implements the 'get_triangles (*note _1079::)'
pure function declared in the 'Base (*note
Shape_Base_class_reference::)' base abstract class.

   Documentation inherited from base class:

   Get shape teselation triangles

Shape::Round<Shape::EllipseBase,false> internal class members
=============================================================

virtual void get_contour(unsigned int contour, const Math::Vector2::put_delegate_t &f, double resolution) const
---------------------------------------------------------------------------------------------------------------

This virtual function implements the 'get_contour (*note _1074::)' pure
function declared in the 'Base (*note Shape_Base_class_reference::)'
base abstract class.

   Documentation inherited from base class:

   Get contour polygone points for specified contour id.  First contour
is always outter edge.

   See also get_contour_count (*note _1075::) function.

virtual unsigned int get_contour_count() const
----------------------------------------------

This virtual function implements the 'get_contour_count (*note _1075::)'
pure function declared in the 'Base (*note
Shape_Base_class_reference::)' base abstract class.

   Documentation inherited from base class:

   Get number of contours polygones.  This function returns value is
greater than 1 if shape has hole(s).

   See also get_contour (*note _1074::) function.

virtual void get_pattern(const Math::Vector2::put_delegate_t &v, const Trace::Distribution &d, bool unobstructed) const
-----------------------------------------------------------------------------------------------------------------------

This virtual function overrides the 'get_pattern (*note _1078::)'
virtual function defined in the 'Base (*note
Shape_Base_class_reference::)' base abstract class.

   Documentation inherited from base class:

   Get points distributed on shape area with given pattern

virtual void get_triangles(const Math::Triangle<2>::put_delegate_t &f, double resolution) const
-----------------------------------------------------------------------------------------------

This virtual function implements the 'get_triangles (*note _1079::)'
pure function declared in the 'Base (*note
Shape_Base_class_reference::)' base abstract class.

   Documentation inherited from base class:

   Get shape teselation triangles

Shape::Round<Shape::EllipticalRingBase,true> internal class members
===================================================================

virtual void get_contour(unsigned int contour, const Math::Vector2::put_delegate_t &f, double resolution) const
---------------------------------------------------------------------------------------------------------------

This virtual function implements the 'get_contour (*note _1074::)' pure
function declared in the 'Base (*note Shape_Base_class_reference::)'
base abstract class.

   Documentation inherited from base class:

   Get contour polygone points for specified contour id.  First contour
is always outter edge.

   See also get_contour_count (*note _1075::) function.

virtual unsigned int get_contour_count() const
----------------------------------------------

This virtual function implements the 'get_contour_count (*note _1075::)'
pure function declared in the 'Base (*note
Shape_Base_class_reference::)' base abstract class.

   Documentation inherited from base class:

   Get number of contours polygones.  This function returns value is
greater than 1 if shape has hole(s).

   See also get_contour (*note _1074::) function.

virtual void get_pattern(const Math::Vector2::put_delegate_t &v, const Trace::Distribution &d, bool unobstructed) const
-----------------------------------------------------------------------------------------------------------------------

This virtual function overrides the 'get_pattern (*note _1078::)'
virtual function defined in the 'Base (*note
Shape_Base_class_reference::)' base abstract class.

   Documentation inherited from base class:

   Get points distributed on shape area with given pattern

virtual void get_triangles(const Math::Triangle<2>::put_delegate_t &f, double resolution) const
-----------------------------------------------------------------------------------------------

This virtual function implements the 'get_triangles (*note _1079::)'
pure function declared in the 'Base (*note
Shape_Base_class_reference::)' base abstract class.

   Documentation inherited from base class:

   Get shape teselation triangles

Shape::Round<Shape::RingBase,true> internal class members
=========================================================

virtual void get_contour(unsigned int contour, const Math::Vector2::put_delegate_t &f, double resolution) const
---------------------------------------------------------------------------------------------------------------

This virtual function implements the 'get_contour (*note _1074::)' pure
function declared in the 'Base (*note Shape_Base_class_reference::)'
base abstract class.

   Documentation inherited from base class:

   Get contour polygone points for specified contour id.  First contour
is always outter edge.

   See also get_contour_count (*note _1075::) function.

virtual unsigned int get_contour_count() const
----------------------------------------------

This virtual function implements the 'get_contour_count (*note _1075::)'
pure function declared in the 'Base (*note
Shape_Base_class_reference::)' base abstract class.

   Documentation inherited from base class:

   Get number of contours polygones.  This function returns value is
greater than 1 if shape has hole(s).

   See also get_contour (*note _1074::) function.

virtual void get_pattern(const Math::Vector2::put_delegate_t &v, const Trace::Distribution &d, bool unobstructed) const
-----------------------------------------------------------------------------------------------------------------------

This virtual function overrides the 'get_pattern (*note _1078::)'
virtual function defined in the 'Base (*note
Shape_Base_class_reference::)' base abstract class.

   Documentation inherited from base class:

   Get points distributed on shape area with given pattern

virtual void get_triangles(const Math::Triangle<2>::put_delegate_t &f, double resolution) const
-----------------------------------------------------------------------------------------------

This virtual function implements the 'get_triangles (*note _1079::)'
pure function declared in the 'Base (*note
Shape_Base_class_reference::)' base abstract class.

   Documentation inherited from base class:

   Get shape teselation triangles

Shape::DiskBase internal class members
======================================

double get_radius(void ) const
------------------------------

Get disk radius

void set_radius(double r)
-------------------------

Set disk radius

Shape::EllipseBase internal class members
=========================================

virtual Math::VectorPair2 get_bounding_box() const
--------------------------------------------------

This virtual function implements the 'get_bounding_box (*note _1073::)'
pure function declared in the 'Base (*note
Shape_Base_class_reference::)' base abstract class.

   Documentation inherited from base class:

   Get shape bounding box

virtual double get_outter_radius(const Math::Vector2 &dir) const
----------------------------------------------------------------

This virtual function implements the 'get_outter_radius (*note _1077::)'
pure function declared in the 'Base (*note
Shape_Base_class_reference::)' base abstract class.

   Documentation inherited from base class:

   Get distance between origin and farthest shape edge in specified
direction

double get_x_radius(void ) const
--------------------------------

Set ellipse radius along x axis

double get_y_radius(void ) const
--------------------------------

Set ellipse radius along y axis

virtual bool inside(const Math::Vector2 &point) const
-----------------------------------------------------

This virtual function implements the 'inside (*note _1080::)' pure
function declared in the 'Base (*note Shape_Base_class_reference::)'
base abstract class.

   Documentation inherited from base class:

   Check if the (x,y) 2d point is inside 2d shape area

virtual double max_radius() const
---------------------------------

This virtual function implements the 'max_radius (*note _1081::)' pure
function declared in the 'Base (*note Shape_Base_class_reference::)'
base abstract class.

   Documentation inherited from base class:

   Get distance between origin and farthest shape edge

virtual double min_radius() const
---------------------------------

This virtual function implements the 'min_radius (*note _1082::)' pure
function declared in the 'Base (*note Shape_Base_class_reference::)'
base abstract class.

   Documentation inherited from base class:

   Get distance between origin and nearest shape outter edge

void set_radius(double xr, double yr)
-------------------------------------

Set ellipse radius along x and y axis

Shape::EllipticalRingBase internal class members
================================================

virtual Math::VectorPair2 get_bounding_box() const
--------------------------------------------------

This virtual function implements the 'get_bounding_box (*note _1073::)'
pure function declared in the 'Base (*note
Shape_Base_class_reference::)' base abstract class.

   Documentation inherited from base class:

   Get shape bounding box

virtual double get_hole_radius(const Math::Vector2 &dir) const
--------------------------------------------------------------

This virtual function overrides the 'get_hole_radius (*note _1076::)'
virtual function defined in the 'Base (*note
Shape_Base_class_reference::)' base abstract class.

   Documentation inherited from base class:

   Get distance between origin and nearest shape outter edge in
specified direction

virtual double get_outter_radius(const Math::Vector2 &dir) const
----------------------------------------------------------------

This virtual function implements the 'get_outter_radius (*note _1077::)'
pure function declared in the 'Base (*note
Shape_Base_class_reference::)' base abstract class.

   Documentation inherited from base class:

   Get distance between origin and farthest shape edge in specified
direction

double get_x_hole_radius(void ) const
-------------------------------------

Get hole radius along the x axis

double get_x_radius(void ) const
--------------------------------

Get external ring radius along the x axis

double get_y_hole_radius(void ) const
-------------------------------------

Get hole radius along the y axis

double get_y_radius(void ) const
--------------------------------

Get external ring radius along the y axis

virtual bool inside(const Math::Vector2 &point) const
-----------------------------------------------------

This virtual function implements the 'inside (*note _1080::)' pure
function declared in the 'Base (*note Shape_Base_class_reference::)'
base abstract class.

   Documentation inherited from base class:

   Check if the (x,y) 2d point is inside 2d shape area

virtual double max_radius() const
---------------------------------

This virtual function implements the 'max_radius (*note _1081::)' pure
function declared in the 'Base (*note Shape_Base_class_reference::)'
base abstract class.

   Documentation inherited from base class:

   Get distance between origin and farthest shape edge

virtual double min_radius() const
---------------------------------

This virtual function implements the 'min_radius (*note _1082::)' pure
function declared in the 'Base (*note Shape_Base_class_reference::)'
base abstract class.

   Documentation inherited from base class:

   Get distance between origin and nearest shape outter edge

void set_radius(double x_radius, double y_radius, double x_hole_radius)
-----------------------------------------------------------------------

Set external ring radius along the x and y axes and hole radius along
the x axis.

Shape::RingBase internal class members
======================================

virtual Math::VectorPair2 get_bounding_box() const
--------------------------------------------------

This virtual function implements the 'get_bounding_box (*note _1073::)'
pure function declared in the 'Base (*note
Shape_Base_class_reference::)' base abstract class.

   Documentation inherited from base class:

   Get shape bounding box

double get_hole_radius() const
------------------------------

Get hole radius

virtual double get_hole_radius(const Math::Vector2 &dir) const
--------------------------------------------------------------

This virtual function overrides the 'get_hole_radius (*note _1076::)'
virtual function defined in the 'Base (*note
Shape_Base_class_reference::)' base abstract class.

   Documentation inherited from base class:

   Get distance between origin and nearest shape outter edge in
specified direction

virtual double get_outter_radius(const Math::Vector2 &dir) const
----------------------------------------------------------------

This virtual function implements the 'get_outter_radius (*note _1077::)'
pure function declared in the 'Base (*note
Shape_Base_class_reference::)' base abstract class.

   Documentation inherited from base class:

   Get distance between origin and farthest shape edge in specified
direction

double get_radius() const
-------------------------

Get ring external radius

virtual bool inside(const Math::Vector2 &point) const
-----------------------------------------------------

This virtual function implements the 'inside (*note _1080::)' pure
function declared in the 'Base (*note Shape_Base_class_reference::)'
base abstract class.

   Documentation inherited from base class:

   Check if the (x,y) 2d point is inside 2d shape area

virtual double max_radius() const
---------------------------------

This virtual function implements the 'max_radius (*note _1081::)' pure
function declared in the 'Base (*note Shape_Base_class_reference::)'
base abstract class.

   Documentation inherited from base class:

   Get distance between origin and farthest shape edge

virtual double min_radius() const
---------------------------------

This virtual function implements the 'min_radius (*note _1082::)' pure
function declared in the 'Base (*note Shape_Base_class_reference::)'
base abstract class.

   Documentation inherited from base class:

   Get distance between origin and nearest shape outter edge

void set_radius(double radius, double hole_radius)
--------------------------------------------------

Set ring external radius and hole radius

Shape::Round internal class members
===================================

void get_contour(unsigned int contour, const Math::Vector2::put_delegate_t &f, double resolution) const
-------------------------------------------------------------------------------------------------------

No documentation available

unsigned int get_contour_count() const
--------------------------------------

No documentation available

void get_pattern(const Math::Vector2::put_delegate_t &v, const Trace::Distribution &d, bool unobstructed) const
---------------------------------------------------------------------------------------------------------------

No documentation available

void get_triangles(const Math::Triangle<2>::put_delegate_t &f, double resolution) const
---------------------------------------------------------------------------------------

No documentation available

Sys namespace reference
=======================

Description
-----------

Optical system and components

Members
-------

Types
.....

   * class Group
   * class Image
   * class Lens
   * class Mirror
   * class OpticalSurface
   * class SourcePoint
   * class SourceRays
   * class System
   * class Container
   * class Element
   * enum LensEdge
   * class Source
   * enum SourceInfinityMode
   * class Stop
   * class Surface

Functions
.........

   * std::ostream & operator<<(std::ostream &o, const Element &e)
   * std::ostream & operator<<(std::ostream &o, const Container &v)

Members detail
--------------

enum LensEdge
.............

Identifier             Description
--------------------------------------------------------------------------
StraightEdge
SlopeEdge

enum SourceInfinityMode
.......................

Specifies point source location mode

Identifier             Description
--------------------------------------------------------------------------
SourceAtFiniteDistance In finite distance mode the point source is
                       located at specified position and all rays are
                       traced from this point.
                       
SourceAtInfinity       In infinity mode the point source generate
                       parallel rays oriented along source direction
                       vector.
                       

std:: ostream & operator<<(std:: ostream &o, const Element &e)
..............................................................

No documentation available

std:: ostream & operator<<(std:: ostream &o, const Container &v)
................................................................

No documentation available

Sys::Group class reference
==========================

Declaration
-----------

     #include <Goptical/Sys/Group>

     namespace Goptical {
       namespace Sys {
         class Group;
       };
     };


   This class is a member of the Sys namespace.

Inheritance
-----------

Description
-----------

This class is used to form a group of optical elements.  A group is a
special kind of optical element which can contains other elements.  A
group has its own local coordinate system.

   See also System hierarchy and groups (*note System hierarchy and
groups::) section.

Members
-------

See also the full member list (*note Sys_Group_class_full_member_list::)
section for this class.

Inherited members
.................

   * 16 members inherited from Container (*note
     Sys_Container_class_reference::)
   * 40 members inherited from Element (*note
     Sys_Element_class_reference::)

Functions
.........

   * Group(const Math::VectorPair3 &p)
   * virtual ~Group()
   * virtual Math::VectorPair3 get_bounding_box() const

Members detail
--------------

Group(const Math::VectorPair3 &p)
.................................

Create a new group at given position

virtual ~Group()
................

No documentation available

virtual Math::VectorPair3 get_bounding_box() const
..................................................

This virtual function overrides the 'get_bounding_box (*note _1288::)'
virtual function defined in the 'Element (*note
Sys_Element_class_reference::)' base class.

   Documentation inherited from base class:

   Get bounding box in local coordinates

Sys::Group class full member list
=================================

Types
-----

   * typedef _ [...]  _ element_list_t
   * typedef _ [...]  _ mod_delegate_t
   * typedef _ [...]  _ put_delegate_t

Functions
---------

   * Group(const Math::VectorPair3 &p)
   * virtual ~Group()
   * void add(const ref<Element> &e)
   * template bool contains(const X *x) const
   * void draw_2d(Io::Renderer &r) const
   * void draw_2d_fit(Io::RendererViewport &r, bool keep_aspect =
     _[...]_)  const
   * void draw_3d(Io::Renderer &r) const
   * void draw_3d_fit(Io::RendererViewport &r, double z_offset =
     _[...]_)  const
   * template void enable_single(const X &e)
   * template X * find() const
   * virtual Math::VectorPair3 get_bounding_box() const
   * Math::Vector3 get_direction(const Element &e) const
   * Math::Vector3 get_direction() const
   * const Container::element_list_t & get_element_list() const
   * template void get_elements(const delegate<void(const X&)> &d) const
   * template void get_elements(const delegate<void(X&)> &d)
   * const Math::Transform<3> & get_global_transform() const
   * Math::Vector3 get_local_direction() const
   * Math::VectorPair3 get_local_plane() const
   * const Math::Vector3 & get_local_position() const
   * const Math::Transform<3> & get_local_transform() const
   * Group * get_parent() const
   * Math::VectorPair3 get_plane() const
   * Math::VectorPair3 get_plane(const Element &e) const
   * Math::Vector3 get_position(const Element &e) const
   * Math::Vector3 get_position() const
   * System * get_system() const
   * const Math::Transform<3> & get_transform() const
   * const Math::Transform<3> & get_transform_from(const Element &e)
     const
   * const Math::Transform<3> & get_transform_from(const Element *e)
     const
   * const Math::Transform<3> & get_transform_to(const Element &e) const
   * const Math::Transform<3> & get_transform_to(const Element *e) const
   * unsigned int get_version() const
   * unsigned int id() const
   * bool is_enabled() const
   * virtual void print(std::ostream &o) const
   * template void process_rays(Trace::Result &result,
     Trace::rays_queue_t *input) const
   * void remove(Element &e)
   * void rotate(double x, double y, double z)
   * void set_direction(const Math::Vector3 &v)
   * void set_enable_state(bool enabled)
   * void set_local_direction(const Math::Vector3 &v)
   * void set_local_plane(const Math::VectorPair3 &p)
   * void set_local_position(const Math::Vector3 &v)
   * void set_plane(const Math::VectorPair3 &p)
   * void set_position(const Math::Vector3 &v)
   * void set_transform(const Math::Transform<3> &t)
   * void update_version()

Sys::Image class reference
==========================

Declaration
-----------

     #include <Goptical/Sys/Image>

     namespace Goptical {
       namespace Sys {
         class Image;
       };
     };


   This class is a member of the Sys namespace.

Inheritance
-----------

Description
-----------

Image plane optical element

Members
-------

See also the full member list (*note Sys_Image_class_full_member_list::)
section for this class.

Inherited members
.................

   * 48 members inherited from Surface (*note
     Sys_Surface_class_reference::)

Functions
.........

   * Image(const Math::VectorPair3 &position, const
     const_ref<Curve::Base> &curve, const const_ref<Shape::Base> &shape)
   * Image(const Math::VectorPair3 &position, double radius)

Members detail
--------------

Image(const Math::VectorPair3 &position, const const_ref <Curve::Base> &curve, const const_ref <Shape::Base> &shape)
....................................................................................................................

Create a new image plane at given position.

Image(const Math::VectorPair3 &position, double radius)
.......................................................

Create a new flat square image plane at given position with given half
width

Sys::Image class full member list
=================================

Types
-----

   * typedef _ [...]  _ mod_delegate_t
   * typedef _ [...]  _ put_delegate_t

Functions
---------

   * Image(const Math::VectorPair3 &position, const
     const_ref<Curve::Base> &curve, const const_ref<Shape::Base> &shape)
   * Image(const Math::VectorPair3 &position, double radius)
   * virtual Math::VectorPair3 get_bounding_box() const
   * virtual Io::Rgb get_color(const Io::Renderer &r) const
   * const Curve::Base & get_curve() const
   * Math::Vector3 get_direction(const Element &e) const
   * Math::Vector3 get_direction() const
   * double get_discard_intensity() const
   * const Math::Transform<3> & get_global_transform() const
   * Math::Vector3 get_local_direction() const
   * Math::VectorPair3 get_local_plane() const
   * const Math::Vector3 & get_local_position() const
   * const Math::Transform<3> & get_local_transform() const
   * Group * get_parent() const
   * void get_pattern(const Math::Vector3::put_delegate_t &f, const
     Trace::Distribution &d, bool unobstructed = _[...]_)  const
   * Math::VectorPair3 get_plane() const
   * Math::VectorPair3 get_plane(const Element &e) const
   * Math::Vector3 get_position(const Element &e) const
   * Math::Vector3 get_position() const
   * const Shape::Base & get_shape() const
   * System * get_system() const
   * const Math::Transform<3> & get_transform() const
   * const Math::Transform<3> & get_transform_from(const Element &e)
     const
   * const Math::Transform<3> & get_transform_from(const Element *e)
     const
   * const Math::Transform<3> & get_transform_to(const Element &e) const
   * const Math::Transform<3> & get_transform_to(const Element *e) const
   * unsigned int get_version() const
   * unsigned int id() const
   * virtual bool intersect(const Trace::Params &params,
     Math::VectorPair3 &pt, const Math::VectorPair3 &ray) const
   * bool is_enabled() const
   * virtual void print(std::ostream &o) const
   * template void process_rays(Trace::Result &result,
     Trace::rays_queue_t *input) const
   * void rotate(double x, double y, double z)
   * void set_curve(const const_ref<Curve::Base> &c)
   * void set_direction(const Math::Vector3 &v)
   * void set_discard_intensity(double intensity)
   * void set_enable_state(bool enabled)
   * void set_local_direction(const Math::Vector3 &v)
   * void set_local_plane(const Math::VectorPair3 &p)
   * void set_local_position(const Math::Vector3 &v)
   * void set_plane(const Math::VectorPair3 &p)
   * void set_position(const Math::Vector3 &v)
   * void set_shape(const const_ref<Shape::Base> &s)
   * void set_transform(const Math::Transform<3> &t)
   * template void trace_ray(Trace::Result &result, Trace::Ray
     &incident, const Math::VectorPair3 &local, const Math::VectorPair3
     &intersect) const
   * void update_version()

Sys::Lens class reference
=========================

Declaration
-----------

     #include <Goptical/Sys/Lens>

     namespace Goptical {
       namespace Sys {
         class Lens;
       };
     };


   This class is a member of the Sys namespace.

Inheritance
-----------

Description
-----------

This class is a group (*note Sys_Group_class_reference::) of optical
surfaces (*note Sys_OpticalSurface_class_reference::).  It contains
functions to describe a lens or lens group component in a convenient
way.

   If Material::none (*note _528::) is passed as material, it will be
replaced by system environement proxy (*note
Material_Proxy_class_reference::) material when the optical surface
becomes part of a System (*note Sys_System_class_reference::).

   See also The Lens component (*note The Lens component::) section.

Members
-------

See also the full member list (*note Sys_Lens_class_full_member_list::)
section for this class.

Inherited members
.................

   * 51 members inherited from Group (*note Sys_Group_class_reference::)

Functions
.........

   * Lens(const Math::VectorPair3 &p, double offset = _[...]_, const
     const_ref<Material::Base> &env = _[...]_)
   * Lens(const Math::VectorPair3 &p, const const_ref<Curve::Base>
     &curve0, const const_ref<Shape::Base> &shape0, const
     const_ref<Curve::Base> &curve1, const const_ref<Shape::Base>
     &shape1, double thickness0, const const_ref<Material::Base>
     &glass0, const const_ref<Material::Base> &env = _[...]_)
   * Lens(const Math::VectorPair3 &p, double roc0, double ap_radius0,
     double roc1, double ap_radius1, double thickness, const
     const_ref<Material::Base> &glass0, const const_ref<Material::Base>
     &env = _[...]_)
   * virtual ~Lens()
   * void add_stop(const const_ref<Shape::Base> &shape, double
     thickness)
   * void add_stop(double ap_radius, double thickness)
   * unsigned int add_surface(const const_ref<Curve::Base> &curve, const
     const_ref<Shape::Base> &shape, double thickness = _[...]_, const
     const_ref<Material::Base> &glass = _[...]_)
   * unsigned int add_surface(double roc, double ap_radius, double
     thickness = _[...]_, const const_ref<Material::Base> &glass =
     _[...]_)
   * Math::VectorPair3 get_exit_plane() const
   * const OpticalSurface & get_left_surface() const
   * OpticalSurface & get_left_surface()
   * const OpticalSurface & get_right_surface() const
   * OpticalSurface & get_right_surface()
   * const OpticalSurface & get_surface(unsigned int index) const
   * OpticalSurface & get_surface(unsigned int index)
   * double get_thickness(unsigned int index = _[...]_)  const
   * void set_curve(const const_ref<Curve::Base> &c, unsigned int index)
   * void set_glass_material(const const_ref<Material::Base> &m,
     unsigned int index = _[...]_)
   * void set_left_curve(const const_ref<Curve::Base> &c)
   * void set_left_material(const const_ref<Material::Base> &m)
   * void set_right_curve(const const_ref<Curve::Base> &c)
   * void set_right_material(const const_ref<Material::Base> &m)
   * void set_shape(const const_ref<Shape::Base> &s)
   * void set_shape(const const_ref<Shape::Base> &s, unsigned int index)
   * void set_thickness(double thickness, unsigned int index = _[...]_)

Members detail
--------------

Lens(const Math::VectorPair3 &p, double offset = 0., const const_ref <Material::Base> &env = Material::none)
............................................................................................................

Create an empty lens.  Surfaces can be added with the add_surface (*note
_1206::) functions.

Lens(const Math::VectorPair3 &p, const const_ref <Curve::Base> &curve0, const const_ref <Shape::Base> &shape0, const const_ref <Curve::Base> &curve1, const const_ref <Shape::Base> &shape1, double thickness0, const const_ref <Material::Base> &glass0, const const_ref <Material::Base> &env = Material::none)
.................................................................................................................................................................................................................................................................................................................

Create a lens at given position with given thickness, shapes, curvatures
and glass.

   See also add_surface (*note _1206::) function.

Lens(const Math::VectorPair3 &p, double roc0, double ap_radius0, double roc1, double ap_radius1, double thickness, const const_ref <Material::Base> &glass0, const const_ref <Material::Base> &env = Material::none)
....................................................................................................................................................................................................................

Create a circular lens with flat or spherical surfaces at given position
with given thickness, radius of curvature, aperture radius and glass.

   See also add_surface (*note _1207::) function.

virtual ~Lens()
...............

No documentation available

void add_stop(const const_ref <Shape::Base> &shape, double thickness)
.....................................................................

Add an aperture stop with given, shape and thickness.

void add_stop(double ap_radius, double thickness)
.................................................

Add an aperture stop with circular aperture.

   Parameters list:

   * radius: circular aperture radius.
   * thickness: distance to the next stop or exit plane.  .

unsigned int add_surface(const const_ref <Curve::Base> &curve, const const_ref <Shape::Base> &shape, double thickness = 0., const const_ref <Material::Base> &glass = Material::none)
.....................................................................................................................................................................................

Add an optical surface with given curve, shape, thickness and material.

unsigned int add_surface(double roc, double ap_radius, double thickness = 0., const const_ref <Material::Base> &glass = Material::none)
.......................................................................................................................................

Add a spherical or flat optical surface with circular aperture.

   Parameters list:

   * roc: spherical radius of curvature.  0 means flat curve.
   * ap_radius: circular aperture radius.
   * thickness: distance to the next surface or exit plane.  .
   * glass: material between added surface and next surface.

Math::VectorPair3 get_exit_plane() const
........................................

Get plane of last surface + thickness z offset

const OpticalSurface & get_left_surface() const
...............................................

Get a reference to left optical surface element

OpticalSurface & get_left_surface()
...................................

Get a reference to left optical surface element

const OpticalSurface & get_right_surface() const
................................................

Get a reference to right optical surface element

OpticalSurface & get_right_surface()
....................................

Get a reference to right optical surface element

const OpticalSurface & get_surface(unsigned int index) const
............................................................

Get a reference to optical surface at given index

OpticalSurface & get_surface(unsigned int index)
................................................

Get a reference to optical surface at given index

double get_thickness(unsigned int index = 0) const
..................................................

Get thickness between two surfaces

void set_curve(const const_ref <Curve::Base> &c, unsigned int index)
....................................................................

Set curve of given surface index

void set_glass_material(const const_ref <Material::Base> &m, unsigned int index = 0)
....................................................................................

Set glass material

void set_left_curve(const const_ref <Curve::Base> &c)
.....................................................

Set left curve

void set_left_material(const const_ref <Material::Base> &m)
...........................................................

Set left material

void set_right_curve(const const_ref <Curve::Base> &c)
......................................................

Set right curve

void set_right_material(const const_ref <Material::Base> &m)
............................................................

Set left material

void set_shape(const const_ref <Shape::Base> &s)
................................................

Set lens shape (all surfaces)

void set_shape(const const_ref <Shape::Base> &s, unsigned int index)
....................................................................

Set lens shape of given surface index

void set_thickness(double thickness, unsigned int index = 0)
............................................................

Adjust thickness between two surfaces

Sys::Lens class full member list
================================

Types
-----

   * typedef _ [...]  _ element_list_t
   * typedef _ [...]  _ mod_delegate_t
   * typedef _ [...]  _ put_delegate_t

Functions
---------

   * Lens(const Math::VectorPair3 &p, double offset = _[...]_, const
     const_ref<Material::Base> &env = _[...]_)
   * Lens(const Math::VectorPair3 &p, const const_ref<Curve::Base>
     &curve0, const const_ref<Shape::Base> &shape0, const
     const_ref<Curve::Base> &curve1, const const_ref<Shape::Base>
     &shape1, double thickness0, const const_ref<Material::Base>
     &glass0, const const_ref<Material::Base> &env = _[...]_)
   * Lens(const Math::VectorPair3 &p, double roc0, double ap_radius0,
     double roc1, double ap_radius1, double thickness, const
     const_ref<Material::Base> &glass0, const const_ref<Material::Base>
     &env = _[...]_)
   * virtual ~Lens()
   * void add_stop(const const_ref<Shape::Base> &shape, double
     thickness)
   * void add_stop(double ap_radius, double thickness)
   * unsigned int add_surface(const const_ref<Curve::Base> &curve, const
     const_ref<Shape::Base> &shape, double thickness = _[...]_, const
     const_ref<Material::Base> &glass = _[...]_)
   * unsigned int add_surface(double roc, double ap_radius, double
     thickness = _[...]_, const const_ref<Material::Base> &glass =
     _[...]_)
   * template bool contains(const X *x) const
   * void draw_2d(Io::Renderer &r) const
   * void draw_2d_fit(Io::RendererViewport &r, bool keep_aspect =
     _[...]_)  const
   * void draw_3d(Io::Renderer &r) const
   * void draw_3d_fit(Io::RendererViewport &r, double z_offset =
     _[...]_)  const
   * template void enable_single(const X &e)
   * template X * find() const
   * virtual Math::VectorPair3 get_bounding_box() const
   * Math::Vector3 get_direction(const Element &e) const
   * Math::Vector3 get_direction() const
   * const Container::element_list_t & get_element_list() const
   * template void get_elements(const delegate<void(const X&)> &d) const
   * template void get_elements(const delegate<void(X&)> &d)
   * Math::VectorPair3 get_exit_plane() const
   * const Math::Transform<3> & get_global_transform() const
   * const OpticalSurface & get_left_surface() const
   * OpticalSurface & get_left_surface()
   * Math::Vector3 get_local_direction() const
   * Math::VectorPair3 get_local_plane() const
   * const Math::Vector3 & get_local_position() const
   * const Math::Transform<3> & get_local_transform() const
   * Group * get_parent() const
   * Math::VectorPair3 get_plane() const
   * Math::VectorPair3 get_plane(const Element &e) const
   * Math::Vector3 get_position(const Element &e) const
   * Math::Vector3 get_position() const
   * const OpticalSurface & get_right_surface() const
   * OpticalSurface & get_right_surface()
   * const OpticalSurface & get_surface(unsigned int index) const
   * OpticalSurface & get_surface(unsigned int index)
   * System * get_system() const
   * double get_thickness(unsigned int index = _[...]_)  const
   * const Math::Transform<3> & get_transform() const
   * const Math::Transform<3> & get_transform_from(const Element &e)
     const
   * const Math::Transform<3> & get_transform_from(const Element *e)
     const
   * const Math::Transform<3> & get_transform_to(const Element &e) const
   * const Math::Transform<3> & get_transform_to(const Element *e) const
   * unsigned int get_version() const
   * unsigned int id() const
   * bool is_enabled() const
   * virtual void print(std::ostream &o) const
   * template void process_rays(Trace::Result &result,
     Trace::rays_queue_t *input) const
   * void rotate(double x, double y, double z)
   * void set_curve(const const_ref<Curve::Base> &c, unsigned int index)
   * void set_direction(const Math::Vector3 &v)
   * void set_enable_state(bool enabled)
   * void set_glass_material(const const_ref<Material::Base> &m,
     unsigned int index = _[...]_)
   * void set_left_curve(const const_ref<Curve::Base> &c)
   * void set_left_material(const const_ref<Material::Base> &m)
   * void set_local_direction(const Math::Vector3 &v)
   * void set_local_plane(const Math::VectorPair3 &p)
   * void set_local_position(const Math::Vector3 &v)
   * void set_plane(const Math::VectorPair3 &p)
   * void set_position(const Math::Vector3 &v)
   * void set_right_curve(const const_ref<Curve::Base> &c)
   * void set_right_material(const const_ref<Material::Base> &m)
   * void set_shape(const const_ref<Shape::Base> &s)
   * void set_shape(const const_ref<Shape::Base> &s, unsigned int index)
   * void set_thickness(double thickness, unsigned int index = _[...]_)
   * void set_transform(const Math::Transform<3> &t)
   * void update_version()

Sys::Mirror class reference
===========================

Declaration
-----------

     #include <Goptical/Sys/Mirror>

     namespace Goptical {
       namespace Sys {
         class Mirror;
       };
     };


   This class is a member of the Sys namespace.

Inheritance
-----------

Description
-----------

This class provide a convenient way to describe a reflecting optical
surface.  Light is reflected only on 1 side of the surface.

Members
-------

See also the full member list (*note
Sys_Mirror_class_full_member_list::) section for this class.

Inherited members
.................

   * 51 members inherited from OpticalSurface (*note
     Sys_OpticalSurface_class_reference::)

Functions
.........

   * Mirror(const Math::VectorPair3 &p, const const_ref<Curve::Base>
     &curve, const const_ref<Shape::Base> &shape, bool light_from_left =
     _[...]_, const const_ref<Material::Base> &metal = _[...]_, const
     const_ref<Material::Base> &env = _[...]_)
   * Mirror(const Math::VectorPair3 &p, const const_ref<Curve::Base>
     &curve, double ap_radius, bool light_from_left = _[...]_, const
     const_ref<Material::Base> &metal = _[...]_, const
     const_ref<Material::Base> &env = _[...]_)
   * Mirror(const Math::VectorPair3 &p, double roc, double sc, double
     ap_radius, bool light_from_left = _[...]_, const
     const_ref<Material::Base> &metal = _[...]_, const
     const_ref<Material::Base> &env = _[...]_)

Members detail
--------------

Mirror(const Math::VectorPair3 &p, const const_ref <Curve::Base> &curve, const const_ref <Shape::Base> &shape, bool light_from_left = true, const const_ref <Material::Base> &metal = Material::mirror, const const_ref <Material::Base> &env = Material::none)
...............................................................................................................................................................................................................................................................

Create a mirror at given position with given shape and curve.  Default
is to reflect light coming from left using Material::mirror (*note
_527::) material.

Mirror(const Math::VectorPair3 &p, const const_ref <Curve::Base> &curve, double ap_radius, bool light_from_left = true, const const_ref <Material::Base> &metal = Material::mirror, const const_ref <Material::Base> &env = Material::none)
...........................................................................................................................................................................................................................................

Create a circular aperture mirror at given position with given curve.
Default is to reflect light coming from left using Material::mirror
(*note _527::) material.

Mirror(const Math::VectorPair3 &p, double roc, double sc, double ap_radius, bool light_from_left = true, const const_ref <Material::Base> &metal = Material::mirror, const const_ref <Material::Base> &env = Material::none)
............................................................................................................................................................................................................................

Create a conic mirror with circular aperture at given position.  Default
is to reflect light coming from left using Material::mirror (*note
_527::) material.

Sys::Mirror class full member list
==================================

Types
-----

   * typedef _ [...]  _ mod_delegate_t
   * typedef _ [...]  _ put_delegate_t

Functions
---------

   * Mirror(const Math::VectorPair3 &p, const const_ref<Curve::Base>
     &curve, const const_ref<Shape::Base> &shape, bool light_from_left =
     _[...]_, const const_ref<Material::Base> &metal = _[...]_, const
     const_ref<Material::Base> &env = _[...]_)
   * Mirror(const Math::VectorPair3 &p, const const_ref<Curve::Base>
     &curve, double ap_radius, bool light_from_left = _[...]_, const
     const_ref<Material::Base> &metal = _[...]_, const
     const_ref<Material::Base> &env = _[...]_)
   * Mirror(const Math::VectorPair3 &p, double roc, double sc, double
     ap_radius, bool light_from_left = _[...]_, const
     const_ref<Material::Base> &metal = _[...]_, const
     const_ref<Material::Base> &env = _[...]_)
   * virtual Math::VectorPair3 get_bounding_box() const
   * virtual Io::Rgb get_color(const Io::Renderer &r) const
   * const Curve::Base & get_curve() const
   * Math::Vector3 get_direction(const Element &e) const
   * Math::Vector3 get_direction() const
   * double get_discard_intensity() const
   * const Math::Transform<3> & get_global_transform() const
   * Math::Vector3 get_local_direction() const
   * Math::VectorPair3 get_local_plane() const
   * const Math::Vector3 & get_local_position() const
   * const Math::Transform<3> & get_local_transform() const
   * const Material::Base & get_material(unsigned int id) const
   * Group * get_parent() const
   * void get_pattern(const Math::Vector3::put_delegate_t &f, const
     Trace::Distribution &d, bool unobstructed = _[...]_)  const
   * Math::VectorPair3 get_plane() const
   * Math::VectorPair3 get_plane(const Element &e) const
   * Math::Vector3 get_position(const Element &e) const
   * Math::Vector3 get_position() const
   * const Shape::Base & get_shape() const
   * System * get_system() const
   * const Math::Transform<3> & get_transform() const
   * const Math::Transform<3> & get_transform_from(const Element &e)
     const
   * const Math::Transform<3> & get_transform_from(const Element *e)
     const
   * const Math::Transform<3> & get_transform_to(const Element &e) const
   * const Math::Transform<3> & get_transform_to(const Element *e) const
   * unsigned int get_version() const
   * unsigned int id() const
   * virtual bool intersect(const Trace::Params &params,
     Math::VectorPair3 &pt, const Math::VectorPair3 &ray) const
   * bool is_enabled() const
   * template void process_rays(Trace::Result &result,
     Trace::rays_queue_t *input) const
   * void rotate(double x, double y, double z)
   * void set_curve(const const_ref<Curve::Base> &c)
   * void set_direction(const Math::Vector3 &v)
   * void set_discard_intensity(double intensity)
   * void set_enable_state(bool enabled)
   * void set_local_direction(const Math::Vector3 &v)
   * void set_local_plane(const Math::VectorPair3 &p)
   * void set_local_position(const Math::Vector3 &v)
   * void set_material(unsigned int index, const
     const_ref<Material::Base> &m)
   * void set_plane(const Math::VectorPair3 &p)
   * void set_position(const Math::Vector3 &v)
   * void set_shape(const const_ref<Shape::Base> &s)
   * void set_transform(const Math::Transform<3> &t)
   * template void trace_ray(Trace::Result &result, Trace::Ray
     &incident, const Math::VectorPair3 &local, const Math::VectorPair3
     &intersect) const
   * void update_version()

Sys::OpticalSurface class reference
===================================

Declaration
-----------

     #include <Goptical/Sys/OpticalSurface>

     namespace Goptical {
       namespace Sys {
         class OpticalSurface;
       };
     };


   This class is a member of the Sys namespace.

Inheritance
-----------

Description
-----------

This class implements optical surfaces.

   Optical surfaces are defined by material on both side of the surface,
curve and contour shape.  This class handle light rays refraction and
reflection.

   If Material::none (*note _528::) is passed as material, it will be
replaced by system environement proxy (*note
Material_Proxy_class_reference::) material when the optical surface
becomes part of a System (*note Sys_System_class_reference::).

Members
-------

See also the full member list (*note
Sys_OpticalSurface_class_full_member_list::) section for this class.

Inherited members
.................

   * 48 members inherited from Surface (*note
     Sys_Surface_class_reference::)

Functions
.........

   * OpticalSurface(const Math::VectorPair3 &p, const
     const_ref<Curve::Base> &curve, const const_ref<Shape::Base> &shape,
     const const_ref<Material::Base> &left, const
     const_ref<Material::Base> &right)
   * OpticalSurface(const Math::VectorPair3 &p, const
     const_ref<Curve::Base> &curve, double ap_radius, const
     const_ref<Material::Base> &left, const const_ref<Material::Base>
     &right)
   * OpticalSurface(const Math::VectorPair3 &p, double roc, double
     ap_radius, const const_ref<Material::Base> &left, const
     const_ref<Material::Base> &right)
   * virtual ~OpticalSurface()
   * virtual Io::Rgb get_color(const Io::Renderer &r) const
   * const Material::Base & get_material(unsigned int id) const
   * void set_material(unsigned int index, const
     const_ref<Material::Base> &m)

Members detail
--------------

OpticalSurface(const Math::VectorPair3 &p, const const_ref <Curve::Base> &curve, const const_ref <Shape::Base> &shape, const const_ref <Material::Base> &left, const const_ref <Material::Base> &right)
.......................................................................................................................................................................................................

Create an optical surface at specified location.

OpticalSurface(const Math::VectorPair3 &p, const const_ref <Curve::Base> &curve, double ap_radius, const const_ref <Material::Base> &left, const const_ref <Material::Base> &right)
...................................................................................................................................................................................

Create a circular aperture optical surface at specified location.

   * ap_radius: circular aperture radius.

OpticalSurface(const Math::VectorPair3 &p, double roc, double ap_radius, const const_ref <Material::Base> &left, const const_ref <Material::Base> &right)
.........................................................................................................................................................

Create a spherical optical surface with circular aperture at specified
location.

   * roc: spherical radius of curvature.  0 means flat curve.
   * ap_radius: circular aperture radius.

virtual ~OpticalSurface()
.........................

No documentation available

virtual Io::Rgb get_color(const Io::Renderer &r) const
......................................................

This virtual function overrides the 'get_color (*note _1343::)' virtual
function defined in the 'Surface (*note Sys_Surface_class_reference::)'
base class.

   Get surface natural color from material properties.

const Material::Base & get_material(unsigned int id) const
..........................................................

Get surface left or right material

void set_material(unsigned int index, const const_ref <Material::Base> &m)
..........................................................................

Set surface left or right material

Sys::OpticalSurface class full member list
==========================================

Types
-----

   * typedef _ [...]  _ mod_delegate_t
   * typedef _ [...]  _ put_delegate_t

Functions
---------

   * OpticalSurface(const Math::VectorPair3 &p, const
     const_ref<Curve::Base> &curve, const const_ref<Shape::Base> &shape,
     const const_ref<Material::Base> &left, const
     const_ref<Material::Base> &right)
   * OpticalSurface(const Math::VectorPair3 &p, const
     const_ref<Curve::Base> &curve, double ap_radius, const
     const_ref<Material::Base> &left, const const_ref<Material::Base>
     &right)
   * OpticalSurface(const Math::VectorPair3 &p, double roc, double
     ap_radius, const const_ref<Material::Base> &left, const
     const_ref<Material::Base> &right)
   * virtual ~OpticalSurface()
   * virtual Math::VectorPair3 get_bounding_box() const
   * virtual Io::Rgb get_color(const Io::Renderer &r) const
   * const Curve::Base & get_curve() const
   * Math::Vector3 get_direction(const Element &e) const
   * Math::Vector3 get_direction() const
   * double get_discard_intensity() const
   * const Math::Transform<3> & get_global_transform() const
   * Math::Vector3 get_local_direction() const
   * Math::VectorPair3 get_local_plane() const
   * const Math::Vector3 & get_local_position() const
   * const Math::Transform<3> & get_local_transform() const
   * const Material::Base & get_material(unsigned int id) const
   * Group * get_parent() const
   * void get_pattern(const Math::Vector3::put_delegate_t &f, const
     Trace::Distribution &d, bool unobstructed = _[...]_)  const
   * Math::VectorPair3 get_plane() const
   * Math::VectorPair3 get_plane(const Element &e) const
   * Math::Vector3 get_position(const Element &e) const
   * Math::Vector3 get_position() const
   * const Shape::Base & get_shape() const
   * System * get_system() const
   * const Math::Transform<3> & get_transform() const
   * const Math::Transform<3> & get_transform_from(const Element &e)
     const
   * const Math::Transform<3> & get_transform_from(const Element *e)
     const
   * const Math::Transform<3> & get_transform_to(const Element &e) const
   * const Math::Transform<3> & get_transform_to(const Element *e) const
   * unsigned int get_version() const
   * unsigned int id() const
   * virtual bool intersect(const Trace::Params &params,
     Math::VectorPair3 &pt, const Math::VectorPair3 &ray) const
   * bool is_enabled() const
   * template void process_rays(Trace::Result &result,
     Trace::rays_queue_t *input) const
   * void rotate(double x, double y, double z)
   * void set_curve(const const_ref<Curve::Base> &c)
   * void set_direction(const Math::Vector3 &v)
   * void set_discard_intensity(double intensity)
   * void set_enable_state(bool enabled)
   * void set_local_direction(const Math::Vector3 &v)
   * void set_local_plane(const Math::VectorPair3 &p)
   * void set_local_position(const Math::Vector3 &v)
   * void set_material(unsigned int index, const
     const_ref<Material::Base> &m)
   * void set_plane(const Math::VectorPair3 &p)
   * void set_position(const Math::Vector3 &v)
   * void set_shape(const const_ref<Shape::Base> &s)
   * void set_transform(const Math::Transform<3> &t)
   * template void trace_ray(Trace::Result &result, Trace::Ray
     &incident, const Math::VectorPair3 &local, const Math::VectorPair3
     &intersect) const
   * void update_version()

Sys::SourcePoint class reference
================================

Declaration
-----------

     #include <Goptical/Sys/SourcePoint>

     namespace Goptical {
       namespace Sys {
         class SourcePoint;
       };
     };


   This class is a member of the Sys namespace.

Inheritance
-----------

Description
-----------

This class implement a point light source.  The source can either be
infinitely far away with a direction vector, or located at a given
position but without direction.

   A ray is generated for each defined spectrum line for each
distribution pattern point on target surface.

   Default wavelen list contains a single 550nm entry.

Members
-------

See also the full member list (*note
Sys_SourcePoint_class_full_member_list::) section for this class.

Inherited members
.................

   * 48 members inherited from Source (*note
     Sys_Source_class_reference::)

Functions
.........

   * SourcePoint(SourceInfinityMode m, const Math::Vector3 &pos_dir)
   * void set_infinity_direction(const Math::Vector3 &dir)
   * void set_mode(SourceInfinityMode mode)
   * void set_position(const Math::Vector3 &pos)

Members detail
--------------

SourcePoint(SourceInfinityMode m, const Math::Vector3 &pos_dir)
...............................................................

Create a point source with given mode.  A direction vector must be
provided when source is in infinity mode.  If not in infinity mode, a
position vector must be provided instead.

void set_infinity_direction(const Math::Vector3 &dir)
.....................................................

Set point source mode to infinity and adjust source direction vector

void set_mode(SourceInfinityMode mode)
......................................

Change current point source infinity mode

void set_position(const Math::Vector3 &pos)
...........................................

This function shadows the 'set_position (*note _1321::)' function
defined in the 'Element (*note Sys_Element_class_reference::)' base
class.

   Set point source mode to positioned and adjust source position vector

Sys::SourcePoint class full member list
=======================================

Types
-----

   * typedef _ [...]  _ mod_delegate_t
   * typedef _ [...]  _ put_delegate_t
   * typedef _ [...]  _ targets_t

Functions
---------

   * SourcePoint(SourceInfinityMode m, const Math::Vector3 &pos_dir)
   * void add_spectral_line(const Light::SpectralLine &l)
   * void clear_spectrum()
   * virtual void draw_2d_e(Io::Renderer &r, const Element *ref) const
   * virtual void draw_3d_e(Io::Renderer &r, const Element *ref) const
   * template void generate_rays(Trace::Result &result, const
     Source::targets_t &entry) const
   * virtual Math::VectorPair3 get_bounding_box() const
   * Math::Vector3 get_direction(const Element &e) const
   * Math::Vector3 get_direction() const
   * const Math::Transform<3> & get_global_transform() const
   * Math::Vector3 get_local_direction() const
   * Math::VectorPair3 get_local_plane() const
   * const Math::Vector3 & get_local_position() const
   * const Math::Transform<3> & get_local_transform() const
   * double get_max_intensity() const
   * double get_min_intensity() const
   * Group * get_parent() const
   * Math::VectorPair3 get_plane() const
   * Math::VectorPair3 get_plane(const Element &e) const
   * Math::Vector3 get_position(const Element &e) const
   * Math::Vector3 get_position() const
   * System * get_system() const
   * const Math::Transform<3> & get_transform() const
   * const Math::Transform<3> & get_transform_from(const Element &e)
     const
   * const Math::Transform<3> & get_transform_from(const Element *e)
     const
   * const Math::Transform<3> & get_transform_to(const Element &e) const
   * const Math::Transform<3> & get_transform_to(const Element *e) const
   * unsigned int get_version() const
   * unsigned int id() const
   * bool is_enabled() const
   * virtual void print(std::ostream &o) const
   * template void process_rays(Trace::Result &result,
     Trace::rays_queue_t *input) const
   * void rotate(double x, double y, double z)
   * void set_direction(const Math::Vector3 &v)
   * void set_enable_state(bool enabled)
   * void set_infinity_direction(const Math::Vector3 &dir)
   * void set_local_direction(const Math::Vector3 &v)
   * void set_local_plane(const Math::VectorPair3 &p)
   * void set_local_position(const Math::Vector3 &v)
   * void set_material(const const_ref<Material::Base> &m)
   * void set_mode(SourceInfinityMode mode)
   * void set_plane(const Math::VectorPair3 &p)
   * void set_position(const Math::Vector3 &pos)
   * void set_spectral_line(const Light::SpectralLine &l, int index =
     _[...]_)
   * void set_transform(const Math::Transform<3> &t)
   * void single_spectral_line(const Light::SpectralLine &l)
   * void update_version()

Sys::SourceRays class reference
===============================

Declaration
-----------

     #include <Goptical/Sys/SourceRays>

     namespace Goptical {
       namespace Sys {
         class SourceRays;
       };
     };


   This class is a member of the Sys namespace.

Inheritance
-----------

Description
-----------

This class implement a light source which generates user defined rays.

   Default wavelen list contains a single 550nm entry.

Members
-------

See also the full member list (*note
Sys_SourceRays_class_full_member_list::) section for this class.

Inherited members
.................

   * 48 members inherited from Source (*note
     Sys_Source_class_reference::)

Functions
.........

   * SourceRays(const Math::Vector3 &object = _[...]_)
   * void add_chief_rays(const System &sys)
   * void add_chief_rays(const Surface &s)
   * void add_marginal_rays(const System &sys, double entrance_height =
     _[...]_)
   * void add_marginal_rays(const Surface &s, double entrance_height =
     _[...]_)
   * void add_ray(const Light::Ray &ray, const Element *ref = _[...]_)
   * void add_rays(const Math::VectorPair3 &ray, const Element *ref =
     _[...]_)
   * void clear_rays()

Members detail
--------------

SourceRays(const Math::Vector3 &object = Math::vector3_0)
.........................................................

Create a rays source.  Source object position is used by some of the
'add_*' functions and may be specified.

void add_chief_rays(const System &sys)
......................................

Add chief rays to system entrance pupil for all defined wavelengths.

void add_chief_rays(const Surface &s)
.....................................

Add chief rays to specified surface for all defined wavelengths.

void add_marginal_rays(const System &sys, double entrance_height = 0.)
......................................................................

Add marginal rays to system entrance pupil for all defined wavelengths.

   See also add_marginal_rays (*note _1243::) function.

void add_marginal_rays(const Surface &s, double entrance_height = 0.)
.....................................................................

Add marginal rays to specified surface for all defined wavelengths.

   Source direction (rotation) is used to determine tangential plane.

   Entrance height is set to surface aperture radius when 0.

void add_ray(const Light::Ray &ray, const Element *ref = 0)
...........................................................

Add a single light ray; rays properties are copied from specified light
ray.

   Ray origin and direction are expressed in specified 'ref' element
coordinates or global coordinates if none is specified.

void add_rays(const Math::VectorPair3 &ray, const Element *ref = 0)
...................................................................

Creates light rays from position and direction for all defined
wavelengths.

   Ray origin and direction are expressed in specified 'ref' element
coordinates or global coordinates if none is specified.

void clear_rays()
.................

Discard all defined rays

Sys::SourceRays class full member list
======================================

Types
-----

   * typedef _ [...]  _ mod_delegate_t
   * typedef _ [...]  _ put_delegate_t
   * typedef _ [...]  _ targets_t

Functions
---------

   * SourceRays(const Math::Vector3 &object = _[...]_)
   * void add_chief_rays(const System &sys)
   * void add_chief_rays(const Surface &s)
   * void add_marginal_rays(const System &sys, double entrance_height =
     _[...]_)
   * void add_marginal_rays(const Surface &s, double entrance_height =
     _[...]_)
   * void add_ray(const Light::Ray &ray, const Element *ref = _[...]_)
   * void add_rays(const Math::VectorPair3 &ray, const Element *ref =
     _[...]_)
   * void add_spectral_line(const Light::SpectralLine &l)
   * void clear_rays()
   * void clear_spectrum()
   * virtual void draw_2d_e(Io::Renderer &r, const Element *ref) const
   * virtual void draw_3d_e(Io::Renderer &r, const Element *ref) const
   * template void generate_rays(Trace::Result &result, const
     Source::targets_t &entry) const
   * virtual Math::VectorPair3 get_bounding_box() const
   * Math::Vector3 get_direction(const Element &e) const
   * Math::Vector3 get_direction() const
   * const Math::Transform<3> & get_global_transform() const
   * Math::Vector3 get_local_direction() const
   * Math::VectorPair3 get_local_plane() const
   * const Math::Vector3 & get_local_position() const
   * const Math::Transform<3> & get_local_transform() const
   * double get_max_intensity() const
   * double get_min_intensity() const
   * Group * get_parent() const
   * Math::VectorPair3 get_plane() const
   * Math::VectorPair3 get_plane(const Element &e) const
   * Math::Vector3 get_position(const Element &e) const
   * Math::Vector3 get_position() const
   * System * get_system() const
   * const Math::Transform<3> & get_transform() const
   * const Math::Transform<3> & get_transform_from(const Element &e)
     const
   * const Math::Transform<3> & get_transform_from(const Element *e)
     const
   * const Math::Transform<3> & get_transform_to(const Element &e) const
   * const Math::Transform<3> & get_transform_to(const Element *e) const
   * unsigned int get_version() const
   * unsigned int id() const
   * bool is_enabled() const
   * virtual void print(std::ostream &o) const
   * template void process_rays(Trace::Result &result,
     Trace::rays_queue_t *input) const
   * void rotate(double x, double y, double z)
   * void set_direction(const Math::Vector3 &v)
   * void set_enable_state(bool enabled)
   * void set_local_direction(const Math::Vector3 &v)
   * void set_local_plane(const Math::VectorPair3 &p)
   * void set_local_position(const Math::Vector3 &v)
   * void set_material(const const_ref<Material::Base> &m)
   * void set_plane(const Math::VectorPair3 &p)
   * void set_position(const Math::Vector3 &v)
   * void set_spectral_line(const Light::SpectralLine &l, int index =
     _[...]_)
   * void set_transform(const Math::Transform<3> &t)
   * void single_spectral_line(const Light::SpectralLine &l)
   * void update_version()

Sys::System class reference
===========================

Declaration
-----------

     #include <Goptical/Sys/System>

     namespace Goptical {
       namespace Sys {
         class System;
       };
     };


   This class is a member of the Sys namespace.

Inheritance
-----------

Description
-----------

This class is used to describe an optical system.  Any optical element
(*note Sys_Element_class_reference::) may be part of a system.  This
class handle 3d transformation between elements local coordinates.

   See also Building the optical system (*note Building the optical
system::) section.

Members
-------

See also the full member list (*note
Sys_System_class_full_member_list::) section for this class.

Inherited members
.................

   * 16 members inherited from Container (*note
     Sys_Container_class_reference::)

Functions
.........

   * System()
   * virtual ~System()
   * Surface * colide_next(const Trace::Params &params,
     Math::VectorPair3 &intersect, const Trace::Ray &ray) const
   * Element & get_element(unsigned int index) const
   * unsigned int get_element_count() const
   * const Surface & get_entrance_pupil() const
   * const Material::Base & get_environment() const
   * const Surface & get_exit_pupil() const
   * const Math::Transform<3> & get_global_transform(const Element
     &from) const
   * const Math::Transform<3> & get_local_transform(const Element &to)
     const
   * const Trace::Params & get_tracer_params() const
   * Trace::Params & get_tracer_params()
   * const Math::Transform<3> & get_transform(const Element &from, const
     Element &to) const
   * unsigned int get_version() const
   * bool has_entrance_pupil() const
   * bool has_exit_pupil() const
   * void set_entrance_pupil(const const_ref<Surface> &entrance)
   * void set_environment(const const_ref<Material::Base> &env)
   * void set_exit_pupil(const const_ref<Surface> &exit)
   * void undef_entrance_pupil()
   * void update_version()

Members detail
--------------

System()
........

Create a new empty system.

virtual ~System()
.................

No documentation available

Surface * colide_next(const Trace::Params &params, Math::VectorPair3 &intersect, const Trace::Ray &ray) const
.............................................................................................................

Find surface which colides with the given ray and update intersection
point

Element & get_element(unsigned int index) const
...............................................

Get registered element.  first element has index 1

unsigned int get_element_count() const
......................................

Get the number of registered elements in the system

const Surface & get_entrance_pupil() const
..........................................

Get defined entrance pupil surface or try to guess it if none defined

const Material::Base & get_environment() const
..............................................

get environment material

const Surface & get_exit_pupil() const
......................................

Get exit pupil

const Math::Transform<3> & get_global_transform(const Element &from) const
..........................................................................

Get transform from element local to global coordinates

const Math::Transform<3> & get_local_transform(const Element &to) const
.......................................................................

Get transform from global to element local coordinates

const Trace::Params & get_tracer_params() const
...............................................

Get default tracer parameters

Trace::Params & get_tracer_params()
...................................

Get default tracer parameters

const Math::Transform<3> & get_transform(const Element &from, const Element &to) const
......................................................................................

Get transform between two elements local coordinates

unsigned int get_version() const
................................

Get system version.  version is updated each time system or associated
elements properties are changed

bool has_entrance_pupil() const
...............................

Test if an entrance pupil has been defined

bool has_exit_pupil() const
...........................

Test if an exit pupil has been defined

void set_entrance_pupil(const const_ref <Surface> &entrance)
............................................................

Define an entrance pupil surface used to project source rays

void set_environment(const const_ref <Material::Base> &env)
...........................................................

set environment material

void set_exit_pupil(const const_ref <Surface> &exit)
....................................................

Define an exit pupil surface

void undef_entrance_pupil()
...........................

Discard defined entrance pupil

void update_version()
.....................

Increase current system version

Sys::System class full member list
==================================

Type
----

   * typedef _ [...]  _ element_list_t

Functions
---------

   * System()
   * virtual ~System()
   * void add(const ref<Element> &e)
   * Surface * colide_next(const Trace::Params &params,
     Math::VectorPair3 &intersect, const Trace::Ray &ray) const
   * template bool contains(const X *x) const
   * void draw_2d(Io::Renderer &r) const
   * void draw_2d_fit(Io::RendererViewport &r, bool keep_aspect =
     _[...]_)  const
   * void draw_3d(Io::Renderer &r) const
   * void draw_3d_fit(Io::RendererViewport &r, double z_offset =
     _[...]_)  const
   * template void enable_single(const X &e)
   * template X * find() const
   * Math::VectorPair3 get_bounding_box() const
   * Element & get_element(unsigned int index) const
   * unsigned int get_element_count() const
   * const Container::element_list_t & get_element_list() const
   * template void get_elements(const delegate<void(const X&)> &d) const
   * template void get_elements(const delegate<void(X&)> &d)
   * const Surface & get_entrance_pupil() const
   * const Material::Base & get_environment() const
   * const Surface & get_exit_pupil() const
   * const Math::Transform<3> & get_global_transform(const Element
     &from) const
   * const Math::Transform<3> & get_local_transform(const Element &to)
     const
   * const Trace::Params & get_tracer_params() const
   * Trace::Params & get_tracer_params()
   * const Math::Transform<3> & get_transform(const Element &from, const
     Element &to) const
   * unsigned int get_version() const
   * bool has_entrance_pupil() const
   * bool has_exit_pupil() const
   * void remove(Element &e)
   * void set_entrance_pupil(const const_ref<Surface> &entrance)
   * void set_environment(const const_ref<Material::Base> &env)
   * void set_exit_pupil(const const_ref<Surface> &exit)
   * void undef_entrance_pupil()
   * void update_version()

Sys::Container class reference
==============================

Declaration
-----------

     #include <Goptical/Sys/Container>

     namespace Goptical {
       namespace Sys {
         class Container;
       };
     };


   This class is a member of the Sys namespace.

   This abstract class contains pure virtuals.

Inheritance
-----------

Description
-----------

This class base contains optical elements membership management code.
It's used as a base class for System (*note
Sys_System_class_reference::) and Group (*note
Sys_Group_class_reference::) classes.

Members
-------

See also the full member list (*note
Sys_Container_class_full_member_list::) section for this class.

Type
....

   * typedef _ [...]  _ element_list_t

Functions
.........

   * Container()
   * virtual ~Container()
   * void add(const ref<Element> &e)
   * template bool contains(const X *x) const
   * void draw_2d(Io::Renderer &r) const
   * void draw_2d_fit(Io::RendererViewport &r, bool keep_aspect =
     _[...]_)  const
   * void draw_3d(Io::Renderer &r) const
   * void draw_3d_fit(Io::RendererViewport &r, double z_offset =
     _[...]_)  const
   * template void enable_single(const X &e)
   * template X * find() const
   * Math::VectorPair3 get_bounding_box() const
   * const element_list_t & get_element_list() const
   * template void get_elements(const delegate<void(const X&)> &d) const
   * template void get_elements(const delegate<void(X&)> &d)
   * void remove(Element &e)

Members detail
--------------

Container()
...........

No documentation available

virtual ~Container()
....................

No documentation available

void add(const ref <Element> &e)
................................

Add an element

template <typename X> bool contains(const X *x) const
.....................................................

Test if element is contained in container and subcontainers

void draw_2d(Io::Renderer &r) const
...................................

Draw system 2d layout using specified renderer.

   See also draw_2d_fit (*note _1273::) function.

void draw_2d_fit(Io::RendererViewport &r, bool keep_aspect = true) const
........................................................................

Setup the renderer 2d viewport to best fit for this system or element
group.

   This function calls Io::Renderer::set_window and
Io::Renderer::set_feature_size (*note _369::).

void draw_3d(Io::Renderer &r) const
...................................

Draw system in 3d using specified renderer.

   See also draw_3d_fit (*note _1275::) function.

void draw_3d_fit(Io::RendererViewport &r, double z_offset = 0) const
....................................................................

Move the renderer 3d camera to best fit for this system or element
group.

   This function calls Io::RendererViewport::set_camera_transform (*note
_466::) and Io::Renderer::set_feature_size (*note _369::).

typedef std:: list <ref<Element> > element_list_t
.................................................

No documentation available

template <typename X> void enable_single(const X &e)
....................................................

Disable all elements of specified type which are not specified element

template <typename X> X * find() const
......................................

Find first element of type X in container and subcontainers

Math::VectorPair3 get_bounding_box() const
..........................................

Get system or element group bounding box

const element_list_t & get_element_list() const
...............................................

Return a reference to container children list

template <typename X> void get_elements(const delegate <void(const X&)> &d) const
.................................................................................

Invoke a delegate for each element of type X in container and
subcontainers

template <typename X> void get_elements(const delegate <void(X&)> &d)
.....................................................................

Invoke a modifier delegate for each element of type X in container and
subcontainers

void remove(Element &e)
.......................

Remove an element

Sys::Container class full member list
=====================================

Type
----

   * typedef _ [...]  _ element_list_t

Functions
---------

   * Container()
   * virtual ~Container()
   * void add(const ref<Element> &e)
   * template bool contains(const X *x) const
   * void draw_2d(Io::Renderer &r) const
   * void draw_2d_fit(Io::RendererViewport &r, bool keep_aspect =
     _[...]_)  const
   * void draw_3d(Io::Renderer &r) const
   * void draw_3d_fit(Io::RendererViewport &r, double z_offset =
     _[...]_)  const
   * template void enable_single(const X &e)
   * template X * find() const
   * Math::VectorPair3 get_bounding_box() const
   * const element_list_t & get_element_list() const
   * template void get_elements(const delegate<void(const X&)> &d) const
   * template void get_elements(const delegate<void(X&)> &d)
   * void remove(Element &e)

Sys::Element class reference
============================

Declaration
-----------

     #include <Goptical/Sys/Element>

     namespace Goptical {
       namespace Sys {
         class Element;
       };
     };


   This class is a member of the Sys namespace.

Inheritance
-----------

Description
-----------

This is the base class for all optical elements.

   Instances of this class may be registered as members of the Container
(*note Sys_Container_class_reference::) class.  It handles element
position and transform to parent coordinates.

   This class has virtual functions which must be reimplemented to
handle incoming rays.

Members
-------

See also the full member list (*note
Sys_Element_class_full_member_list::) section for this class.

Types
.....

   * typedef _ [...]  _ mod_delegate_t
   * typedef _ [...]  _ put_delegate_t

Functions
.........

   * Element(const Math::VectorPair3 &plane)
   * virtual ~Element()
   * virtual void draw_2d_e(Io::Renderer &r, const Element *ref) const
   * virtual void draw_3d_e(Io::Renderer &r, const Element *ref) const
   * virtual Math::VectorPair3 get_bounding_box() const
   * Math::Vector3 get_direction(const Element &e) const
   * Math::Vector3 get_direction() const
   * const Math::Transform<3> & get_global_transform() const
   * Math::Vector3 get_local_direction() const
   * Math::VectorPair3 get_local_plane() const
   * const Math::Vector3 & get_local_position() const
   * const Math::Transform<3> & get_local_transform() const
   * Group * get_parent() const
   * Math::VectorPair3 get_plane() const
   * Math::VectorPair3 get_plane(const Element &e) const
   * Math::Vector3 get_position(const Element &e) const
   * Math::Vector3 get_position() const
   * System * get_system() const
   * const Math::Transform<3> & get_transform() const
   * const Math::Transform<3> & get_transform_from(const Element &e)
     const
   * const Math::Transform<3> & get_transform_from(const Element *e)
     const
   * const Math::Transform<3> & get_transform_to(const Element &e) const
   * const Math::Transform<3> & get_transform_to(const Element *e) const
   * unsigned int get_version() const
   * unsigned int id() const
   * bool is_enabled() const
   * virtual void print(std::ostream &o) const
   * template void process_rays(Trace::Result &result,
     Trace::rays_queue_t *input) const
   * void rotate(double x, double y, double z)
   * void set_direction(const Math::Vector3 &v)
   * void set_enable_state(bool enabled)
   * void set_local_direction(const Math::Vector3 &v)
   * void set_local_plane(const Math::VectorPair3 &p)
   * void set_local_position(const Math::Vector3 &v)
   * void set_plane(const Math::VectorPair3 &p)
   * void set_position(const Math::Vector3 &v)
   * void set_transform(const Math::Transform<3> &t)
   * void update_version()

Members detail
--------------

Element(const Math::VectorPair3 &plane)
.......................................

Create a new optical element with given position and direction in parent
coordinates system.

virtual ~Element()
..................

No documentation available

virtual void draw_2d_e(Io::Renderer &r, const Element *ref) const
.................................................................

Draw element 2d layout using the given renderer in given element
coordinates.

virtual void draw_3d_e(Io::Renderer &r, const Element *ref) const
.................................................................

Draw element in 3d using the given renderer in given element coordinates

virtual Math::VectorPair3 get_bounding_box() const
..................................................

Get bounding box in local coordinates

Math::Vector3 get_direction(const Element &e) const
...................................................

Get element direction in given element coordinate system

Math::Vector3 get_direction() const
...................................

Get element direction in system global coordinates

const Math::Transform<3> & get_global_transform() const
.......................................................

Get transform from this element local to global coordinates

Math::Vector3 get_local_direction() const
.........................................

Get element direction in parent coordinate system

Math::VectorPair3 get_local_plane() const
.........................................

Get reference plane (position and direction) in parent coordinate system

   See also get_local_direction (*note _1292::) function and
get_local_position (*note _1294::) function.

const Math::Vector3 & get_local_position() const
................................................

Get element position in parent local coordinate system

const Math::Transform<3> & get_local_transform() const
......................................................

Get transform from global to this element local coordinates

Group * get_parent() const
..........................

Get a pointer to parent element, if any.

Math::VectorPair3 get_plane() const
...................................

Get reference plane (position and direction) in system global
coordinates

   See also get_direction (*note _1289::) function and get_position
(*note _1299::) function.

Math::VectorPair3 get_plane(const Element &e) const
...................................................

Get reference plane (position and direction) in given element
coordinates

   See also get_direction (*note _1289::) function and get_position
(*note _1299::) function.

Math::Vector3 get_position(const Element &e) const
..................................................

Get element position in given element coordinate system

Math::Vector3 get_position() const
..................................

Get element position in system global coordinate system

System * get_system() const
...........................

Get a pointer to system

const Math::Transform<3> & get_transform() const
................................................

Get transform from this element to parent element coordinate system

const Math::Transform<3> & get_transform_from(const Element &e) const
.....................................................................

Get transform from given element to this element coordinate system

const Math::Transform<3> & get_transform_from(const Element *e) const
.....................................................................

Get transform from given element to this element coordinate system.
Transform from global coordinates is returned if paramter is 0.

const Math::Transform<3> & get_transform_to(const Element &e) const
...................................................................

Get transform from this element to given element coordinate system

const Math::Transform<3> & get_transform_to(const Element *e) const
...................................................................

Get transform from this element to given element coordinate system.
Transform to global coordinates is returned if paramter is 0.

unsigned int get_version() const
................................

Get element version.  version is updated each time element or its
children properties are changed

unsigned int id() const
.......................

Get element identifer in current system

bool is_enabled() const
.......................

Return true if element must be considered

typedef delegate <void(Element&)> mod_delegate_t
................................................

No documentation available

virtual void print(std:: ostream &o) const
..........................................

No documentation available

template <Trace::IntensityMode m> void process_rays(Trace::Result &result, Trace::rays_queue_t *input) const
............................................................................................................

Batch process a list of light rays interacting with element.  This
function is only used in sequential ray trace mode.

typedef delegate <void(const Element&)> put_delegate_t
......................................................

No documentation available

void rotate(double x, double y, double z)
.........................................

Rotate element direction.  angles are in degrees

void set_direction(const Math::Vector3 &v)
..........................................

Set element direction in system global coordinates

void set_enable_state(bool enabled)
...................................

Set enable state

void set_local_direction(const Math::Vector3 &v)
................................................

Set element direction in parent coordinate system

void set_local_plane(const Math::VectorPair3 &p)
................................................

Set reference plane (position and direction) in parent coordinate system

   See also set_local_direction (*note _1317::) function and
set_local_position (*note _1319::) function.

void set_local_position(const Math::Vector3 &v)
...............................................

Set element position in parent local coordinate system

void set_plane(const Math::VectorPair3 &p)
..........................................

Set reference plane (position and direction) in system global
coordinates

   See also set_direction (*note _1315::) function and set_position
(*note _1321::) function.

void set_position(const Math::Vector3 &v)
.........................................

Set element position in system global coordinate system

void set_transform(const Math::Transform<3> &t)
...............................................

Set transform to parant coordinate system

void update_version()
.....................

Increase current element version

Sys::Element class full member list
===================================

Types
-----

   * typedef _ [...]  _ mod_delegate_t
   * typedef _ [...]  _ put_delegate_t

Functions
---------

   * Element(const Math::VectorPair3 &plane)
   * virtual ~Element()
   * virtual void draw_2d_e(Io::Renderer &r, const Element *ref) const
   * virtual void draw_3d_e(Io::Renderer &r, const Element *ref) const
   * virtual Math::VectorPair3 get_bounding_box() const
   * Math::Vector3 get_direction(const Element &e) const
   * Math::Vector3 get_direction() const
   * const Math::Transform<3> & get_global_transform() const
   * Math::Vector3 get_local_direction() const
   * Math::VectorPair3 get_local_plane() const
   * const Math::Vector3 & get_local_position() const
   * const Math::Transform<3> & get_local_transform() const
   * Group * get_parent() const
   * Math::VectorPair3 get_plane() const
   * Math::VectorPair3 get_plane(const Element &e) const
   * Math::Vector3 get_position(const Element &e) const
   * Math::Vector3 get_position() const
   * System * get_system() const
   * const Math::Transform<3> & get_transform() const
   * const Math::Transform<3> & get_transform_from(const Element &e)
     const
   * const Math::Transform<3> & get_transform_from(const Element *e)
     const
   * const Math::Transform<3> & get_transform_to(const Element &e) const
   * const Math::Transform<3> & get_transform_to(const Element *e) const
   * unsigned int get_version() const
   * unsigned int id() const
   * bool is_enabled() const
   * virtual void print(std::ostream &o) const
   * template void process_rays(Trace::Result &result,
     Trace::rays_queue_t *input) const
   * void rotate(double x, double y, double z)
   * void set_direction(const Math::Vector3 &v)
   * void set_enable_state(bool enabled)
   * void set_local_direction(const Math::Vector3 &v)
   * void set_local_plane(const Math::VectorPair3 &p)
   * void set_local_position(const Math::Vector3 &v)
   * void set_plane(const Math::VectorPair3 &p)
   * void set_position(const Math::Vector3 &v)
   * void set_transform(const Math::Transform<3> &t)
   * void update_version()

Sys::Source class reference
===========================

Declaration
-----------

     #include <Goptical/Sys/Source>

     namespace Goptical {
       namespace Sys {
         class Source;
       };
     };


   This class is a member of the Sys namespace.

Inheritance
-----------

Description
-----------

This class is the base class for all light sources implementations.

Members
-------

See also the full member list (*note
Sys_Source_class_full_member_list::) section for this class.

Inherited members
.................

   * 40 members inherited from Element (*note
     Sys_Element_class_reference::)

Type
....

   * typedef _ [...]  _ targets_t

Functions
.........

   * Source(const Math::VectorPair3 &position)
   * void add_spectral_line(const Light::SpectralLine &l)
   * void clear_spectrum()
   * template void generate_rays(Trace::Result &result, const targets_t
     &entry) const
   * double get_max_intensity() const
   * double get_min_intensity() const
   * void set_material(const const_ref<Material::Base> &m)
   * void set_spectral_line(const Light::SpectralLine &l, int index =
     _[...]_)
   * void single_spectral_line(const Light::SpectralLine &l)

Members detail
--------------

Source(const Math::VectorPair3 &position)
.........................................

Create a source at given position.

void add_spectral_line(const Light::SpectralLine &l)
....................................................

Add a new wavelen for ray generation

void clear_spectrum()
.....................

Clear wavelen list

template <Trace::IntensityMode m> void generate_rays(Trace::Result &result, const targets_t &entry) const
.........................................................................................................

Generate light rays from source

double get_max_intensity() const
................................

Get maximal spectral line intensity

double get_min_intensity() const
................................

Get minimal spectral line intensity

void set_material(const const_ref <Material::Base> &m)
......................................................

Set material where light rays are generated.  system environment
material is used by default.

void set_spectral_line(const Light::SpectralLine &l, int index = 0)
...................................................................

Set a wavelen in list for ray generation

void single_spectral_line(const Light::SpectralLine &l)
.......................................................

Clear ray wavelen list and set a single wavelen

typedef std:: vector <const Sys::Element*> targets_t
....................................................

No documentation available

Sys::Source class full member list
==================================

Types
-----

   * typedef _ [...]  _ mod_delegate_t
   * typedef _ [...]  _ put_delegate_t
   * typedef _ [...]  _ targets_t

Functions
---------

   * Source(const Math::VectorPair3 &position)
   * void add_spectral_line(const Light::SpectralLine &l)
   * void clear_spectrum()
   * virtual void draw_2d_e(Io::Renderer &r, const Element *ref) const
   * virtual void draw_3d_e(Io::Renderer &r, const Element *ref) const
   * template void generate_rays(Trace::Result &result, const targets_t
     &entry) const
   * virtual Math::VectorPair3 get_bounding_box() const
   * Math::Vector3 get_direction(const Element &e) const
   * Math::Vector3 get_direction() const
   * const Math::Transform<3> & get_global_transform() const
   * Math::Vector3 get_local_direction() const
   * Math::VectorPair3 get_local_plane() const
   * const Math::Vector3 & get_local_position() const
   * const Math::Transform<3> & get_local_transform() const
   * double get_max_intensity() const
   * double get_min_intensity() const
   * Group * get_parent() const
   * Math::VectorPair3 get_plane() const
   * Math::VectorPair3 get_plane(const Element &e) const
   * Math::Vector3 get_position(const Element &e) const
   * Math::Vector3 get_position() const
   * System * get_system() const
   * const Math::Transform<3> & get_transform() const
   * const Math::Transform<3> & get_transform_from(const Element &e)
     const
   * const Math::Transform<3> & get_transform_from(const Element *e)
     const
   * const Math::Transform<3> & get_transform_to(const Element &e) const
   * const Math::Transform<3> & get_transform_to(const Element *e) const
   * unsigned int get_version() const
   * unsigned int id() const
   * bool is_enabled() const
   * virtual void print(std::ostream &o) const
   * template void process_rays(Trace::Result &result,
     Trace::rays_queue_t *input) const
   * void rotate(double x, double y, double z)
   * void set_direction(const Math::Vector3 &v)
   * void set_enable_state(bool enabled)
   * void set_local_direction(const Math::Vector3 &v)
   * void set_local_plane(const Math::VectorPair3 &p)
   * void set_local_position(const Math::Vector3 &v)
   * void set_material(const const_ref<Material::Base> &m)
   * void set_plane(const Math::VectorPair3 &p)
   * void set_position(const Math::Vector3 &v)
   * void set_spectral_line(const Light::SpectralLine &l, int index =
     _[...]_)
   * void set_transform(const Math::Transform<3> &t)
   * void single_spectral_line(const Light::SpectralLine &l)
   * void update_version()

Sys::Stop class reference
=========================

Declaration
-----------

     #include <Goptical/Sys/Stop>

     namespace Goptical {
       namespace Sys {
         class Stop;
       };
     };


   This class is a member of the Sys namespace.

Inheritance
-----------

Description
-----------

This class implements an aperture stop surface.

   This surface will block all rays which fall outside the surface shape
and inside the external radius.  (All rays which pass at a distance from
the axis greater than the external radius are not affected.)

   Rays which fall inside the surface shape may either be intercepted
and reemited or unaffected.  Rays are always intercepted in sequential
raytrace mode.  In non-sequential mode this can be changed with
set_intercept_reemit (*note _1339::); default is disabled.

Members
-------

See also the full member list (*note Sys_Stop_class_full_member_list::)
section for this class.

Inherited members
.................

   * 48 members inherited from Surface (*note
     Sys_Surface_class_reference::)

Functions
.........

   * Stop(const Math::VectorPair3 &p, const const_ref<Shape::Base>
     &shape)
   * Stop(const Math::VectorPair3 &p, double radius)
   * double get_external_radius() const
   * bool get_intercept_reemit() const
   * void set_external_radius(double external_radius)
   * void set_intercept_reemit(bool intercept_reemit)

Members detail
--------------

Stop(const Math::VectorPair3 &p, const const_ref <Shape::Base> &shape)
......................................................................

Create an aperture stop surface.  External radius is set to twice the
shape max radius.

Stop(const Math::VectorPair3 &p, double radius)
...............................................

Create a circular aperture stop surface with given radius.  External
radius is set to twice the shape max radius.

double get_external_radius() const
..................................

Get stop external radius.  .

   See also set_external_radius (*note _1338::) function and Stop (*note
Sys_Stop_class_reference::) class.

bool get_intercept_reemit() const
.................................

Get intercept and reemit enabled.  .

   See also set_intercept_reemit (*note _1339::) function and Stop
(*note Sys_Stop_class_reference::) class.

void set_external_radius(double external_radius)
................................................

Set stop external radius.  .

   See also get_external_radius (*note _1336::) function and Stop (*note
Sys_Stop_class_reference::) class.

void set_intercept_reemit(bool intercept_reemit)
................................................

Set intercept and reemit enabled.  .

   See also get_intercept_reemit (*note _1337::) function and Stop
(*note Sys_Stop_class_reference::) class.

Sys::Stop class full member list
================================

Types
-----

   * typedef _ [...]  _ mod_delegate_t
   * typedef _ [...]  _ put_delegate_t

Functions
---------

   * Stop(const Math::VectorPair3 &p, const const_ref<Shape::Base>
     &shape)
   * Stop(const Math::VectorPair3 &p, double radius)
   * virtual Math::VectorPair3 get_bounding_box() const
   * virtual Io::Rgb get_color(const Io::Renderer &r) const
   * const Curve::Base & get_curve() const
   * Math::Vector3 get_direction(const Element &e) const
   * Math::Vector3 get_direction() const
   * double get_discard_intensity() const
   * double get_external_radius() const
   * const Math::Transform<3> & get_global_transform() const
   * bool get_intercept_reemit() const
   * Math::Vector3 get_local_direction() const
   * Math::VectorPair3 get_local_plane() const
   * const Math::Vector3 & get_local_position() const
   * const Math::Transform<3> & get_local_transform() const
   * Group * get_parent() const
   * void get_pattern(const Math::Vector3::put_delegate_t &f, const
     Trace::Distribution &d, bool unobstructed = _[...]_)  const
   * Math::VectorPair3 get_plane() const
   * Math::VectorPair3 get_plane(const Element &e) const
   * Math::Vector3 get_position(const Element &e) const
   * Math::Vector3 get_position() const
   * const Shape::Base & get_shape() const
   * System * get_system() const
   * const Math::Transform<3> & get_transform() const
   * const Math::Transform<3> & get_transform_from(const Element &e)
     const
   * const Math::Transform<3> & get_transform_from(const Element *e)
     const
   * const Math::Transform<3> & get_transform_to(const Element &e) const
   * const Math::Transform<3> & get_transform_to(const Element *e) const
   * unsigned int get_version() const
   * unsigned int id() const
   * bool is_enabled() const
   * virtual void print(std::ostream &o) const
   * template void process_rays(Trace::Result &result,
     Trace::rays_queue_t *input) const
   * void rotate(double x, double y, double z)
   * void set_curve(const const_ref<Curve::Base> &c)
   * void set_direction(const Math::Vector3 &v)
   * void set_discard_intensity(double intensity)
   * void set_enable_state(bool enabled)
   * void set_external_radius(double external_radius)
   * void set_intercept_reemit(bool intercept_reemit)
   * void set_local_direction(const Math::Vector3 &v)
   * void set_local_plane(const Math::VectorPair3 &p)
   * void set_local_position(const Math::Vector3 &v)
   * void set_plane(const Math::VectorPair3 &p)
   * void set_position(const Math::Vector3 &v)
   * void set_shape(const const_ref<Shape::Base> &s)
   * void set_transform(const Math::Transform<3> &t)
   * template void trace_ray(Trace::Result &result, Trace::Ray
     &incident, const Math::VectorPair3 &local, const Math::VectorPair3
     &intersect) const
   * void update_version()

Sys::Surface class reference
============================

Declaration
-----------

     #include <Goptical/Sys/Surface>

     namespace Goptical {
       namespace Sys {
         class Surface;
       };
     };


   This class is a member of the Sys namespace.

Inheritance
-----------

Description
-----------

This is the base class for surface element.  A surface element is
defined by its position, surface curve and contour shape.

   This class can handle incoming rays and is responsible for finding
rays intersection with the surface.

   Depending on ray trace intensity mode, it will potentially adjust
light absorption and then call trace_ray_simple, trace_ray_intensity or
trace_ray_polarized.  These functions must be reimplemented in sub
classes, default implementations will throw.

Members
-------

See also the full member list (*note
Sys_Surface_class_full_member_list::) section for this class.

Inherited members
.................

   * 40 members inherited from Element (*note
     Sys_Element_class_reference::)

Functions
.........

   * Surface(const Math::VectorPair3 &p, const const_ref<Curve::Base>
     &curve, const const_ref<Shape::Base> &shape)
   * virtual ~Surface()
   * virtual Math::VectorPair3 get_bounding_box() const
   * virtual Io::Rgb get_color(const Io::Renderer &r) const
   * const Curve::Base & get_curve() const
   * double get_discard_intensity() const
   * void get_pattern(const Math::Vector3::put_delegate_t &f, const
     Trace::Distribution &d, bool unobstructed = _[...]_)  const
   * const Shape::Base & get_shape() const
   * virtual bool intersect(const Trace::Params &params,
     Math::VectorPair3 &pt, const Math::VectorPair3 &ray) const
   * void set_curve(const const_ref<Curve::Base> &c)
   * void set_discard_intensity(double intensity)
   * void set_shape(const const_ref<Shape::Base> &s)
   * template void trace_ray(Trace::Result &result, Trace::Ray
     &incident, const Math::VectorPair3 &local, const Math::VectorPair3
     &intersect) const

Members detail
--------------

Surface(const Math::VectorPair3 &p, const const_ref <Curve::Base> &curve, const const_ref <Shape::Base> &shape)
...............................................................................................................

Create a surface element at given location.

virtual ~Surface()
..................

No documentation available

virtual Math::VectorPair3 get_bounding_box() const
..................................................

This virtual function overrides the 'get_bounding_box (*note _1288::)'
virtual function defined in the 'Element (*note
Sys_Element_class_reference::)' base class.

   Documentation inherited from base class:

   Get bounding box in local coordinates

virtual Io::Rgb get_color(const Io::Renderer &r) const
......................................................

Get surface apparent color

const Curve::Base & get_curve() const
.....................................

Get surface curve

double get_discard_intensity() const
....................................

Get minimal ray intensity.

void get_pattern(const Math::Vector3::put_delegate_t &f, const Trace::Distribution &d, bool unobstructed = false) const
.......................................................................................................................

Get distribution pattern points projected on the surface

const Shape::Base & get_shape() const
.....................................

Get surface shape

virtual bool intersect(const Trace::Params &params, Math::VectorPair3 &pt, const Math::VectorPair3 &ray) const
..............................................................................................................

Get intersection point and normal to surface at intersection.  Return
false if no intersection occured.

void set_curve(const const_ref <Curve::Base> &c)
................................................

Set surface curve

void set_discard_intensity(double intensity)
............................................

Set minimal ray intensity.  Incident rays with less intensity will be
discarded

void set_shape(const const_ref <Shape::Base> &s)
................................................

Set surface shape

template <Trace::IntensityMode m> void trace_ray(Trace::Result &result, Trace::Ray &incident, const Math::VectorPair3 &local, const Math::VectorPair3 &intersect) const
.......................................................................................................................................................................

Trace a single ray through the surface

Sys::Surface class full member list
===================================

Types
-----

   * typedef _ [...]  _ mod_delegate_t
   * typedef _ [...]  _ put_delegate_t

Functions
---------

   * Surface(const Math::VectorPair3 &p, const const_ref<Curve::Base>
     &curve, const const_ref<Shape::Base> &shape)
   * virtual ~Surface()
   * virtual Math::VectorPair3 get_bounding_box() const
   * virtual Io::Rgb get_color(const Io::Renderer &r) const
   * const Curve::Base & get_curve() const
   * Math::Vector3 get_direction(const Element &e) const
   * Math::Vector3 get_direction() const
   * double get_discard_intensity() const
   * const Math::Transform<3> & get_global_transform() const
   * Math::Vector3 get_local_direction() const
   * Math::VectorPair3 get_local_plane() const
   * const Math::Vector3 & get_local_position() const
   * const Math::Transform<3> & get_local_transform() const
   * Group * get_parent() const
   * void get_pattern(const Math::Vector3::put_delegate_t &f, const
     Trace::Distribution &d, bool unobstructed = _[...]_)  const
   * Math::VectorPair3 get_plane() const
   * Math::VectorPair3 get_plane(const Element &e) const
   * Math::Vector3 get_position(const Element &e) const
   * Math::Vector3 get_position() const
   * const Shape::Base & get_shape() const
   * System * get_system() const
   * const Math::Transform<3> & get_transform() const
   * const Math::Transform<3> & get_transform_from(const Element &e)
     const
   * const Math::Transform<3> & get_transform_from(const Element *e)
     const
   * const Math::Transform<3> & get_transform_to(const Element &e) const
   * const Math::Transform<3> & get_transform_to(const Element *e) const
   * unsigned int get_version() const
   * unsigned int id() const
   * virtual bool intersect(const Trace::Params &params,
     Math::VectorPair3 &pt, const Math::VectorPair3 &ray) const
   * bool is_enabled() const
   * virtual void print(std::ostream &o) const
   * template void process_rays(Trace::Result &result,
     Trace::rays_queue_t *input) const
   * void rotate(double x, double y, double z)
   * void set_curve(const const_ref<Curve::Base> &c)
   * void set_direction(const Math::Vector3 &v)
   * void set_discard_intensity(double intensity)
   * void set_enable_state(bool enabled)
   * void set_local_direction(const Math::Vector3 &v)
   * void set_local_plane(const Math::VectorPair3 &p)
   * void set_local_position(const Math::Vector3 &v)
   * void set_plane(const Math::VectorPair3 &p)
   * void set_position(const Math::Vector3 &v)
   * void set_shape(const const_ref<Shape::Base> &s)
   * void set_transform(const Math::Transform<3> &t)
   * template void trace_ray(Trace::Result &result, Trace::Ray
     &incident, const Math::VectorPair3 &local, const Math::VectorPair3
     &intersect) const
   * void update_version()

Trace namespace reference
=========================

Description
-----------

Ray tracer and light propagation

Members
-------

Types
.....

   * class Distribution
   * class Params
   * class Result
   * class Sequence
   * class Tracer
   * enum IntensityMode
   * enum Pattern
   * class Ray
   * typedef _ [...]  _ rays_queue_t

Function
........

   * std::ostream & operator<<(std::ostream &o, const Sequence &s)

Members detail
--------------

enum IntensityMode
..................

Specifies light intensity calculation mode to use by light propagation
algorithms.

Identifier             Description
--------------------------------------------------------------------------
SimpleTrace            No Intensity calculation is performed
                       
IntensityTrace         Light intensity computation is performed without
                       taking polarization into account
                       
PolarizedTrace         Light intensity with polarization computation is
                       performed (not supported yet)
                       

enum Pattern
............

Specifies point distribution patterns over a shape delimited surface.

[Different patterns rendered on a disk with default density]
Identifier             Description
--------------------------------------------------------------------------
DefaultDist            Preferred distribution pattern for a given shape
                       
SagittalDist           Sagittal plane distribution (along the X axis,
                       X/Z plane)
                       
MeridionalDist         Meridional plane distribution (along the Y axis,
                       Y/Z plane)
                       
TangentialDist         Tangential plane distribution, same as
                       MeridionalDist (*note _1354::)
                       
CrossDist              Sagittal and Meridional distribution combined
                       
SquareDist             Square pattern distribution
                       
TriangularDist         Triangular pattern distribution
                       
HexaPolarDist          Hexapolar pattern, suitable for circular shapes
                       
RandomDist             Random distribution
                       

   See also Distribution (*note Trace_Distribution_class_reference::)
class.

std:: ostream & operator<<(std:: ostream &o, const Sequence &s)
...............................................................

No documentation available

typedef std:: deque <Ray*> rays_queue_t
.......................................

No documentation available

Trace::Distribution class reference
===================================

Declaration
-----------

     #include <Goptical/Trace/Distribution>

     namespace Goptical {
       namespace Trace {
         class Distribution;
       };
     };


   This class is a member of the Trace namespace.

Description
-----------

This class describes distribution pattern and ray density used for light
ray distribution over surfaces during light propagation.

   Ray density is expressed as average number of rays along surface
radius.

[Different patterns rendered on a disk with default density]
Members
-------

See also the full member list (*note
Trace_Distribution_class_full_member_list::) section for this class.

Functions
.........

   * Distribution(Pattern pattern = _[...]_, unsigned int radial_density
     = _[...]_, double scaling = _[...]_)
   * Pattern get_pattern() const
   * unsigned int get_radial_density() const
   * double get_scaling() const
   * void set_pattern(Pattern p)
   * void set_radial_density(unsigned int count)
   * void set_scaling(double scaling)
   * void set_uniform_pattern()

Members detail
--------------

Distribution(Pattern pattern = DefaultDist, unsigned int radial_density = 5, double scaling = 0.999)
....................................................................................................

Creates a distribution pattern with specified pattern, radial ray
density and scaling.

   The scaling ratio parameter may be used to avoid distributing rays
too close to the surface edge.

Pattern get_pattern() const
...........................

Get distribution pattern

unsigned int get_radial_density() const
.......................................

Get current radial density

double get_scaling() const
..........................

get current scaling

void set_pattern(Pattern p)
...........................

Set distribution pattern

void set_radial_density(unsigned int count)
...........................................

Set average number of ray to distribute on surface radius

void set_scaling(double scaling)
................................

Set scaling, Rays are distributed on surface but are kept away from
surface edge if scaling is less than 1.0.

void set_uniform_pattern()
..........................

Ensure uniform 2d pattern suitable for spot diagram and image analysis
is selected.  Change to default pattern if not.

Trace::Distribution class full member list
==========================================

Functions
---------

   * Distribution(Pattern pattern = _[...]_, unsigned int radial_density
     = _[...]_, double scaling = _[...]_)
   * Pattern get_pattern() const
   * unsigned int get_radial_density() const
   * double get_scaling() const
   * void set_pattern(Pattern p)
   * void set_radial_density(unsigned int count)
   * void set_scaling(double scaling)
   * void set_uniform_pattern()

Trace::Params class reference
=============================

Declaration
-----------

     #include <Goptical/Trace/Params>

     namespace Goptical {
       namespace Trace {
         class Params;
       };
     };


   This class is a member of the Trace namespace.

Description
-----------

This class is used to store light progation parameters.  This includes
sequential / non-sequential mode, light intensity computation mode and
propagation mode (raytracing, diffraction, ...).

   See also Performing light propagation (*note Performing light
propagation::) section.

Members
-------

See also the full member list (*note
Trace_Params_class_full_member_list::) section for this class.

Functions
.........

   * Params()
   * const Distribution & get_default_distribution() const
   * Distribution & get_default_distribution()
   * const Distribution & get_distribution(const Sys::Surface &s) const
   * IntensityMode get_intensity_mode() const
   * double get_lost_ray_length() const
   * unsigned int get_max_bounce() const
   * bool get_unobstructed() const
   * bool is_sequential() const
   * void reset_distribution()
   * void set_default_distribution(const Distribution
     &default_distribution)
   * void set_distribution(const Sys::Surface &s, const Distribution
     &dist)
   * void set_intensity_mode(IntensityMode intensity_mode)
   * void set_lost_ray_length(double lost_ray_length)
   * void set_max_bounce(unsigned int max_bounce)
   * void set_nonsequential_mode()
   * void set_sequential_mode(const const_ref<Sequence> &seq)
   * void set_unobstructed(bool unobstructed)

Members detail
--------------

Params()
........

No documentation available

const Distribution & get_default_distribution() const
.....................................................

Get default rays distribution pattern.

   See also set_default_distribution (*note _1375::) function.

Distribution & get_default_distribution()
.........................................

Get default rays distribution pattern.

   See also set_default_distribution (*note _1375::) function.

const Distribution & get_distribution(const Sys::Surface &s) const
..................................................................

Get distribution pattern for a given surface

IntensityMode get_intensity_mode() const
........................................

Get raytracing intensity mode.

   See also set_intensity_mode (*note _1377::) function.

double get_lost_ray_length() const
..................................

Get lost ray length.

   See also set_lost_ray_length (*note _1378::) function.

unsigned int get_max_bounce() const
...................................

Get maximum ray bounce count, default is 50.

   See also set_max_bounce (*note _1379::) function.

bool get_unobstructed() const
.............................

Get unobstructed raytracing mode.  Surface shapes are ignored, no rays
are stopped.

   See also set_unobstructed (*note _1382::) function.

bool is_sequential() const
..........................

Test if in sequential ray tracing mode

void reset_distribution()
.........................

Reset all surface specific distribution settings to default

void set_default_distribution(const Distribution &default_distribution)
.......................................................................

Set default rays distribution pattern.

   See also get_default_distribution (*note _1366::) function.

void set_distribution(const Sys::Surface &s, const Distribution &dist)
......................................................................

Set distribution pattern for a given surface

void set_intensity_mode(IntensityMode intensity_mode)
.....................................................

Set raytracing intensity mode.

   See also get_intensity_mode (*note _1369::) function.

void set_lost_ray_length(double lost_ray_length)
................................................

Set lost ray length.

   See also get_lost_ray_length (*note _1370::) function.

void set_max_bounce(unsigned int max_bounce)
............................................

Set maximum ray bounce count, default is 50.

   See also get_max_bounce (*note _1371::) function.

void set_nonsequential_mode()
.............................

Set non sequential ray tracing mode (default)

void set_sequential_mode(const const_ref <Sequence> &seq)
.........................................................

Set sequential ray tracing mode

void set_unobstructed(bool unobstructed)
........................................

Set unobstructed raytracing mode.  Surface shapes are ignored, no rays
are stopped.

   See also get_unobstructed (*note _1372::) function.

Trace::Params class full member list
====================================

Functions
---------

   * Params()
   * const Distribution & get_default_distribution() const
   * Distribution & get_default_distribution()
   * const Distribution & get_distribution(const Sys::Surface &s) const
   * IntensityMode get_intensity_mode() const
   * double get_lost_ray_length() const
   * unsigned int get_max_bounce() const
   * bool get_unobstructed() const
   * bool is_sequential() const
   * void reset_distribution()
   * void set_default_distribution(const Distribution
     &default_distribution)
   * void set_distribution(const Sys::Surface &s, const Distribution
     &dist)
   * void set_intensity_mode(IntensityMode intensity_mode)
   * void set_lost_ray_length(double lost_ray_length)
   * void set_max_bounce(unsigned int max_bounce)
   * void set_nonsequential_mode()
   * void set_sequential_mode(const const_ref<Sequence> &seq)
   * void set_unobstructed(bool unobstructed)

Trace::Result class reference
=============================

Declaration
-----------

     #include <Goptical/Trace/Result>

     namespace Goptical {
       namespace Trace {
         class Result;
       };
     };


   This class is a member of the Trace namespace.

Description
-----------

This class encapsulates rays data propagation result.

   It must be properly configured before light propagation as needed by
the analysis currently being performed.  All requested light propagation
informations will be store for further processing.

   All Ray (*note Trace_Ray_class_reference::) object are allocated by
this class.  It is able to remember which element intercepted and
generated each ray.

Members
-------

See also the full member list (*note
Trace_Result_class_full_member_list::) section for this class.

Type
....

   * typedef _ [...]  _ sources_t

Functions
.........

   * Result()
   * ~Result()
   * void add_generated(const Sys::Element &s, Ray &ray)
   * void add_intercepted(const Sys::Surface &s, Ray &ray)
   * void add_ray_wavelen(double wavelen)
   * void clear()
   * void clear_save_states()
   * void draw_2d(Io::Renderer &r, bool hit_image = _[...]_, const
     Sys::Element *ref = _[...]_)  const
   * void draw_3d(Io::Renderer &r, bool hit_image = _[...]_, const
     Sys::Element *ref = _[...]_)  const
   * const rays_queue_t & get_generated(const Sys::Element &s) const
   * bool get_generated_save_state(const Sys::Element &e)
   * const rays_queue_t & get_intercepted(const Sys::Surface &s) const
   * Math::Vector3 get_intercepted_center(const Sys::Surface &s) const
   * Math::Vector3 get_intercepted_centroid(const Sys::Surface &s) const
   * bool get_intercepted_save_state(const Sys::Element &e)
   * Math::VectorPair3 get_intercepted_window(const Sys::Surface &s)
     const
   * double get_max_ray_intensity() const
   * const Params & get_params() const
   * const std::set<double> & get_ray_wavelen_set() const
   * const sources_t & get_source_list() const
   * Ray & new_ray()
   * Ray & new_ray(const Light::Ray &r)
   * void set_generated_save_state(const Sys::Element &e, bool enabled =
     _[...]_)
   * void set_intercepted_save_state(const Sys::Element &e, bool enabled
     = _[...]_)

Members detail
--------------

Result()
........

Crate a new empty result object

~Result()
.........

No documentation available

void add_generated(const Sys::Element &s, Ray &ray)
...................................................

Declare a new ray generation

void add_intercepted(const Sys::Surface &s, Ray &ray)
.....................................................

Declare a new ray interception

void add_ray_wavelen(double wavelen)
....................................

Declare ray wavelen used for tracing

void clear()
............

Clear all result data

void clear_save_states()
........................

Set all save states to false

void draw_2d(Io::Renderer &r, bool hit_image = false, const Sys::Element *ref = 0) const
........................................................................................

Draw all tangential rays using specified renderer.  Only rays which end
up hitting the image plane are drawn when 'hit_image' is set.

void draw_3d(Io::Renderer &r, bool hit_image = false, const Sys::Element *ref = 0) const
........................................................................................

Draw all rays using specified renderer.  Only rays which end up hitting
the image plane are drawn when 'hit_image' is set.

const rays_queue_t & get_generated(const Sys::Element &s) const
...............................................................

Get the list of rays generated by a given element

bool get_generated_save_state(const Sys::Element &e)
....................................................

Return true if generated rays must be saved for this element

const rays_queue_t & get_intercepted(const Sys::Surface &s) const
.................................................................

Get the list of rays striking a given surface

Math::Vector3 get_intercepted_center(const Sys::Surface &s) const
.................................................................

Get center of window

Math::Vector3 get_intercepted_centroid(const Sys::Surface &s) const
...................................................................

Get centroid of all ray intercepted on a surface

bool get_intercepted_save_state(const Sys::Element &e)
......................................................

Return true if generated rays must be saved for this element

Math::VectorPair3 get_intercepted_window(const Sys::Surface &s) const
.....................................................................

Get window which include all ray intercepted on a surface

double get_max_ray_intensity() const
....................................

Get maximum intensity for a single ray FIXME

const Params & get_params() const
.................................

Get reference to tracer parameters used

const std:: set <double> & get_ray_wavelen_set() const
......................................................

Get ray wavelen in use set

const sources_t & get_source_list() const
.........................................

Get list of sources used for ray tracing

Ray & new_ray()
...............

Allocate a new Trace::Ray object from result

Ray & new_ray(const Light::Ray &r)
..................................

Allocate a new Trace::Ray object from result

void set_generated_save_state(const Sys::Element &e, bool enabled = true)
.........................................................................

List of rays generated by this element must be saved when tracing rays

void set_intercepted_save_state(const Sys::Element &e, bool enabled = true)
...........................................................................

List of rays striking this surface must be saved when tracing rays

typedef std:: vector <const Sys::Source*> sources_t
...................................................

No documentation available

Trace::Result class full member list
====================================

Type
----

   * typedef _ [...]  _ sources_t

Functions
---------

   * Result()
   * ~Result()
   * void add_generated(const Sys::Element &s, Ray &ray)
   * void add_intercepted(const Sys::Surface &s, Ray &ray)
   * void add_ray_wavelen(double wavelen)
   * void clear()
   * void clear_save_states()
   * void draw_2d(Io::Renderer &r, bool hit_image = _[...]_, const
     Sys::Element *ref = _[...]_)  const
   * void draw_3d(Io::Renderer &r, bool hit_image = _[...]_, const
     Sys::Element *ref = _[...]_)  const
   * const rays_queue_t & get_generated(const Sys::Element &s) const
   * bool get_generated_save_state(const Sys::Element &e)
   * const rays_queue_t & get_intercepted(const Sys::Surface &s) const
   * Math::Vector3 get_intercepted_center(const Sys::Surface &s) const
   * Math::Vector3 get_intercepted_centroid(const Sys::Surface &s) const
   * bool get_intercepted_save_state(const Sys::Element &e)
   * Math::VectorPair3 get_intercepted_window(const Sys::Surface &s)
     const
   * double get_max_ray_intensity() const
   * const Params & get_params() const
   * const std::set<double> & get_ray_wavelen_set() const
   * const sources_t & get_source_list() const
   * Ray & new_ray()
   * Ray & new_ray(const Light::Ray &r)
   * void set_generated_save_state(const Sys::Element &e, bool enabled =
     _[...]_)
   * void set_intercepted_save_state(const Sys::Element &e, bool enabled
     = _[...]_)

Trace::Sequence class reference
===============================

Declaration
-----------

     #include <Goptical/Trace/Sequence>

     namespace Goptical {
       namespace Trace {
         class Sequence;
       };
     };


   This class is a member of the Trace namespace.

Inheritance
-----------

Description
-----------

There are two light propagation modes in common use: sequential and non
sequential.  When using the sequential mode, light only interacts with
sequence elements in given sequence order.

   This class will hold the user defined ordered list of elements used
by sequential light propagation algorithm implemented in the Tracer
(*note Trace_Tracer_class_reference::) class.

Members
-------

See also the full member list (*note
Trace_Sequence_class_full_member_list::) section for this class.

Functions
.........

   * Sequence()
   * Sequence(const Sys::System &system)
   * void add(const Sys::System &system)
   * unsigned int append(const Sys::Element &element)
   * void clear()
   * const Sys::Element & get_element(unsigned int index) const
   * void insert(unsigned int index, const Sys::Element &element)
   * void remove(unsigned int index)

Members detail
--------------

Sequence()
..........

Create a new empty sequence

Sequence(const Sys::System &system)
...................................

Create a new sequence and insert all elements present in the system.
This is equivalent to calling add() on empty sequence.

void add(const Sys::System &system)
...................................

Add all elements from the given system.  Element are sorted in axis
order starting from left; reflecting elements do reverse direction.

unsigned int append(const Sys::Element &element)
................................................

Insert an element at end of sequence.

   The return value is position of the element in the sequence

void clear()
............

Remove all elements from sequence

const Sys::Element & get_element(unsigned int index) const
..........................................................

Get a reference to an element in sequence

void insert(unsigned int index, const Sys::Element &element)
............................................................

Insert an element in sequence at given position

void remove(unsigned int index)
...............................

Remove an element from sequence

Trace::Sequence class full member list
======================================

Functions
---------

   * Sequence()
   * Sequence(const Sys::System &system)
   * void add(const Sys::System &system)
   * unsigned int append(const Sys::Element &element)
   * void clear()
   * const Sys::Element & get_element(unsigned int index) const
   * void insert(unsigned int index, const Sys::Element &element)
   * void remove(unsigned int index)

Trace::Tracer class reference
=============================

Declaration
-----------

     #include <Goptical/Trace/Tracer>

     namespace Goptical {
       namespace Trace {
         class Tracer;
       };
     };


   This class is a member of the Trace namespace.

Description
-----------

This class handle light propagation in an optical system.

   Propagation result is stored in a Result (*note
Trace_Result_class_reference::) object.  Propagation parameters are
stored in a Params (*note Trace_Params_class_reference::) object.

   See also Performing light propagation (*note Performing light
propagation::) section.

Members
-------

See also the full member list (*note
Trace_Tracer_class_full_member_list::) section for this class.

Functions
.........

   * Tracer(const const_ref<Sys::System> &system)
   * ~Tracer()
   * const Params & get_params() const
   * Params & get_params()
   * const Sys::System & get_system() const
   * Result & get_trace_result() const
   * Result & set_default_trace_result()
   * void set_params(const Params &params)
   * void set_trace_result(Result &res)
   * void trace()

Members detail
--------------

Tracer(const const_ref <Sys::System> &system)
.............................................

Create a new Light porpagator object

~Tracer()
.........

No documentation available

const Params & get_params() const
.................................

get tracer parameters

Params & get_params()
.....................

get tracer parameters

const Sys::System & get_system() const
......................................

Get attached system

Result & get_trace_result() const
.................................

No documentation available

Result & set_default_trace_result()
...................................

Undefine user defined Result object.  Next ray trace operation will
allocate a new internal trace result object

void set_params(const Params &params)
.....................................

replace all tracer parameters

void set_trace_result(Result &res)
..................................

Set the Result object which must be used to store ray tracing data.  a
new Result object will be allocated on first ray trace operation if none
were defined.

void trace()
............

Launch ray tracing operation

Trace::Tracer class full member list
====================================

Functions
---------

   * Tracer(const const_ref<Sys::System> &system)
   * ~Tracer()
   * const Params & get_params() const
   * Params & get_params()
   * const Sys::System & get_system() const
   * Result & get_trace_result() const
   * Result & set_default_trace_result()
   * void set_params(const Params &params)
   * void set_trace_result(Result &res)
   * void trace()

Trace::Ray class reference
==========================

Declaration
-----------

     #include <Goptical/Trace/Ray>

     namespace Goptical {
       namespace Trace {
         class Ray;
       };
     };


   This class is a member of the Trace namespace.

Inheritance
-----------

Description
-----------

This class is used to describe a Light::Ray (*note
Light_Ray_class_reference::) with all tracing and propagation
informations attached.

Members
-------

See also the full member list (*note Trace_Ray_class_full_member_list::)
section for this class.

Inherited members
.................

   * 36 members inherited from Light::Ray (*note
     Light_Ray_class_reference::)

Functions
.........

   * Ray()
   * Ray(const Light::Ray &r)
   * void add_generated(Ray *r)
   * const Sys::Element * get_creator() const
   * Math::Vector3 get_direction() const
   * Math::Vector3 get_direction(const Sys::Element &e) const
   * Ray * get_first_child() const
   * Sys::Element & get_intercept_element() const
   * double get_intercept_intensity() const
   * const Math::Vector3 & get_intercept_point() const
   * double get_len() const
   * const Material::Base * get_material() const
   * Ray * get_next_child() const
   * Ray * get_parent() const
   * Math::Vector3 get_position() const
   * Math::Vector3 get_position(const Sys::Element &e) const
   * bool is_lost() const
   * void set_creator(const Sys::Element *creator)
   * void set_intercept(const Sys::Element &e, const Math::Vector3
     &point)
   * void set_intercept_intensity(double intercept_intensity)
   * void set_len(double len)
   * void set_material(const Material::Base *material)

Members detail
--------------

Ray()
.....

This constructor shadows the 'Ray (*note _489::)' constructor defined in
the 'Ray (*note Light_Ray_class_reference::)' base class.

   Create a propagated light ray

Ray(const Light::Ray &r)
........................

Create a propagated light ray

void add_generated(Ray *r)
..........................

Define a new child generated ray

const Sys::Element * get_creator() const
........................................

Get element which generated this ray..

   See also set_creator (*note _1443::) function.

Math::Vector3 get_direction() const
...................................

Get global direction

Math::Vector3 get_direction(const Sys::Element &e) const
........................................................

Get direction relative to given element

Ray * get_first_child() const
.............................

Get first ray generated from this one

Sys::Element & get_intercept_element() const
............................................

Get light ray interception element

double get_intercept_intensity() const
......................................

Get ray intensity at interception point..

   See also set_intercept_intensity (*note _1445::) function.

const Math::Vector3 & get_intercept_point() const
.................................................

Get light ray interception point

double get_len() const
......................

Get light ray length..

   See also set_len (*note _1446::) function.

const Material::Base * get_material() const
...........................................

Get material ray is propagated in..

   See also set_material (*note _1447::) function.

Ray * get_next_child() const
............................

Get next sibling ray generated by same parent

Ray * get_parent() const
........................

Get ray which generated this one

Math::Vector3 get_position() const
..................................

Get global position

Math::Vector3 get_position(const Sys::Element &e) const
.......................................................

Get position relative to given element

bool is_lost() const
....................

Return true if ray is not intercepted

void set_creator(const Sys::Element *creator)
.............................................

Set element which generated this ray..

   See also get_creator (*note _1429::) function.

void set_intercept(const Sys::Element &e, const Math::Vector3 &point)
.....................................................................

Set light ray interception point and element

void set_intercept_intensity(double intercept_intensity)
........................................................

Set ray intensity at interception point..

   See also get_intercept_intensity (*note _1434::) function.

void set_len(double len)
........................

Set light ray length..

   See also get_len (*note _1436::) function.

void set_material(const Material::Base *material)
.................................................

Set material ray is propagated in..

   See also get_material (*note _1437::) function.

Trace::Ray class full member list
=================================

Functions
---------

   * Ray()
   * Ray(const Light::Ray &r)
   * void add_generated(Ray *r)
   * Math::Vector<N> & direction()
   * const Math::Vector<N> & direction() const
   * const Sys::Element * get_creator() const
   * Math::Vector3 get_direction() const
   * Math::Vector3 get_direction(const Sys::Element &e) const
   * Ray * get_first_child() const
   * double get_intensity() const
   * Sys::Element & get_intercept_element() const
   * double get_intercept_intensity() const
   * const Math::Vector3 & get_intercept_point() const
   * double get_len() const
   * const Material::Base * get_material() const
   * Ray * get_next_child() const
   * Ray * get_parent() const
   * Math::Vector3 get_position() const
   * Math::Vector3 get_position(const Sys::Element &e) const
   * double get_wavelen() const
   * bool is_lost() const
   * Math::Vector<3> ln_ln_clst_pt(const Math::VectorPair<3> &line)
     const
   * double ln_ln_clst_pt_scale(const Math::VectorPair<3> &line) const
   * Math::Vector<N> ln_pt_clst_pt(const Math::Vector<N> &point) const
   * double ln_pt_clst_pt_scale(const Math::Vector<N> &point) const
   * Math::Vector<N> & normal()
   * const Math::Vector<N> & normal() const
   * Math::VectorPairBase<3> operator*(double factor)
   * const Math::VectorPairBase<3> & operator+=(const
     Math::VectorPairBase<3> &p)
   * const Math::Vector<N> & operator[](int n) const
   * Math::Vector<N> & operator[](int n)
   * Math::Vector<N> & origin()
   * const Math::Vector<N> & origin() const
   * Math::Vector<3> pl_ln_intersect(const Math::VectorPair<3> &line)
     const
   * double pl_ln_intersect_scale(const Math::VectorPair<3> &line) const
   * Math::Vector<N> seg_pt_clst_pt(const Math::Vector<N> &point) const
   * double seg_pt_clst_pt_scale(const Math::Vector<N> &point) const
   * void set_creator(const Sys::Element *creator)
   * void set_intensity(double intensity)
   * void set_intercept(const Sys::Element &e, const Math::Vector3
     &point)
   * void set_intercept_intensity(double intercept_intensity)
   * void set_len(double len)
   * void set_material(const Material::Base *material)
   * void set_wavelen(double wavelen)
   * double x0() const
   * double & x0()
   * double x1() const
   * double & x1()
   * double y0() const
   * double & y0()
   * double y1() const
   * double & y1()
   * double z0() const
   * double & z0()
   * double z1() const
   * double & z1()

